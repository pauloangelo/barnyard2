/**
 * Autogenerated by Thrift Compiler (0.10.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include <string.h>
#include <thrift/c_glib/thrift.h>
#include <thrift/c_glib/thrift_application_exception.h>
#include "hbase.h"

gboolean
hbase_if_enable_table (HbaseIf *iface, const Bytes tableName, IOError ** io, GError **error)
{
  return HBASE_IF_GET_INTERFACE (iface)->enable_table (iface, tableName, io, error);
}

gboolean
hbase_if_disable_table (HbaseIf *iface, const Bytes tableName, IOError ** io, GError **error)
{
  return HBASE_IF_GET_INTERFACE (iface)->disable_table (iface, tableName, io, error);
}

gboolean
hbase_if_is_table_enabled (HbaseIf *iface, gboolean* _return, const Bytes tableName, IOError ** io, GError **error)
{
  return HBASE_IF_GET_INTERFACE (iface)->is_table_enabled (iface, _return, tableName, io, error);
}

gboolean
hbase_if_compact (HbaseIf *iface, const Bytes tableNameOrRegionName, IOError ** io, GError **error)
{
  return HBASE_IF_GET_INTERFACE (iface)->compact (iface, tableNameOrRegionName, io, error);
}

gboolean
hbase_if_major_compact (HbaseIf *iface, const Bytes tableNameOrRegionName, IOError ** io, GError **error)
{
  return HBASE_IF_GET_INTERFACE (iface)->major_compact (iface, tableNameOrRegionName, io, error);
}

gboolean
hbase_if_get_table_names (HbaseIf *iface, GPtrArray ** _return, IOError ** io, GError **error)
{
  return HBASE_IF_GET_INTERFACE (iface)->get_table_names (iface, _return, io, error);
}

gboolean
hbase_if_get_column_descriptors (HbaseIf *iface, GHashTable ** _return, const Text tableName, IOError ** io, GError **error)
{
  return HBASE_IF_GET_INTERFACE (iface)->get_column_descriptors (iface, _return, tableName, io, error);
}

gboolean
hbase_if_get_table_regions (HbaseIf *iface, GPtrArray ** _return, const Text tableName, IOError ** io, GError **error)
{
  return HBASE_IF_GET_INTERFACE (iface)->get_table_regions (iface, _return, tableName, io, error);
}

gboolean
hbase_if_create_table (HbaseIf *iface, const Text tableName, const GPtrArray * columnFamilies, IOError ** io, IllegalArgument ** ia, AlreadyExists ** exist, GError **error)
{
  return HBASE_IF_GET_INTERFACE (iface)->create_table (iface, tableName, columnFamilies, io, ia, exist, error);
}

gboolean
hbase_if_delete_table (HbaseIf *iface, const Text tableName, IOError ** io, GError **error)
{
  return HBASE_IF_GET_INTERFACE (iface)->delete_table (iface, tableName, io, error);
}

gboolean
hbase_if_get (HbaseIf *iface, GPtrArray ** _return, const Text tableName, const Text row, const Text column, const GHashTable * attributes, IOError ** io, GError **error)
{
  return HBASE_IF_GET_INTERFACE (iface)->get (iface, _return, tableName, row, column, attributes, io, error);
}

gboolean
hbase_if_get_ver (HbaseIf *iface, GPtrArray ** _return, const Text tableName, const Text row, const Text column, const gint32 numVersions, const GHashTable * attributes, IOError ** io, GError **error)
{
  return HBASE_IF_GET_INTERFACE (iface)->get_ver (iface, _return, tableName, row, column, numVersions, attributes, io, error);
}

gboolean
hbase_if_get_ver_ts (HbaseIf *iface, GPtrArray ** _return, const Text tableName, const Text row, const Text column, const gint64 timestamp, const gint32 numVersions, const GHashTable * attributes, IOError ** io, GError **error)
{
  return HBASE_IF_GET_INTERFACE (iface)->get_ver_ts (iface, _return, tableName, row, column, timestamp, numVersions, attributes, io, error);
}

gboolean
hbase_if_get_row (HbaseIf *iface, GPtrArray ** _return, const Text tableName, const Text row, const GHashTable * attributes, IOError ** io, GError **error)
{
  return HBASE_IF_GET_INTERFACE (iface)->get_row (iface, _return, tableName, row, attributes, io, error);
}

gboolean
hbase_if_get_row_with_columns (HbaseIf *iface, GPtrArray ** _return, const Text tableName, const Text row, const GPtrArray * columns, const GHashTable * attributes, IOError ** io, GError **error)
{
  return HBASE_IF_GET_INTERFACE (iface)->get_row_with_columns (iface, _return, tableName, row, columns, attributes, io, error);
}

gboolean
hbase_if_get_row_ts (HbaseIf *iface, GPtrArray ** _return, const Text tableName, const Text row, const gint64 timestamp, const GHashTable * attributes, IOError ** io, GError **error)
{
  return HBASE_IF_GET_INTERFACE (iface)->get_row_ts (iface, _return, tableName, row, timestamp, attributes, io, error);
}

gboolean
hbase_if_get_row_with_columns_ts (HbaseIf *iface, GPtrArray ** _return, const Text tableName, const Text row, const GPtrArray * columns, const gint64 timestamp, const GHashTable * attributes, IOError ** io, GError **error)
{
  return HBASE_IF_GET_INTERFACE (iface)->get_row_with_columns_ts (iface, _return, tableName, row, columns, timestamp, attributes, io, error);
}

gboolean
hbase_if_get_rows (HbaseIf *iface, GPtrArray ** _return, const Text tableName, const GPtrArray * rows, const GHashTable * attributes, IOError ** io, GError **error)
{
  return HBASE_IF_GET_INTERFACE (iface)->get_rows (iface, _return, tableName, rows, attributes, io, error);
}

gboolean
hbase_if_get_rows_with_columns (HbaseIf *iface, GPtrArray ** _return, const Text tableName, const GPtrArray * rows, const GPtrArray * columns, const GHashTable * attributes, IOError ** io, GError **error)
{
  return HBASE_IF_GET_INTERFACE (iface)->get_rows_with_columns (iface, _return, tableName, rows, columns, attributes, io, error);
}

gboolean
hbase_if_get_rows_ts (HbaseIf *iface, GPtrArray ** _return, const Text tableName, const GPtrArray * rows, const gint64 timestamp, const GHashTable * attributes, IOError ** io, GError **error)
{
  return HBASE_IF_GET_INTERFACE (iface)->get_rows_ts (iface, _return, tableName, rows, timestamp, attributes, io, error);
}

gboolean
hbase_if_get_rows_with_columns_ts (HbaseIf *iface, GPtrArray ** _return, const Text tableName, const GPtrArray * rows, const GPtrArray * columns, const gint64 timestamp, const GHashTable * attributes, IOError ** io, GError **error)
{
  return HBASE_IF_GET_INTERFACE (iface)->get_rows_with_columns_ts (iface, _return, tableName, rows, columns, timestamp, attributes, io, error);
}

gboolean
hbase_if_mutate_row (HbaseIf *iface, const Text tableName, const Text row, const GPtrArray * mutations, const GHashTable * attributes, IOError ** io, IllegalArgument ** ia, GError **error)
{
  return HBASE_IF_GET_INTERFACE (iface)->mutate_row (iface, tableName, row, mutations, attributes, io, ia, error);
}

gboolean
hbase_if_mutate_row_ts (HbaseIf *iface, const Text tableName, const Text row, const GPtrArray * mutations, const gint64 timestamp, const GHashTable * attributes, IOError ** io, IllegalArgument ** ia, GError **error)
{
  return HBASE_IF_GET_INTERFACE (iface)->mutate_row_ts (iface, tableName, row, mutations, timestamp, attributes, io, ia, error);
}

gboolean
hbase_if_mutate_rows (HbaseIf *iface, const Text tableName, const GPtrArray * rowBatches, const GHashTable * attributes, IOError ** io, IllegalArgument ** ia, GError **error)
{
  return HBASE_IF_GET_INTERFACE (iface)->mutate_rows (iface, tableName, rowBatches, attributes, io, ia, error);
}

gboolean
hbase_if_mutate_rows_ts (HbaseIf *iface, const Text tableName, const GPtrArray * rowBatches, const gint64 timestamp, const GHashTable * attributes, IOError ** io, IllegalArgument ** ia, GError **error)
{
  return HBASE_IF_GET_INTERFACE (iface)->mutate_rows_ts (iface, tableName, rowBatches, timestamp, attributes, io, ia, error);
}

gboolean
hbase_if_atomic_increment (HbaseIf *iface, gint64* _return, const Text tableName, const Text row, const Text column, const gint64 value, IOError ** io, IllegalArgument ** ia, GError **error)
{
  return HBASE_IF_GET_INTERFACE (iface)->atomic_increment (iface, _return, tableName, row, column, value, io, ia, error);
}

gboolean
hbase_if_delete_all (HbaseIf *iface, const Text tableName, const Text row, const Text column, const GHashTable * attributes, IOError ** io, GError **error)
{
  return HBASE_IF_GET_INTERFACE (iface)->delete_all (iface, tableName, row, column, attributes, io, error);
}

gboolean
hbase_if_delete_all_ts (HbaseIf *iface, const Text tableName, const Text row, const Text column, const gint64 timestamp, const GHashTable * attributes, IOError ** io, GError **error)
{
  return HBASE_IF_GET_INTERFACE (iface)->delete_all_ts (iface, tableName, row, column, timestamp, attributes, io, error);
}

gboolean
hbase_if_delete_all_row (HbaseIf *iface, const Text tableName, const Text row, const GHashTable * attributes, IOError ** io, GError **error)
{
  return HBASE_IF_GET_INTERFACE (iface)->delete_all_row (iface, tableName, row, attributes, io, error);
}

gboolean
hbase_if_increment (HbaseIf *iface, const TIncrement * increment, IOError ** io, GError **error)
{
  return HBASE_IF_GET_INTERFACE (iface)->increment (iface, increment, io, error);
}

gboolean
hbase_if_increment_rows (HbaseIf *iface, const GPtrArray * increments, IOError ** io, GError **error)
{
  return HBASE_IF_GET_INTERFACE (iface)->increment_rows (iface, increments, io, error);
}

gboolean
hbase_if_delete_all_row_ts (HbaseIf *iface, const Text tableName, const Text row, const gint64 timestamp, const GHashTable * attributes, IOError ** io, GError **error)
{
  return HBASE_IF_GET_INTERFACE (iface)->delete_all_row_ts (iface, tableName, row, timestamp, attributes, io, error);
}

gboolean
hbase_if_scanner_open_with_scan (HbaseIf *iface, ScannerID* _return, const Text tableName, const TScan * scan, const GHashTable * attributes, IOError ** io, GError **error)
{
  return HBASE_IF_GET_INTERFACE (iface)->scanner_open_with_scan (iface, _return, tableName, scan, attributes, io, error);
}

gboolean
hbase_if_scanner_open (HbaseIf *iface, ScannerID* _return, const Text tableName, const Text startRow, const GPtrArray * columns, const GHashTable * attributes, IOError ** io, GError **error)
{
  return HBASE_IF_GET_INTERFACE (iface)->scanner_open (iface, _return, tableName, startRow, columns, attributes, io, error);
}

gboolean
hbase_if_scanner_open_with_stop (HbaseIf *iface, ScannerID* _return, const Text tableName, const Text startRow, const Text stopRow, const GPtrArray * columns, const GHashTable * attributes, IOError ** io, GError **error)
{
  return HBASE_IF_GET_INTERFACE (iface)->scanner_open_with_stop (iface, _return, tableName, startRow, stopRow, columns, attributes, io, error);
}

gboolean
hbase_if_scanner_open_with_prefix (HbaseIf *iface, ScannerID* _return, const Text tableName, const Text startAndPrefix, const GPtrArray * columns, const GHashTable * attributes, IOError ** io, GError **error)
{
  return HBASE_IF_GET_INTERFACE (iface)->scanner_open_with_prefix (iface, _return, tableName, startAndPrefix, columns, attributes, io, error);
}

gboolean
hbase_if_scanner_open_ts (HbaseIf *iface, ScannerID* _return, const Text tableName, const Text startRow, const GPtrArray * columns, const gint64 timestamp, const GHashTable * attributes, IOError ** io, GError **error)
{
  return HBASE_IF_GET_INTERFACE (iface)->scanner_open_ts (iface, _return, tableName, startRow, columns, timestamp, attributes, io, error);
}

gboolean
hbase_if_scanner_open_with_stop_ts (HbaseIf *iface, ScannerID* _return, const Text tableName, const Text startRow, const Text stopRow, const GPtrArray * columns, const gint64 timestamp, const GHashTable * attributes, IOError ** io, GError **error)
{
  return HBASE_IF_GET_INTERFACE (iface)->scanner_open_with_stop_ts (iface, _return, tableName, startRow, stopRow, columns, timestamp, attributes, io, error);
}

gboolean
hbase_if_scanner_get (HbaseIf *iface, GPtrArray ** _return, const ScannerID id, IOError ** io, IllegalArgument ** ia, GError **error)
{
  return HBASE_IF_GET_INTERFACE (iface)->scanner_get (iface, _return, id, io, ia, error);
}

gboolean
hbase_if_scanner_get_list (HbaseIf *iface, GPtrArray ** _return, const ScannerID id, const gint32 nbRows, IOError ** io, IllegalArgument ** ia, GError **error)
{
  return HBASE_IF_GET_INTERFACE (iface)->scanner_get_list (iface, _return, id, nbRows, io, ia, error);
}

gboolean
hbase_if_scanner_close (HbaseIf *iface, const ScannerID id, IOError ** io, IllegalArgument ** ia, GError **error)
{
  return HBASE_IF_GET_INTERFACE (iface)->scanner_close (iface, id, io, ia, error);
}

gboolean
hbase_if_get_row_or_before (HbaseIf *iface, GPtrArray ** _return, const Text tableName, const Text row, const Text family, IOError ** io, GError **error)
{
  return HBASE_IF_GET_INTERFACE (iface)->get_row_or_before (iface, _return, tableName, row, family, io, error);
}

gboolean
hbase_if_get_region_info (HbaseIf *iface, TRegionInfo ** _return, const Text row, IOError ** io, GError **error)
{
  return HBASE_IF_GET_INTERFACE (iface)->get_region_info (iface, _return, row, io, error);
}

gboolean
hbase_if_append (HbaseIf *iface, GPtrArray ** _return, const TAppend * append, IOError ** io, GError **error)
{
  return HBASE_IF_GET_INTERFACE (iface)->append (iface, _return, append, io, error);
}

gboolean
hbase_if_check_and_put (HbaseIf *iface, gboolean* _return, const Text tableName, const Text row, const Text column, const Text value, const Mutation * mput, const GHashTable * attributes, IOError ** io, IllegalArgument ** ia, GError **error)
{
  return HBASE_IF_GET_INTERFACE (iface)->check_and_put (iface, _return, tableName, row, column, value, mput, attributes, io, ia, error);
}

GType
hbase_if_get_type (void)
{
  static GType type = 0;
  if (type == 0)
  {
    static const GTypeInfo type_info =
    {
      sizeof (HbaseIfInterface),
      NULL,  /* base_init */
      NULL,  /* base_finalize */
      NULL,  /* class_init */
      NULL,  /* class_finalize */
      NULL,  /* class_data */
      0,     /* instance_size */
      0,     /* n_preallocs */
      NULL,  /* instance_init */
      NULL   /* value_table */
    };
    type = g_type_register_static (G_TYPE_INTERFACE,
                                   "HbaseIf",
                                   &type_info, 0);
  }
  return type;
}

static void 
hbase_if_interface_init (HbaseIfInterface *iface);

G_DEFINE_TYPE_WITH_CODE (HbaseClient, hbase_client,
                         G_TYPE_OBJECT, 
                         G_IMPLEMENT_INTERFACE (TYPE_HBASE_IF,
                                                hbase_if_interface_init))

enum _HbaseClientProperties
{
  PROP_0,
  PROP_HBASE_CLIENT_INPUT_PROTOCOL,
  PROP_HBASE_CLIENT_OUTPUT_PROTOCOL
};

void
hbase_client_set_property (GObject *object, guint property_id, const GValue *value, GParamSpec *pspec)
{
  HbaseClient *client = HBASE_CLIENT (object);

  THRIFT_UNUSED_VAR (pspec);

  switch (property_id)
  {
    case PROP_HBASE_CLIENT_INPUT_PROTOCOL:
      client->input_protocol = g_value_get_object (value);
      break;
    case PROP_HBASE_CLIENT_OUTPUT_PROTOCOL:
      client->output_protocol = g_value_get_object (value);
      break;
  }
}

void
hbase_client_get_property (GObject *object, guint property_id, GValue *value, GParamSpec *pspec)
{
  HbaseClient *client = HBASE_CLIENT (object);

  THRIFT_UNUSED_VAR (pspec);

  switch (property_id)
  {
    case PROP_HBASE_CLIENT_INPUT_PROTOCOL:
      g_value_set_object (value, client->input_protocol);
      break;
    case PROP_HBASE_CLIENT_OUTPUT_PROTOCOL:
      g_value_set_object (value, client->output_protocol);
      break;
  }
}

gboolean hbase_client_send_enable_table (HbaseIf * iface, const Bytes tableName, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = HBASE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "enableTable", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "enableTable_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "tableName", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, tableName ? ((GByteArray *) tableName)->data : NULL, tableName ? ((GByteArray *) tableName)->len : 0, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean hbase_client_recv_enable_table (HbaseIf * iface, IOError ** io, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = HBASE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "enableTable", 11) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected enableTable", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *io != NULL)
            {
              g_object_unref (*io);
            }
            *io = g_object_new (TYPE_I_O_ERROR, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*io), protocol, error)) < 0)
            {
              g_object_unref (*io);
              *io = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*io != NULL)
  {
      g_set_error (error, I_O_ERROR_ERROR, I_O_ERROR_ERROR_CODE, "IOError");
      return FALSE;
  }
  return TRUE;
}

gboolean hbase_client_enable_table (HbaseIf * iface, const Bytes tableName, IOError ** io, GError ** error)
{
  if (!hbase_client_send_enable_table (iface, tableName, error))
    return FALSE;
  if (!hbase_client_recv_enable_table (iface, io, error))
    return FALSE;
  return TRUE;
}

gboolean hbase_client_send_disable_table (HbaseIf * iface, const Bytes tableName, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = HBASE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "disableTable", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "disableTable_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "tableName", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, tableName ? ((GByteArray *) tableName)->data : NULL, tableName ? ((GByteArray *) tableName)->len : 0, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean hbase_client_recv_disable_table (HbaseIf * iface, IOError ** io, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = HBASE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "disableTable", 12) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected disableTable", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *io != NULL)
            {
              g_object_unref (*io);
            }
            *io = g_object_new (TYPE_I_O_ERROR, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*io), protocol, error)) < 0)
            {
              g_object_unref (*io);
              *io = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*io != NULL)
  {
      g_set_error (error, I_O_ERROR_ERROR, I_O_ERROR_ERROR_CODE, "IOError");
      return FALSE;
  }
  return TRUE;
}

gboolean hbase_client_disable_table (HbaseIf * iface, const Bytes tableName, IOError ** io, GError ** error)
{
  if (!hbase_client_send_disable_table (iface, tableName, error))
    return FALSE;
  if (!hbase_client_recv_disable_table (iface, io, error))
    return FALSE;
  return TRUE;
}

gboolean hbase_client_send_is_table_enabled (HbaseIf * iface, const Bytes tableName, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = HBASE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "isTableEnabled", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "isTableEnabled_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "tableName", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, tableName ? ((GByteArray *) tableName)->data : NULL, tableName ? ((GByteArray *) tableName)->len : 0, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean hbase_client_recv_is_table_enabled (HbaseIf * iface, gboolean* _return, IOError ** io, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = HBASE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "isTableEnabled", 14) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected isTableEnabled", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_BOOL)
          {
            if ((ret = thrift_protocol_read_bool (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *io != NULL)
            {
              g_object_unref (*io);
            }
            *io = g_object_new (TYPE_I_O_ERROR, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*io), protocol, error)) < 0)
            {
              g_object_unref (*io);
              *io = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*io != NULL)
  {
      g_set_error (error, I_O_ERROR_ERROR, I_O_ERROR_ERROR_CODE, "IOError");
      return FALSE;
  }
  return TRUE;
}

gboolean hbase_client_is_table_enabled (HbaseIf * iface, gboolean* _return, const Bytes tableName, IOError ** io, GError ** error)
{
  if (!hbase_client_send_is_table_enabled (iface, tableName, error))
    return FALSE;
  if (!hbase_client_recv_is_table_enabled (iface, _return, io, error))
    return FALSE;
  return TRUE;
}

gboolean hbase_client_send_compact (HbaseIf * iface, const Bytes tableNameOrRegionName, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = HBASE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "compact", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "compact_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "tableNameOrRegionName", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, tableNameOrRegionName ? ((GByteArray *) tableNameOrRegionName)->data : NULL, tableNameOrRegionName ? ((GByteArray *) tableNameOrRegionName)->len : 0, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean hbase_client_recv_compact (HbaseIf * iface, IOError ** io, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = HBASE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "compact", 7) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected compact", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *io != NULL)
            {
              g_object_unref (*io);
            }
            *io = g_object_new (TYPE_I_O_ERROR, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*io), protocol, error)) < 0)
            {
              g_object_unref (*io);
              *io = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*io != NULL)
  {
      g_set_error (error, I_O_ERROR_ERROR, I_O_ERROR_ERROR_CODE, "IOError");
      return FALSE;
  }
  return TRUE;
}

gboolean hbase_client_compact (HbaseIf * iface, const Bytes tableNameOrRegionName, IOError ** io, GError ** error)
{
  if (!hbase_client_send_compact (iface, tableNameOrRegionName, error))
    return FALSE;
  if (!hbase_client_recv_compact (iface, io, error))
    return FALSE;
  return TRUE;
}

gboolean hbase_client_send_major_compact (HbaseIf * iface, const Bytes tableNameOrRegionName, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = HBASE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "majorCompact", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "majorCompact_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "tableNameOrRegionName", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, tableNameOrRegionName ? ((GByteArray *) tableNameOrRegionName)->data : NULL, tableNameOrRegionName ? ((GByteArray *) tableNameOrRegionName)->len : 0, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean hbase_client_recv_major_compact (HbaseIf * iface, IOError ** io, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = HBASE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "majorCompact", 12) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected majorCompact", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *io != NULL)
            {
              g_object_unref (*io);
            }
            *io = g_object_new (TYPE_I_O_ERROR, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*io), protocol, error)) < 0)
            {
              g_object_unref (*io);
              *io = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*io != NULL)
  {
      g_set_error (error, I_O_ERROR_ERROR, I_O_ERROR_ERROR_CODE, "IOError");
      return FALSE;
  }
  return TRUE;
}

gboolean hbase_client_major_compact (HbaseIf * iface, const Bytes tableNameOrRegionName, IOError ** io, GError ** error)
{
  if (!hbase_client_send_major_compact (iface, tableNameOrRegionName, error))
    return FALSE;
  if (!hbase_client_recv_major_compact (iface, io, error))
    return FALSE;
  return TRUE;
}

gboolean hbase_client_send_get_table_names (HbaseIf * iface, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = HBASE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getTableNames", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getTableNames_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean hbase_client_recv_get_table_names (HbaseIf * iface, GPtrArray ** _return, IOError ** io, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = HBASE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getTableNames", 13) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getTableNames", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_LIST)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType element_type;

              if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through list elements */
              for (i = 0; i < size; i++)
              {
                GByteArray * _elem194 = NULL;
                if (_elem194 != NULL)
                {
                  g_free(_elem194);
                  _elem194 = NULL;
                }

                if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                  return 0;
                xfer += ret;
                _elem194 = g_byte_array_new();
                g_byte_array_append (_elem194, (guint8 *) data, (guint) len);
                g_free (data);
                g_ptr_array_add (*_return, _elem194);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *io != NULL)
            {
              g_object_unref (*io);
            }
            *io = g_object_new (TYPE_I_O_ERROR, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*io), protocol, error)) < 0)
            {
              g_object_unref (*io);
              *io = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*io != NULL)
  {
      g_set_error (error, I_O_ERROR_ERROR, I_O_ERROR_ERROR_CODE, "IOError");
      return FALSE;
  }
  return TRUE;
}

gboolean hbase_client_get_table_names (HbaseIf * iface, GPtrArray ** _return, IOError ** io, GError ** error)
{
  if (!hbase_client_send_get_table_names (iface, error))
    return FALSE;
  if (!hbase_client_recv_get_table_names (iface, _return, io, error))
    return FALSE;
  return TRUE;
}

gboolean hbase_client_send_get_column_descriptors (HbaseIf * iface, const Text tableName, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = HBASE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getColumnDescriptors", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getColumnDescriptors_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "tableName", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, tableName ? ((GByteArray *) tableName)->data : NULL, tableName ? ((GByteArray *) tableName)->len : 0, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean hbase_client_recv_get_column_descriptors (HbaseIf * iface, GHashTable ** _return, IOError ** io, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = HBASE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getColumnDescriptors", 20) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getColumnDescriptors", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_MAP)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType key_type;
              ThriftType value_type;

              /* read the map begin marker */
              if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through each of the map's fields */
              for (i = 0; i < size; i++)
              {
                Text key195 = NULL;
                ColumnDescriptor * val196 = NULL;
                if (key195 != NULL)
                {
                  g_free(key195);
                  key195 = NULL;
                }

                if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                  return 0;
                xfer += ret;
                key195 = g_byte_array_new();
                g_byte_array_append (key195, (guint8 *) data, (guint) len);
                g_free (data);
                if ( val196 != NULL)
                {
                  g_object_unref (val196);
                }
                val196 = g_object_new (TYPE_COLUMN_DESCRIPTOR, NULL);
                if ((ret = thrift_struct_read (THRIFT_STRUCT (val196), protocol, error)) < 0)
                {
                  g_object_unref (val196);
                  return 0;
                }
                xfer += ret;
                if (*_return && key195)
                  g_hash_table_insert ((GHashTable *)*_return, (gpointer) key195, (gpointer) val196);
              }

              /* read the map end marker */
              if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *io != NULL)
            {
              g_object_unref (*io);
            }
            *io = g_object_new (TYPE_I_O_ERROR, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*io), protocol, error)) < 0)
            {
              g_object_unref (*io);
              *io = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*io != NULL)
  {
      g_set_error (error, I_O_ERROR_ERROR, I_O_ERROR_ERROR_CODE, "IOError");
      return FALSE;
  }
  return TRUE;
}

gboolean hbase_client_get_column_descriptors (HbaseIf * iface, GHashTable ** _return, const Text tableName, IOError ** io, GError ** error)
{
  if (!hbase_client_send_get_column_descriptors (iface, tableName, error))
    return FALSE;
  if (!hbase_client_recv_get_column_descriptors (iface, _return, io, error))
    return FALSE;
  return TRUE;
}

gboolean hbase_client_send_get_table_regions (HbaseIf * iface, const Text tableName, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = HBASE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getTableRegions", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getTableRegions_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "tableName", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, tableName ? ((GByteArray *) tableName)->data : NULL, tableName ? ((GByteArray *) tableName)->len : 0, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean hbase_client_recv_get_table_regions (HbaseIf * iface, GPtrArray ** _return, IOError ** io, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = HBASE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getTableRegions", 15) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getTableRegions", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_LIST)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType element_type;

              if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through list elements */
              for (i = 0; i < size; i++)
              {
                TRegionInfo * _elem197 = NULL;
                if ( _elem197 != NULL)
                {
                  g_object_unref (_elem197);
                }
                _elem197 = g_object_new (TYPE_T_REGION_INFO, NULL);
                if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem197), protocol, error)) < 0)
                {
                  g_object_unref (_elem197);
                  return 0;
                }
                xfer += ret;
                g_ptr_array_add (*_return, _elem197);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *io != NULL)
            {
              g_object_unref (*io);
            }
            *io = g_object_new (TYPE_I_O_ERROR, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*io), protocol, error)) < 0)
            {
              g_object_unref (*io);
              *io = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*io != NULL)
  {
      g_set_error (error, I_O_ERROR_ERROR, I_O_ERROR_ERROR_CODE, "IOError");
      return FALSE;
  }
  return TRUE;
}

gboolean hbase_client_get_table_regions (HbaseIf * iface, GPtrArray ** _return, const Text tableName, IOError ** io, GError ** error)
{
  if (!hbase_client_send_get_table_regions (iface, tableName, error))
    return FALSE;
  if (!hbase_client_recv_get_table_regions (iface, _return, io, error))
    return FALSE;
  return TRUE;
}

gboolean hbase_client_send_create_table (HbaseIf * iface, const Text tableName, const GPtrArray * columnFamilies, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = HBASE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "createTable", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "createTable_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "tableName", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, tableName ? ((GByteArray *) tableName)->data : NULL, tableName ? ((GByteArray *) tableName)->len : 0, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "columnFamilies", T_LIST, 2, error)) < 0)
      return 0;
    xfer += ret;
    {
      guint i198;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (columnFamilies ? columnFamilies->len : 0), error)) < 0)
        return 0;
      xfer += ret;
      for (i198 = 0; i198 < (columnFamilies ? columnFamilies->len : 0); i198++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) columnFamilies, i198))), protocol, error)) < 0)
          return 0;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean hbase_client_recv_create_table (HbaseIf * iface, IOError ** io, IllegalArgument ** ia, AlreadyExists ** exist, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = HBASE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "createTable", 11) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected createTable", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *io != NULL)
            {
              g_object_unref (*io);
            }
            *io = g_object_new (TYPE_I_O_ERROR, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*io), protocol, error)) < 0)
            {
              g_object_unref (*io);
              *io = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 2:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ia != NULL)
            {
              g_object_unref (*ia);
            }
            *ia = g_object_new (TYPE_ILLEGAL_ARGUMENT, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ia), protocol, error)) < 0)
            {
              g_object_unref (*ia);
              *ia = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 3:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *exist != NULL)
            {
              g_object_unref (*exist);
            }
            *exist = g_object_new (TYPE_ALREADY_EXISTS, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*exist), protocol, error)) < 0)
            {
              g_object_unref (*exist);
              *exist = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*io != NULL)
  {
      g_set_error (error, I_O_ERROR_ERROR, I_O_ERROR_ERROR_CODE, "IOError");
      return FALSE;
  }
  if (*ia != NULL)
  {
      g_set_error (error, ILLEGAL_ARGUMENT_ERROR, ILLEGAL_ARGUMENT_ERROR_CODE, "IllegalArgument");
      return FALSE;
  }
  if (*exist != NULL)
  {
      g_set_error (error, ALREADY_EXISTS_ERROR, ALREADY_EXISTS_ERROR_CODE, "AlreadyExists");
      return FALSE;
  }
  return TRUE;
}

gboolean hbase_client_create_table (HbaseIf * iface, const Text tableName, const GPtrArray * columnFamilies, IOError ** io, IllegalArgument ** ia, AlreadyExists ** exist, GError ** error)
{
  if (!hbase_client_send_create_table (iface, tableName, columnFamilies, error))
    return FALSE;
  if (!hbase_client_recv_create_table (iface, io, ia, exist, error))
    return FALSE;
  return TRUE;
}

gboolean hbase_client_send_delete_table (HbaseIf * iface, const Text tableName, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = HBASE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "deleteTable", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "deleteTable_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "tableName", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, tableName ? ((GByteArray *) tableName)->data : NULL, tableName ? ((GByteArray *) tableName)->len : 0, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean hbase_client_recv_delete_table (HbaseIf * iface, IOError ** io, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = HBASE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "deleteTable", 11) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected deleteTable", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *io != NULL)
            {
              g_object_unref (*io);
            }
            *io = g_object_new (TYPE_I_O_ERROR, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*io), protocol, error)) < 0)
            {
              g_object_unref (*io);
              *io = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*io != NULL)
  {
      g_set_error (error, I_O_ERROR_ERROR, I_O_ERROR_ERROR_CODE, "IOError");
      return FALSE;
  }
  return TRUE;
}

gboolean hbase_client_delete_table (HbaseIf * iface, const Text tableName, IOError ** io, GError ** error)
{
  if (!hbase_client_send_delete_table (iface, tableName, error))
    return FALSE;
  if (!hbase_client_recv_delete_table (iface, io, error))
    return FALSE;
  return TRUE;
}

gboolean hbase_client_send_get (HbaseIf * iface, const Text tableName, const Text row, const Text column, const GHashTable * attributes, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = HBASE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "get", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "get_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "tableName", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, tableName ? ((GByteArray *) tableName)->data : NULL, tableName ? ((GByteArray *) tableName)->len : 0, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "row", T_STRING, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, row ? ((GByteArray *) row)->data : NULL, row ? ((GByteArray *) row)->len : 0, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "column", T_STRING, 3, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, column ? ((GByteArray *) column)->data : NULL, column ? ((GByteArray *) column)->len : 0, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "attributes", T_MAP, 4, error)) < 0)
      return 0;
    xfer += ret;
    {
      Text key199 = NULL;
      Text val200 = NULL;
      GList *key_list = NULL, *iter = NULL;
      Text* keys;
      int i = 0, key_count;

      if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRING, attributes ? (gint32) g_hash_table_size ((GHashTable *) attributes) : 0, error)) < 0)
        return 0;
      xfer += ret;
      if (attributes)
        g_hash_table_foreach ((GHashTable *) attributes, thrift_hash_table_get_keys, &key_list);
      key_count = g_list_length (key_list);
      keys = g_newa (Text, key_count);
      for (iter = g_list_first (key_list); iter; iter = iter->next)
        keys[i++] = (Text) iter->data;
      g_list_free (key_list);

      for (i = 0; i < key_count; ++i)
      {
        key199 = keys[i];
        val200 = (Text) g_hash_table_lookup (((GHashTable *) attributes), (gpointer) key199);

        if ((ret = thrift_protocol_write_binary (protocol,  key199 ? ((GByteArray *)  key199)->data : NULL,  key199 ? ((GByteArray *)  key199)->len : 0, error)) < 0)
          return 0;
        xfer += ret;

        if ((ret = thrift_protocol_write_binary (protocol,  val200 ? ((GByteArray *)  val200)->data : NULL,  val200 ? ((GByteArray *)  val200)->len : 0, error)) < 0)
          return 0;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean hbase_client_recv_get (HbaseIf * iface, GPtrArray ** _return, IOError ** io, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = HBASE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "get", 3) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected get", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_LIST)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType element_type;

              if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through list elements */
              for (i = 0; i < size; i++)
              {
                TCell * _elem201 = NULL;
                if ( _elem201 != NULL)
                {
                  g_object_unref (_elem201);
                }
                _elem201 = g_object_new (TYPE_T_CELL, NULL);
                if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem201), protocol, error)) < 0)
                {
                  g_object_unref (_elem201);
                  return 0;
                }
                xfer += ret;
                g_ptr_array_add (*_return, _elem201);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *io != NULL)
            {
              g_object_unref (*io);
            }
            *io = g_object_new (TYPE_I_O_ERROR, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*io), protocol, error)) < 0)
            {
              g_object_unref (*io);
              *io = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*io != NULL)
  {
      g_set_error (error, I_O_ERROR_ERROR, I_O_ERROR_ERROR_CODE, "IOError");
      return FALSE;
  }
  return TRUE;
}

gboolean hbase_client_get (HbaseIf * iface, GPtrArray ** _return, const Text tableName, const Text row, const Text column, const GHashTable * attributes, IOError ** io, GError ** error)
{
  if (!hbase_client_send_get (iface, tableName, row, column, attributes, error))
    return FALSE;
  if (!hbase_client_recv_get (iface, _return, io, error))
    return FALSE;
  return TRUE;
}

gboolean hbase_client_send_get_ver (HbaseIf * iface, const Text tableName, const Text row, const Text column, const gint32 numVersions, const GHashTable * attributes, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = HBASE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getVer", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getVer_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "tableName", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, tableName ? ((GByteArray *) tableName)->data : NULL, tableName ? ((GByteArray *) tableName)->len : 0, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "row", T_STRING, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, row ? ((GByteArray *) row)->data : NULL, row ? ((GByteArray *) row)->len : 0, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "column", T_STRING, 3, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, column ? ((GByteArray *) column)->data : NULL, column ? ((GByteArray *) column)->len : 0, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "numVersions", T_I32, 4, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, numVersions, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "attributes", T_MAP, 5, error)) < 0)
      return 0;
    xfer += ret;
    {
      Text key202 = NULL;
      Text val203 = NULL;
      GList *key_list = NULL, *iter = NULL;
      Text* keys;
      int i = 0, key_count;

      if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRING, attributes ? (gint32) g_hash_table_size ((GHashTable *) attributes) : 0, error)) < 0)
        return 0;
      xfer += ret;
      if (attributes)
        g_hash_table_foreach ((GHashTable *) attributes, thrift_hash_table_get_keys, &key_list);
      key_count = g_list_length (key_list);
      keys = g_newa (Text, key_count);
      for (iter = g_list_first (key_list); iter; iter = iter->next)
        keys[i++] = (Text) iter->data;
      g_list_free (key_list);

      for (i = 0; i < key_count; ++i)
      {
        key202 = keys[i];
        val203 = (Text) g_hash_table_lookup (((GHashTable *) attributes), (gpointer) key202);

        if ((ret = thrift_protocol_write_binary (protocol,  key202 ? ((GByteArray *)  key202)->data : NULL,  key202 ? ((GByteArray *)  key202)->len : 0, error)) < 0)
          return 0;
        xfer += ret;

        if ((ret = thrift_protocol_write_binary (protocol,  val203 ? ((GByteArray *)  val203)->data : NULL,  val203 ? ((GByteArray *)  val203)->len : 0, error)) < 0)
          return 0;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean hbase_client_recv_get_ver (HbaseIf * iface, GPtrArray ** _return, IOError ** io, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = HBASE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getVer", 6) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getVer", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_LIST)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType element_type;

              if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through list elements */
              for (i = 0; i < size; i++)
              {
                TCell * _elem204 = NULL;
                if ( _elem204 != NULL)
                {
                  g_object_unref (_elem204);
                }
                _elem204 = g_object_new (TYPE_T_CELL, NULL);
                if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem204), protocol, error)) < 0)
                {
                  g_object_unref (_elem204);
                  return 0;
                }
                xfer += ret;
                g_ptr_array_add (*_return, _elem204);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *io != NULL)
            {
              g_object_unref (*io);
            }
            *io = g_object_new (TYPE_I_O_ERROR, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*io), protocol, error)) < 0)
            {
              g_object_unref (*io);
              *io = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*io != NULL)
  {
      g_set_error (error, I_O_ERROR_ERROR, I_O_ERROR_ERROR_CODE, "IOError");
      return FALSE;
  }
  return TRUE;
}

gboolean hbase_client_get_ver (HbaseIf * iface, GPtrArray ** _return, const Text tableName, const Text row, const Text column, const gint32 numVersions, const GHashTable * attributes, IOError ** io, GError ** error)
{
  if (!hbase_client_send_get_ver (iface, tableName, row, column, numVersions, attributes, error))
    return FALSE;
  if (!hbase_client_recv_get_ver (iface, _return, io, error))
    return FALSE;
  return TRUE;
}

gboolean hbase_client_send_get_ver_ts (HbaseIf * iface, const Text tableName, const Text row, const Text column, const gint64 timestamp, const gint32 numVersions, const GHashTable * attributes, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = HBASE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getVerTs", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getVerTs_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "tableName", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, tableName ? ((GByteArray *) tableName)->data : NULL, tableName ? ((GByteArray *) tableName)->len : 0, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "row", T_STRING, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, row ? ((GByteArray *) row)->data : NULL, row ? ((GByteArray *) row)->len : 0, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "column", T_STRING, 3, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, column ? ((GByteArray *) column)->data : NULL, column ? ((GByteArray *) column)->len : 0, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "timestamp", T_I64, 4, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, timestamp, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "numVersions", T_I32, 5, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, numVersions, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "attributes", T_MAP, 6, error)) < 0)
      return 0;
    xfer += ret;
    {
      Text key205 = NULL;
      Text val206 = NULL;
      GList *key_list = NULL, *iter = NULL;
      Text* keys;
      int i = 0, key_count;

      if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRING, attributes ? (gint32) g_hash_table_size ((GHashTable *) attributes) : 0, error)) < 0)
        return 0;
      xfer += ret;
      if (attributes)
        g_hash_table_foreach ((GHashTable *) attributes, thrift_hash_table_get_keys, &key_list);
      key_count = g_list_length (key_list);
      keys = g_newa (Text, key_count);
      for (iter = g_list_first (key_list); iter; iter = iter->next)
        keys[i++] = (Text) iter->data;
      g_list_free (key_list);

      for (i = 0; i < key_count; ++i)
      {
        key205 = keys[i];
        val206 = (Text) g_hash_table_lookup (((GHashTable *) attributes), (gpointer) key205);

        if ((ret = thrift_protocol_write_binary (protocol,  key205 ? ((GByteArray *)  key205)->data : NULL,  key205 ? ((GByteArray *)  key205)->len : 0, error)) < 0)
          return 0;
        xfer += ret;

        if ((ret = thrift_protocol_write_binary (protocol,  val206 ? ((GByteArray *)  val206)->data : NULL,  val206 ? ((GByteArray *)  val206)->len : 0, error)) < 0)
          return 0;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean hbase_client_recv_get_ver_ts (HbaseIf * iface, GPtrArray ** _return, IOError ** io, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = HBASE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getVerTs", 8) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getVerTs", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_LIST)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType element_type;

              if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through list elements */
              for (i = 0; i < size; i++)
              {
                TCell * _elem207 = NULL;
                if ( _elem207 != NULL)
                {
                  g_object_unref (_elem207);
                }
                _elem207 = g_object_new (TYPE_T_CELL, NULL);
                if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem207), protocol, error)) < 0)
                {
                  g_object_unref (_elem207);
                  return 0;
                }
                xfer += ret;
                g_ptr_array_add (*_return, _elem207);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *io != NULL)
            {
              g_object_unref (*io);
            }
            *io = g_object_new (TYPE_I_O_ERROR, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*io), protocol, error)) < 0)
            {
              g_object_unref (*io);
              *io = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*io != NULL)
  {
      g_set_error (error, I_O_ERROR_ERROR, I_O_ERROR_ERROR_CODE, "IOError");
      return FALSE;
  }
  return TRUE;
}

gboolean hbase_client_get_ver_ts (HbaseIf * iface, GPtrArray ** _return, const Text tableName, const Text row, const Text column, const gint64 timestamp, const gint32 numVersions, const GHashTable * attributes, IOError ** io, GError ** error)
{
  if (!hbase_client_send_get_ver_ts (iface, tableName, row, column, timestamp, numVersions, attributes, error))
    return FALSE;
  if (!hbase_client_recv_get_ver_ts (iface, _return, io, error))
    return FALSE;
  return TRUE;
}

gboolean hbase_client_send_get_row (HbaseIf * iface, const Text tableName, const Text row, const GHashTable * attributes, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = HBASE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getRow", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getRow_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "tableName", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, tableName ? ((GByteArray *) tableName)->data : NULL, tableName ? ((GByteArray *) tableName)->len : 0, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "row", T_STRING, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, row ? ((GByteArray *) row)->data : NULL, row ? ((GByteArray *) row)->len : 0, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "attributes", T_MAP, 3, error)) < 0)
      return 0;
    xfer += ret;
    {
      Text key208 = NULL;
      Text val209 = NULL;
      GList *key_list = NULL, *iter = NULL;
      Text* keys;
      int i = 0, key_count;

      if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRING, attributes ? (gint32) g_hash_table_size ((GHashTable *) attributes) : 0, error)) < 0)
        return 0;
      xfer += ret;
      if (attributes)
        g_hash_table_foreach ((GHashTable *) attributes, thrift_hash_table_get_keys, &key_list);
      key_count = g_list_length (key_list);
      keys = g_newa (Text, key_count);
      for (iter = g_list_first (key_list); iter; iter = iter->next)
        keys[i++] = (Text) iter->data;
      g_list_free (key_list);

      for (i = 0; i < key_count; ++i)
      {
        key208 = keys[i];
        val209 = (Text) g_hash_table_lookup (((GHashTable *) attributes), (gpointer) key208);

        if ((ret = thrift_protocol_write_binary (protocol,  key208 ? ((GByteArray *)  key208)->data : NULL,  key208 ? ((GByteArray *)  key208)->len : 0, error)) < 0)
          return 0;
        xfer += ret;

        if ((ret = thrift_protocol_write_binary (protocol,  val209 ? ((GByteArray *)  val209)->data : NULL,  val209 ? ((GByteArray *)  val209)->len : 0, error)) < 0)
          return 0;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean hbase_client_recv_get_row (HbaseIf * iface, GPtrArray ** _return, IOError ** io, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = HBASE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getRow", 6) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getRow", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_LIST)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType element_type;

              if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through list elements */
              for (i = 0; i < size; i++)
              {
                TRowResult * _elem210 = NULL;
                if ( _elem210 != NULL)
                {
                  g_object_unref (_elem210);
                }
                _elem210 = g_object_new (TYPE_T_ROW_RESULT, NULL);
                if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem210), protocol, error)) < 0)
                {
                  g_object_unref (_elem210);
                  return 0;
                }
                xfer += ret;
                g_ptr_array_add (*_return, _elem210);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *io != NULL)
            {
              g_object_unref (*io);
            }
            *io = g_object_new (TYPE_I_O_ERROR, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*io), protocol, error)) < 0)
            {
              g_object_unref (*io);
              *io = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*io != NULL)
  {
      g_set_error (error, I_O_ERROR_ERROR, I_O_ERROR_ERROR_CODE, "IOError");
      return FALSE;
  }
  return TRUE;
}

gboolean hbase_client_get_row (HbaseIf * iface, GPtrArray ** _return, const Text tableName, const Text row, const GHashTable * attributes, IOError ** io, GError ** error)
{
  if (!hbase_client_send_get_row (iface, tableName, row, attributes, error))
    return FALSE;
  if (!hbase_client_recv_get_row (iface, _return, io, error))
    return FALSE;
  return TRUE;
}

gboolean hbase_client_send_get_row_with_columns (HbaseIf * iface, const Text tableName, const Text row, const GPtrArray * columns, const GHashTable * attributes, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = HBASE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getRowWithColumns", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getRowWithColumns_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "tableName", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, tableName ? ((GByteArray *) tableName)->data : NULL, tableName ? ((GByteArray *) tableName)->len : 0, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "row", T_STRING, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, row ? ((GByteArray *) row)->data : NULL, row ? ((GByteArray *) row)->len : 0, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "columns", T_LIST, 3, error)) < 0)
      return 0;
    xfer += ret;
    {
      guint i211;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (columns ? columns->len : 0), error)) < 0)
        return 0;
      xfer += ret;
      for (i211 = 0; i211 < (columns ? columns->len : 0); i211++)
      {
        if ((ret = thrift_protocol_write_binary (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) columns, i211)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) columns, i211)))->data : NULL, ((gchar*)g_ptr_array_index ((GPtrArray *) columns, i211)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) columns, i211)))->len : 0, error)) < 0)
          return 0;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "attributes", T_MAP, 4, error)) < 0)
      return 0;
    xfer += ret;
    {
      Text key212 = NULL;
      Text val213 = NULL;
      GList *key_list = NULL, *iter = NULL;
      Text* keys;
      int i = 0, key_count;

      if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRING, attributes ? (gint32) g_hash_table_size ((GHashTable *) attributes) : 0, error)) < 0)
        return 0;
      xfer += ret;
      if (attributes)
        g_hash_table_foreach ((GHashTable *) attributes, thrift_hash_table_get_keys, &key_list);
      key_count = g_list_length (key_list);
      keys = g_newa (Text, key_count);
      for (iter = g_list_first (key_list); iter; iter = iter->next)
        keys[i++] = (Text) iter->data;
      g_list_free (key_list);

      for (i = 0; i < key_count; ++i)
      {
        key212 = keys[i];
        val213 = (Text) g_hash_table_lookup (((GHashTable *) attributes), (gpointer) key212);

        if ((ret = thrift_protocol_write_binary (protocol,  key212 ? ((GByteArray *)  key212)->data : NULL,  key212 ? ((GByteArray *)  key212)->len : 0, error)) < 0)
          return 0;
        xfer += ret;

        if ((ret = thrift_protocol_write_binary (protocol,  val213 ? ((GByteArray *)  val213)->data : NULL,  val213 ? ((GByteArray *)  val213)->len : 0, error)) < 0)
          return 0;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean hbase_client_recv_get_row_with_columns (HbaseIf * iface, GPtrArray ** _return, IOError ** io, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = HBASE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getRowWithColumns", 17) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getRowWithColumns", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_LIST)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType element_type;

              if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through list elements */
              for (i = 0; i < size; i++)
              {
                TRowResult * _elem214 = NULL;
                if ( _elem214 != NULL)
                {
                  g_object_unref (_elem214);
                }
                _elem214 = g_object_new (TYPE_T_ROW_RESULT, NULL);
                if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem214), protocol, error)) < 0)
                {
                  g_object_unref (_elem214);
                  return 0;
                }
                xfer += ret;
                g_ptr_array_add (*_return, _elem214);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *io != NULL)
            {
              g_object_unref (*io);
            }
            *io = g_object_new (TYPE_I_O_ERROR, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*io), protocol, error)) < 0)
            {
              g_object_unref (*io);
              *io = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*io != NULL)
  {
      g_set_error (error, I_O_ERROR_ERROR, I_O_ERROR_ERROR_CODE, "IOError");
      return FALSE;
  }
  return TRUE;
}

gboolean hbase_client_get_row_with_columns (HbaseIf * iface, GPtrArray ** _return, const Text tableName, const Text row, const GPtrArray * columns, const GHashTable * attributes, IOError ** io, GError ** error)
{
  if (!hbase_client_send_get_row_with_columns (iface, tableName, row, columns, attributes, error))
    return FALSE;
  if (!hbase_client_recv_get_row_with_columns (iface, _return, io, error))
    return FALSE;
  return TRUE;
}

gboolean hbase_client_send_get_row_ts (HbaseIf * iface, const Text tableName, const Text row, const gint64 timestamp, const GHashTable * attributes, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = HBASE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getRowTs", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getRowTs_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "tableName", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, tableName ? ((GByteArray *) tableName)->data : NULL, tableName ? ((GByteArray *) tableName)->len : 0, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "row", T_STRING, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, row ? ((GByteArray *) row)->data : NULL, row ? ((GByteArray *) row)->len : 0, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "timestamp", T_I64, 3, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, timestamp, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "attributes", T_MAP, 4, error)) < 0)
      return 0;
    xfer += ret;
    {
      Text key215 = NULL;
      Text val216 = NULL;
      GList *key_list = NULL, *iter = NULL;
      Text* keys;
      int i = 0, key_count;

      if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRING, attributes ? (gint32) g_hash_table_size ((GHashTable *) attributes) : 0, error)) < 0)
        return 0;
      xfer += ret;
      if (attributes)
        g_hash_table_foreach ((GHashTable *) attributes, thrift_hash_table_get_keys, &key_list);
      key_count = g_list_length (key_list);
      keys = g_newa (Text, key_count);
      for (iter = g_list_first (key_list); iter; iter = iter->next)
        keys[i++] = (Text) iter->data;
      g_list_free (key_list);

      for (i = 0; i < key_count; ++i)
      {
        key215 = keys[i];
        val216 = (Text) g_hash_table_lookup (((GHashTable *) attributes), (gpointer) key215);

        if ((ret = thrift_protocol_write_binary (protocol,  key215 ? ((GByteArray *)  key215)->data : NULL,  key215 ? ((GByteArray *)  key215)->len : 0, error)) < 0)
          return 0;
        xfer += ret;

        if ((ret = thrift_protocol_write_binary (protocol,  val216 ? ((GByteArray *)  val216)->data : NULL,  val216 ? ((GByteArray *)  val216)->len : 0, error)) < 0)
          return 0;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean hbase_client_recv_get_row_ts (HbaseIf * iface, GPtrArray ** _return, IOError ** io, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = HBASE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getRowTs", 8) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getRowTs", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_LIST)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType element_type;

              if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through list elements */
              for (i = 0; i < size; i++)
              {
                TRowResult * _elem217 = NULL;
                if ( _elem217 != NULL)
                {
                  g_object_unref (_elem217);
                }
                _elem217 = g_object_new (TYPE_T_ROW_RESULT, NULL);
                if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem217), protocol, error)) < 0)
                {
                  g_object_unref (_elem217);
                  return 0;
                }
                xfer += ret;
                g_ptr_array_add (*_return, _elem217);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *io != NULL)
            {
              g_object_unref (*io);
            }
            *io = g_object_new (TYPE_I_O_ERROR, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*io), protocol, error)) < 0)
            {
              g_object_unref (*io);
              *io = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*io != NULL)
  {
      g_set_error (error, I_O_ERROR_ERROR, I_O_ERROR_ERROR_CODE, "IOError");
      return FALSE;
  }
  return TRUE;
}

gboolean hbase_client_get_row_ts (HbaseIf * iface, GPtrArray ** _return, const Text tableName, const Text row, const gint64 timestamp, const GHashTable * attributes, IOError ** io, GError ** error)
{
  if (!hbase_client_send_get_row_ts (iface, tableName, row, timestamp, attributes, error))
    return FALSE;
  if (!hbase_client_recv_get_row_ts (iface, _return, io, error))
    return FALSE;
  return TRUE;
}

gboolean hbase_client_send_get_row_with_columns_ts (HbaseIf * iface, const Text tableName, const Text row, const GPtrArray * columns, const gint64 timestamp, const GHashTable * attributes, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = HBASE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getRowWithColumnsTs", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getRowWithColumnsTs_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "tableName", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, tableName ? ((GByteArray *) tableName)->data : NULL, tableName ? ((GByteArray *) tableName)->len : 0, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "row", T_STRING, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, row ? ((GByteArray *) row)->data : NULL, row ? ((GByteArray *) row)->len : 0, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "columns", T_LIST, 3, error)) < 0)
      return 0;
    xfer += ret;
    {
      guint i218;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (columns ? columns->len : 0), error)) < 0)
        return 0;
      xfer += ret;
      for (i218 = 0; i218 < (columns ? columns->len : 0); i218++)
      {
        if ((ret = thrift_protocol_write_binary (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) columns, i218)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) columns, i218)))->data : NULL, ((gchar*)g_ptr_array_index ((GPtrArray *) columns, i218)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) columns, i218)))->len : 0, error)) < 0)
          return 0;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "timestamp", T_I64, 4, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, timestamp, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "attributes", T_MAP, 5, error)) < 0)
      return 0;
    xfer += ret;
    {
      Text key219 = NULL;
      Text val220 = NULL;
      GList *key_list = NULL, *iter = NULL;
      Text* keys;
      int i = 0, key_count;

      if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRING, attributes ? (gint32) g_hash_table_size ((GHashTable *) attributes) : 0, error)) < 0)
        return 0;
      xfer += ret;
      if (attributes)
        g_hash_table_foreach ((GHashTable *) attributes, thrift_hash_table_get_keys, &key_list);
      key_count = g_list_length (key_list);
      keys = g_newa (Text, key_count);
      for (iter = g_list_first (key_list); iter; iter = iter->next)
        keys[i++] = (Text) iter->data;
      g_list_free (key_list);

      for (i = 0; i < key_count; ++i)
      {
        key219 = keys[i];
        val220 = (Text) g_hash_table_lookup (((GHashTable *) attributes), (gpointer) key219);

        if ((ret = thrift_protocol_write_binary (protocol,  key219 ? ((GByteArray *)  key219)->data : NULL,  key219 ? ((GByteArray *)  key219)->len : 0, error)) < 0)
          return 0;
        xfer += ret;

        if ((ret = thrift_protocol_write_binary (protocol,  val220 ? ((GByteArray *)  val220)->data : NULL,  val220 ? ((GByteArray *)  val220)->len : 0, error)) < 0)
          return 0;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean hbase_client_recv_get_row_with_columns_ts (HbaseIf * iface, GPtrArray ** _return, IOError ** io, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = HBASE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getRowWithColumnsTs", 19) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getRowWithColumnsTs", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_LIST)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType element_type;

              if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through list elements */
              for (i = 0; i < size; i++)
              {
                TRowResult * _elem221 = NULL;
                if ( _elem221 != NULL)
                {
                  g_object_unref (_elem221);
                }
                _elem221 = g_object_new (TYPE_T_ROW_RESULT, NULL);
                if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem221), protocol, error)) < 0)
                {
                  g_object_unref (_elem221);
                  return 0;
                }
                xfer += ret;
                g_ptr_array_add (*_return, _elem221);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *io != NULL)
            {
              g_object_unref (*io);
            }
            *io = g_object_new (TYPE_I_O_ERROR, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*io), protocol, error)) < 0)
            {
              g_object_unref (*io);
              *io = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*io != NULL)
  {
      g_set_error (error, I_O_ERROR_ERROR, I_O_ERROR_ERROR_CODE, "IOError");
      return FALSE;
  }
  return TRUE;
}

gboolean hbase_client_get_row_with_columns_ts (HbaseIf * iface, GPtrArray ** _return, const Text tableName, const Text row, const GPtrArray * columns, const gint64 timestamp, const GHashTable * attributes, IOError ** io, GError ** error)
{
  if (!hbase_client_send_get_row_with_columns_ts (iface, tableName, row, columns, timestamp, attributes, error))
    return FALSE;
  if (!hbase_client_recv_get_row_with_columns_ts (iface, _return, io, error))
    return FALSE;
  return TRUE;
}

gboolean hbase_client_send_get_rows (HbaseIf * iface, const Text tableName, const GPtrArray * rows, const GHashTable * attributes, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = HBASE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getRows", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getRows_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "tableName", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, tableName ? ((GByteArray *) tableName)->data : NULL, tableName ? ((GByteArray *) tableName)->len : 0, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "rows", T_LIST, 2, error)) < 0)
      return 0;
    xfer += ret;
    {
      guint i222;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (rows ? rows->len : 0), error)) < 0)
        return 0;
      xfer += ret;
      for (i222 = 0; i222 < (rows ? rows->len : 0); i222++)
      {
        if ((ret = thrift_protocol_write_binary (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) rows, i222)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) rows, i222)))->data : NULL, ((gchar*)g_ptr_array_index ((GPtrArray *) rows, i222)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) rows, i222)))->len : 0, error)) < 0)
          return 0;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "attributes", T_MAP, 3, error)) < 0)
      return 0;
    xfer += ret;
    {
      Text key223 = NULL;
      Text val224 = NULL;
      GList *key_list = NULL, *iter = NULL;
      Text* keys;
      int i = 0, key_count;

      if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRING, attributes ? (gint32) g_hash_table_size ((GHashTable *) attributes) : 0, error)) < 0)
        return 0;
      xfer += ret;
      if (attributes)
        g_hash_table_foreach ((GHashTable *) attributes, thrift_hash_table_get_keys, &key_list);
      key_count = g_list_length (key_list);
      keys = g_newa (Text, key_count);
      for (iter = g_list_first (key_list); iter; iter = iter->next)
        keys[i++] = (Text) iter->data;
      g_list_free (key_list);

      for (i = 0; i < key_count; ++i)
      {
        key223 = keys[i];
        val224 = (Text) g_hash_table_lookup (((GHashTable *) attributes), (gpointer) key223);

        if ((ret = thrift_protocol_write_binary (protocol,  key223 ? ((GByteArray *)  key223)->data : NULL,  key223 ? ((GByteArray *)  key223)->len : 0, error)) < 0)
          return 0;
        xfer += ret;

        if ((ret = thrift_protocol_write_binary (protocol,  val224 ? ((GByteArray *)  val224)->data : NULL,  val224 ? ((GByteArray *)  val224)->len : 0, error)) < 0)
          return 0;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean hbase_client_recv_get_rows (HbaseIf * iface, GPtrArray ** _return, IOError ** io, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = HBASE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getRows", 7) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getRows", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_LIST)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType element_type;

              if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through list elements */
              for (i = 0; i < size; i++)
              {
                TRowResult * _elem225 = NULL;
                if ( _elem225 != NULL)
                {
                  g_object_unref (_elem225);
                }
                _elem225 = g_object_new (TYPE_T_ROW_RESULT, NULL);
                if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem225), protocol, error)) < 0)
                {
                  g_object_unref (_elem225);
                  return 0;
                }
                xfer += ret;
                g_ptr_array_add (*_return, _elem225);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *io != NULL)
            {
              g_object_unref (*io);
            }
            *io = g_object_new (TYPE_I_O_ERROR, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*io), protocol, error)) < 0)
            {
              g_object_unref (*io);
              *io = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*io != NULL)
  {
      g_set_error (error, I_O_ERROR_ERROR, I_O_ERROR_ERROR_CODE, "IOError");
      return FALSE;
  }
  return TRUE;
}

gboolean hbase_client_get_rows (HbaseIf * iface, GPtrArray ** _return, const Text tableName, const GPtrArray * rows, const GHashTable * attributes, IOError ** io, GError ** error)
{
  if (!hbase_client_send_get_rows (iface, tableName, rows, attributes, error))
    return FALSE;
  if (!hbase_client_recv_get_rows (iface, _return, io, error))
    return FALSE;
  return TRUE;
}

gboolean hbase_client_send_get_rows_with_columns (HbaseIf * iface, const Text tableName, const GPtrArray * rows, const GPtrArray * columns, const GHashTable * attributes, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = HBASE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getRowsWithColumns", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getRowsWithColumns_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "tableName", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, tableName ? ((GByteArray *) tableName)->data : NULL, tableName ? ((GByteArray *) tableName)->len : 0, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "rows", T_LIST, 2, error)) < 0)
      return 0;
    xfer += ret;
    {
      guint i226;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (rows ? rows->len : 0), error)) < 0)
        return 0;
      xfer += ret;
      for (i226 = 0; i226 < (rows ? rows->len : 0); i226++)
      {
        if ((ret = thrift_protocol_write_binary (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) rows, i226)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) rows, i226)))->data : NULL, ((gchar*)g_ptr_array_index ((GPtrArray *) rows, i226)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) rows, i226)))->len : 0, error)) < 0)
          return 0;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "columns", T_LIST, 3, error)) < 0)
      return 0;
    xfer += ret;
    {
      guint i227;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (columns ? columns->len : 0), error)) < 0)
        return 0;
      xfer += ret;
      for (i227 = 0; i227 < (columns ? columns->len : 0); i227++)
      {
        if ((ret = thrift_protocol_write_binary (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) columns, i227)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) columns, i227)))->data : NULL, ((gchar*)g_ptr_array_index ((GPtrArray *) columns, i227)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) columns, i227)))->len : 0, error)) < 0)
          return 0;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "attributes", T_MAP, 4, error)) < 0)
      return 0;
    xfer += ret;
    {
      Text key228 = NULL;
      Text val229 = NULL;
      GList *key_list = NULL, *iter = NULL;
      Text* keys;
      int i = 0, key_count;

      if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRING, attributes ? (gint32) g_hash_table_size ((GHashTable *) attributes) : 0, error)) < 0)
        return 0;
      xfer += ret;
      if (attributes)
        g_hash_table_foreach ((GHashTable *) attributes, thrift_hash_table_get_keys, &key_list);
      key_count = g_list_length (key_list);
      keys = g_newa (Text, key_count);
      for (iter = g_list_first (key_list); iter; iter = iter->next)
        keys[i++] = (Text) iter->data;
      g_list_free (key_list);

      for (i = 0; i < key_count; ++i)
      {
        key228 = keys[i];
        val229 = (Text) g_hash_table_lookup (((GHashTable *) attributes), (gpointer) key228);

        if ((ret = thrift_protocol_write_binary (protocol,  key228 ? ((GByteArray *)  key228)->data : NULL,  key228 ? ((GByteArray *)  key228)->len : 0, error)) < 0)
          return 0;
        xfer += ret;

        if ((ret = thrift_protocol_write_binary (protocol,  val229 ? ((GByteArray *)  val229)->data : NULL,  val229 ? ((GByteArray *)  val229)->len : 0, error)) < 0)
          return 0;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean hbase_client_recv_get_rows_with_columns (HbaseIf * iface, GPtrArray ** _return, IOError ** io, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = HBASE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getRowsWithColumns", 18) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getRowsWithColumns", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_LIST)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType element_type;

              if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through list elements */
              for (i = 0; i < size; i++)
              {
                TRowResult * _elem230 = NULL;
                if ( _elem230 != NULL)
                {
                  g_object_unref (_elem230);
                }
                _elem230 = g_object_new (TYPE_T_ROW_RESULT, NULL);
                if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem230), protocol, error)) < 0)
                {
                  g_object_unref (_elem230);
                  return 0;
                }
                xfer += ret;
                g_ptr_array_add (*_return, _elem230);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *io != NULL)
            {
              g_object_unref (*io);
            }
            *io = g_object_new (TYPE_I_O_ERROR, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*io), protocol, error)) < 0)
            {
              g_object_unref (*io);
              *io = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*io != NULL)
  {
      g_set_error (error, I_O_ERROR_ERROR, I_O_ERROR_ERROR_CODE, "IOError");
      return FALSE;
  }
  return TRUE;
}

gboolean hbase_client_get_rows_with_columns (HbaseIf * iface, GPtrArray ** _return, const Text tableName, const GPtrArray * rows, const GPtrArray * columns, const GHashTable * attributes, IOError ** io, GError ** error)
{
  if (!hbase_client_send_get_rows_with_columns (iface, tableName, rows, columns, attributes, error))
    return FALSE;
  if (!hbase_client_recv_get_rows_with_columns (iface, _return, io, error))
    return FALSE;
  return TRUE;
}

gboolean hbase_client_send_get_rows_ts (HbaseIf * iface, const Text tableName, const GPtrArray * rows, const gint64 timestamp, const GHashTable * attributes, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = HBASE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getRowsTs", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getRowsTs_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "tableName", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, tableName ? ((GByteArray *) tableName)->data : NULL, tableName ? ((GByteArray *) tableName)->len : 0, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "rows", T_LIST, 2, error)) < 0)
      return 0;
    xfer += ret;
    {
      guint i231;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (rows ? rows->len : 0), error)) < 0)
        return 0;
      xfer += ret;
      for (i231 = 0; i231 < (rows ? rows->len : 0); i231++)
      {
        if ((ret = thrift_protocol_write_binary (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) rows, i231)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) rows, i231)))->data : NULL, ((gchar*)g_ptr_array_index ((GPtrArray *) rows, i231)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) rows, i231)))->len : 0, error)) < 0)
          return 0;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "timestamp", T_I64, 3, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, timestamp, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "attributes", T_MAP, 4, error)) < 0)
      return 0;
    xfer += ret;
    {
      Text key232 = NULL;
      Text val233 = NULL;
      GList *key_list = NULL, *iter = NULL;
      Text* keys;
      int i = 0, key_count;

      if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRING, attributes ? (gint32) g_hash_table_size ((GHashTable *) attributes) : 0, error)) < 0)
        return 0;
      xfer += ret;
      if (attributes)
        g_hash_table_foreach ((GHashTable *) attributes, thrift_hash_table_get_keys, &key_list);
      key_count = g_list_length (key_list);
      keys = g_newa (Text, key_count);
      for (iter = g_list_first (key_list); iter; iter = iter->next)
        keys[i++] = (Text) iter->data;
      g_list_free (key_list);

      for (i = 0; i < key_count; ++i)
      {
        key232 = keys[i];
        val233 = (Text) g_hash_table_lookup (((GHashTable *) attributes), (gpointer) key232);

        if ((ret = thrift_protocol_write_binary (protocol,  key232 ? ((GByteArray *)  key232)->data : NULL,  key232 ? ((GByteArray *)  key232)->len : 0, error)) < 0)
          return 0;
        xfer += ret;

        if ((ret = thrift_protocol_write_binary (protocol,  val233 ? ((GByteArray *)  val233)->data : NULL,  val233 ? ((GByteArray *)  val233)->len : 0, error)) < 0)
          return 0;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean hbase_client_recv_get_rows_ts (HbaseIf * iface, GPtrArray ** _return, IOError ** io, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = HBASE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getRowsTs", 9) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getRowsTs", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_LIST)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType element_type;

              if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through list elements */
              for (i = 0; i < size; i++)
              {
                TRowResult * _elem234 = NULL;
                if ( _elem234 != NULL)
                {
                  g_object_unref (_elem234);
                }
                _elem234 = g_object_new (TYPE_T_ROW_RESULT, NULL);
                if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem234), protocol, error)) < 0)
                {
                  g_object_unref (_elem234);
                  return 0;
                }
                xfer += ret;
                g_ptr_array_add (*_return, _elem234);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *io != NULL)
            {
              g_object_unref (*io);
            }
            *io = g_object_new (TYPE_I_O_ERROR, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*io), protocol, error)) < 0)
            {
              g_object_unref (*io);
              *io = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*io != NULL)
  {
      g_set_error (error, I_O_ERROR_ERROR, I_O_ERROR_ERROR_CODE, "IOError");
      return FALSE;
  }
  return TRUE;
}

gboolean hbase_client_get_rows_ts (HbaseIf * iface, GPtrArray ** _return, const Text tableName, const GPtrArray * rows, const gint64 timestamp, const GHashTable * attributes, IOError ** io, GError ** error)
{
  if (!hbase_client_send_get_rows_ts (iface, tableName, rows, timestamp, attributes, error))
    return FALSE;
  if (!hbase_client_recv_get_rows_ts (iface, _return, io, error))
    return FALSE;
  return TRUE;
}

gboolean hbase_client_send_get_rows_with_columns_ts (HbaseIf * iface, const Text tableName, const GPtrArray * rows, const GPtrArray * columns, const gint64 timestamp, const GHashTable * attributes, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = HBASE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getRowsWithColumnsTs", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getRowsWithColumnsTs_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "tableName", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, tableName ? ((GByteArray *) tableName)->data : NULL, tableName ? ((GByteArray *) tableName)->len : 0, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "rows", T_LIST, 2, error)) < 0)
      return 0;
    xfer += ret;
    {
      guint i235;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (rows ? rows->len : 0), error)) < 0)
        return 0;
      xfer += ret;
      for (i235 = 0; i235 < (rows ? rows->len : 0); i235++)
      {
        if ((ret = thrift_protocol_write_binary (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) rows, i235)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) rows, i235)))->data : NULL, ((gchar*)g_ptr_array_index ((GPtrArray *) rows, i235)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) rows, i235)))->len : 0, error)) < 0)
          return 0;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "columns", T_LIST, 3, error)) < 0)
      return 0;
    xfer += ret;
    {
      guint i236;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (columns ? columns->len : 0), error)) < 0)
        return 0;
      xfer += ret;
      for (i236 = 0; i236 < (columns ? columns->len : 0); i236++)
      {
        if ((ret = thrift_protocol_write_binary (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) columns, i236)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) columns, i236)))->data : NULL, ((gchar*)g_ptr_array_index ((GPtrArray *) columns, i236)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) columns, i236)))->len : 0, error)) < 0)
          return 0;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "timestamp", T_I64, 4, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, timestamp, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "attributes", T_MAP, 5, error)) < 0)
      return 0;
    xfer += ret;
    {
      Text key237 = NULL;
      Text val238 = NULL;
      GList *key_list = NULL, *iter = NULL;
      Text* keys;
      int i = 0, key_count;

      if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRING, attributes ? (gint32) g_hash_table_size ((GHashTable *) attributes) : 0, error)) < 0)
        return 0;
      xfer += ret;
      if (attributes)
        g_hash_table_foreach ((GHashTable *) attributes, thrift_hash_table_get_keys, &key_list);
      key_count = g_list_length (key_list);
      keys = g_newa (Text, key_count);
      for (iter = g_list_first (key_list); iter; iter = iter->next)
        keys[i++] = (Text) iter->data;
      g_list_free (key_list);

      for (i = 0; i < key_count; ++i)
      {
        key237 = keys[i];
        val238 = (Text) g_hash_table_lookup (((GHashTable *) attributes), (gpointer) key237);

        if ((ret = thrift_protocol_write_binary (protocol,  key237 ? ((GByteArray *)  key237)->data : NULL,  key237 ? ((GByteArray *)  key237)->len : 0, error)) < 0)
          return 0;
        xfer += ret;

        if ((ret = thrift_protocol_write_binary (protocol,  val238 ? ((GByteArray *)  val238)->data : NULL,  val238 ? ((GByteArray *)  val238)->len : 0, error)) < 0)
          return 0;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean hbase_client_recv_get_rows_with_columns_ts (HbaseIf * iface, GPtrArray ** _return, IOError ** io, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = HBASE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getRowsWithColumnsTs", 20) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getRowsWithColumnsTs", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_LIST)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType element_type;

              if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through list elements */
              for (i = 0; i < size; i++)
              {
                TRowResult * _elem239 = NULL;
                if ( _elem239 != NULL)
                {
                  g_object_unref (_elem239);
                }
                _elem239 = g_object_new (TYPE_T_ROW_RESULT, NULL);
                if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem239), protocol, error)) < 0)
                {
                  g_object_unref (_elem239);
                  return 0;
                }
                xfer += ret;
                g_ptr_array_add (*_return, _elem239);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *io != NULL)
            {
              g_object_unref (*io);
            }
            *io = g_object_new (TYPE_I_O_ERROR, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*io), protocol, error)) < 0)
            {
              g_object_unref (*io);
              *io = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*io != NULL)
  {
      g_set_error (error, I_O_ERROR_ERROR, I_O_ERROR_ERROR_CODE, "IOError");
      return FALSE;
  }
  return TRUE;
}

gboolean hbase_client_get_rows_with_columns_ts (HbaseIf * iface, GPtrArray ** _return, const Text tableName, const GPtrArray * rows, const GPtrArray * columns, const gint64 timestamp, const GHashTable * attributes, IOError ** io, GError ** error)
{
  if (!hbase_client_send_get_rows_with_columns_ts (iface, tableName, rows, columns, timestamp, attributes, error))
    return FALSE;
  if (!hbase_client_recv_get_rows_with_columns_ts (iface, _return, io, error))
    return FALSE;
  return TRUE;
}

gboolean hbase_client_send_mutate_row (HbaseIf * iface, const Text tableName, const Text row, const GPtrArray * mutations, const GHashTable * attributes, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = HBASE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "mutateRow", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "mutateRow_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "tableName", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, tableName ? ((GByteArray *) tableName)->data : NULL, tableName ? ((GByteArray *) tableName)->len : 0, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "row", T_STRING, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, row ? ((GByteArray *) row)->data : NULL, row ? ((GByteArray *) row)->len : 0, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "mutations", T_LIST, 3, error)) < 0)
      return 0;
    xfer += ret;
    {
      guint i240;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (mutations ? mutations->len : 0), error)) < 0)
        return 0;
      xfer += ret;
      for (i240 = 0; i240 < (mutations ? mutations->len : 0); i240++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) mutations, i240))), protocol, error)) < 0)
          return 0;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "attributes", T_MAP, 4, error)) < 0)
      return 0;
    xfer += ret;
    {
      Text key241 = NULL;
      Text val242 = NULL;
      GList *key_list = NULL, *iter = NULL;
      Text* keys;
      int i = 0, key_count;

      if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRING, attributes ? (gint32) g_hash_table_size ((GHashTable *) attributes) : 0, error)) < 0)
        return 0;
      xfer += ret;
      if (attributes)
        g_hash_table_foreach ((GHashTable *) attributes, thrift_hash_table_get_keys, &key_list);
      key_count = g_list_length (key_list);
      keys = g_newa (Text, key_count);
      for (iter = g_list_first (key_list); iter; iter = iter->next)
        keys[i++] = (Text) iter->data;
      g_list_free (key_list);

      for (i = 0; i < key_count; ++i)
      {
        key241 = keys[i];
        val242 = (Text) g_hash_table_lookup (((GHashTable *) attributes), (gpointer) key241);

        if ((ret = thrift_protocol_write_binary (protocol,  key241 ? ((GByteArray *)  key241)->data : NULL,  key241 ? ((GByteArray *)  key241)->len : 0, error)) < 0)
          return 0;
        xfer += ret;

        if ((ret = thrift_protocol_write_binary (protocol,  val242 ? ((GByteArray *)  val242)->data : NULL,  val242 ? ((GByteArray *)  val242)->len : 0, error)) < 0)
          return 0;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean hbase_client_recv_mutate_row (HbaseIf * iface, IOError ** io, IllegalArgument ** ia, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = HBASE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "mutateRow", 9) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected mutateRow", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *io != NULL)
            {
              g_object_unref (*io);
            }
            *io = g_object_new (TYPE_I_O_ERROR, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*io), protocol, error)) < 0)
            {
              g_object_unref (*io);
              *io = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 2:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ia != NULL)
            {
              g_object_unref (*ia);
            }
            *ia = g_object_new (TYPE_ILLEGAL_ARGUMENT, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ia), protocol, error)) < 0)
            {
              g_object_unref (*ia);
              *ia = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*io != NULL)
  {
      g_set_error (error, I_O_ERROR_ERROR, I_O_ERROR_ERROR_CODE, "IOError");
      return FALSE;
  }
  if (*ia != NULL)
  {
      g_set_error (error, ILLEGAL_ARGUMENT_ERROR, ILLEGAL_ARGUMENT_ERROR_CODE, "IllegalArgument");
      return FALSE;
  }
  return TRUE;
}

gboolean hbase_client_mutate_row (HbaseIf * iface, const Text tableName, const Text row, const GPtrArray * mutations, const GHashTable * attributes, IOError ** io, IllegalArgument ** ia, GError ** error)
{
  if (!hbase_client_send_mutate_row (iface, tableName, row, mutations, attributes, error))
    return FALSE;
  if (!hbase_client_recv_mutate_row (iface, io, ia, error))
    return FALSE;
  return TRUE;
}

gboolean hbase_client_send_mutate_row_ts (HbaseIf * iface, const Text tableName, const Text row, const GPtrArray * mutations, const gint64 timestamp, const GHashTable * attributes, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = HBASE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "mutateRowTs", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "mutateRowTs_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "tableName", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, tableName ? ((GByteArray *) tableName)->data : NULL, tableName ? ((GByteArray *) tableName)->len : 0, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "row", T_STRING, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, row ? ((GByteArray *) row)->data : NULL, row ? ((GByteArray *) row)->len : 0, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "mutations", T_LIST, 3, error)) < 0)
      return 0;
    xfer += ret;
    {
      guint i243;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (mutations ? mutations->len : 0), error)) < 0)
        return 0;
      xfer += ret;
      for (i243 = 0; i243 < (mutations ? mutations->len : 0); i243++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) mutations, i243))), protocol, error)) < 0)
          return 0;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "timestamp", T_I64, 4, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, timestamp, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "attributes", T_MAP, 5, error)) < 0)
      return 0;
    xfer += ret;
    {
      Text key244 = NULL;
      Text val245 = NULL;
      GList *key_list = NULL, *iter = NULL;
      Text* keys;
      int i = 0, key_count;

      if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRING, attributes ? (gint32) g_hash_table_size ((GHashTable *) attributes) : 0, error)) < 0)
        return 0;
      xfer += ret;
      if (attributes)
        g_hash_table_foreach ((GHashTable *) attributes, thrift_hash_table_get_keys, &key_list);
      key_count = g_list_length (key_list);
      keys = g_newa (Text, key_count);
      for (iter = g_list_first (key_list); iter; iter = iter->next)
        keys[i++] = (Text) iter->data;
      g_list_free (key_list);

      for (i = 0; i < key_count; ++i)
      {
        key244 = keys[i];
        val245 = (Text) g_hash_table_lookup (((GHashTable *) attributes), (gpointer) key244);

        if ((ret = thrift_protocol_write_binary (protocol,  key244 ? ((GByteArray *)  key244)->data : NULL,  key244 ? ((GByteArray *)  key244)->len : 0, error)) < 0)
          return 0;
        xfer += ret;

        if ((ret = thrift_protocol_write_binary (protocol,  val245 ? ((GByteArray *)  val245)->data : NULL,  val245 ? ((GByteArray *)  val245)->len : 0, error)) < 0)
          return 0;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean hbase_client_recv_mutate_row_ts (HbaseIf * iface, IOError ** io, IllegalArgument ** ia, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = HBASE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "mutateRowTs", 11) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected mutateRowTs", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *io != NULL)
            {
              g_object_unref (*io);
            }
            *io = g_object_new (TYPE_I_O_ERROR, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*io), protocol, error)) < 0)
            {
              g_object_unref (*io);
              *io = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 2:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ia != NULL)
            {
              g_object_unref (*ia);
            }
            *ia = g_object_new (TYPE_ILLEGAL_ARGUMENT, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ia), protocol, error)) < 0)
            {
              g_object_unref (*ia);
              *ia = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*io != NULL)
  {
      g_set_error (error, I_O_ERROR_ERROR, I_O_ERROR_ERROR_CODE, "IOError");
      return FALSE;
  }
  if (*ia != NULL)
  {
      g_set_error (error, ILLEGAL_ARGUMENT_ERROR, ILLEGAL_ARGUMENT_ERROR_CODE, "IllegalArgument");
      return FALSE;
  }
  return TRUE;
}

gboolean hbase_client_mutate_row_ts (HbaseIf * iface, const Text tableName, const Text row, const GPtrArray * mutations, const gint64 timestamp, const GHashTable * attributes, IOError ** io, IllegalArgument ** ia, GError ** error)
{
  if (!hbase_client_send_mutate_row_ts (iface, tableName, row, mutations, timestamp, attributes, error))
    return FALSE;
  if (!hbase_client_recv_mutate_row_ts (iface, io, ia, error))
    return FALSE;
  return TRUE;
}

gboolean hbase_client_send_mutate_rows (HbaseIf * iface, const Text tableName, const GPtrArray * rowBatches, const GHashTable * attributes, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = HBASE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "mutateRows", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "mutateRows_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "tableName", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, tableName ? ((GByteArray *) tableName)->data : NULL, tableName ? ((GByteArray *) tableName)->len : 0, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "rowBatches", T_LIST, 2, error)) < 0)
      return 0;
    xfer += ret;
    {
      guint i246;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (rowBatches ? rowBatches->len : 0), error)) < 0)
        return 0;
      xfer += ret;
      for (i246 = 0; i246 < (rowBatches ? rowBatches->len : 0); i246++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) rowBatches, i246))), protocol, error)) < 0)
          return 0;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "attributes", T_MAP, 3, error)) < 0)
      return 0;
    xfer += ret;
    {
      Text key247 = NULL;
      Text val248 = NULL;
      GList *key_list = NULL, *iter = NULL;
      Text* keys;
      int i = 0, key_count;

      if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRING, attributes ? (gint32) g_hash_table_size ((GHashTable *) attributes) : 0, error)) < 0)
        return 0;
      xfer += ret;
      if (attributes)
        g_hash_table_foreach ((GHashTable *) attributes, thrift_hash_table_get_keys, &key_list);
      key_count = g_list_length (key_list);
      keys = g_newa (Text, key_count);
      for (iter = g_list_first (key_list); iter; iter = iter->next)
        keys[i++] = (Text) iter->data;
      g_list_free (key_list);

      for (i = 0; i < key_count; ++i)
      {
        key247 = keys[i];
        val248 = (Text) g_hash_table_lookup (((GHashTable *) attributes), (gpointer) key247);

        if ((ret = thrift_protocol_write_binary (protocol,  key247 ? ((GByteArray *)  key247)->data : NULL,  key247 ? ((GByteArray *)  key247)->len : 0, error)) < 0)
          return 0;
        xfer += ret;

        if ((ret = thrift_protocol_write_binary (protocol,  val248 ? ((GByteArray *)  val248)->data : NULL,  val248 ? ((GByteArray *)  val248)->len : 0, error)) < 0)
          return 0;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean hbase_client_recv_mutate_rows (HbaseIf * iface, IOError ** io, IllegalArgument ** ia, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = HBASE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "mutateRows", 10) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected mutateRows", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *io != NULL)
            {
              g_object_unref (*io);
            }
            *io = g_object_new (TYPE_I_O_ERROR, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*io), protocol, error)) < 0)
            {
              g_object_unref (*io);
              *io = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 2:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ia != NULL)
            {
              g_object_unref (*ia);
            }
            *ia = g_object_new (TYPE_ILLEGAL_ARGUMENT, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ia), protocol, error)) < 0)
            {
              g_object_unref (*ia);
              *ia = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*io != NULL)
  {
      g_set_error (error, I_O_ERROR_ERROR, I_O_ERROR_ERROR_CODE, "IOError");
      return FALSE;
  }
  if (*ia != NULL)
  {
      g_set_error (error, ILLEGAL_ARGUMENT_ERROR, ILLEGAL_ARGUMENT_ERROR_CODE, "IllegalArgument");
      return FALSE;
  }
  return TRUE;
}

gboolean hbase_client_mutate_rows (HbaseIf * iface, const Text tableName, const GPtrArray * rowBatches, const GHashTable * attributes, IOError ** io, IllegalArgument ** ia, GError ** error)
{
  if (!hbase_client_send_mutate_rows (iface, tableName, rowBatches, attributes, error))
    return FALSE;
  if (!hbase_client_recv_mutate_rows (iface, io, ia, error))
    return FALSE;
  return TRUE;
}

gboolean hbase_client_send_mutate_rows_ts (HbaseIf * iface, const Text tableName, const GPtrArray * rowBatches, const gint64 timestamp, const GHashTable * attributes, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = HBASE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "mutateRowsTs", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "mutateRowsTs_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "tableName", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, tableName ? ((GByteArray *) tableName)->data : NULL, tableName ? ((GByteArray *) tableName)->len : 0, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "rowBatches", T_LIST, 2, error)) < 0)
      return 0;
    xfer += ret;
    {
      guint i249;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (rowBatches ? rowBatches->len : 0), error)) < 0)
        return 0;
      xfer += ret;
      for (i249 = 0; i249 < (rowBatches ? rowBatches->len : 0); i249++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) rowBatches, i249))), protocol, error)) < 0)
          return 0;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "timestamp", T_I64, 3, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, timestamp, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "attributes", T_MAP, 4, error)) < 0)
      return 0;
    xfer += ret;
    {
      Text key250 = NULL;
      Text val251 = NULL;
      GList *key_list = NULL, *iter = NULL;
      Text* keys;
      int i = 0, key_count;

      if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRING, attributes ? (gint32) g_hash_table_size ((GHashTable *) attributes) : 0, error)) < 0)
        return 0;
      xfer += ret;
      if (attributes)
        g_hash_table_foreach ((GHashTable *) attributes, thrift_hash_table_get_keys, &key_list);
      key_count = g_list_length (key_list);
      keys = g_newa (Text, key_count);
      for (iter = g_list_first (key_list); iter; iter = iter->next)
        keys[i++] = (Text) iter->data;
      g_list_free (key_list);

      for (i = 0; i < key_count; ++i)
      {
        key250 = keys[i];
        val251 = (Text) g_hash_table_lookup (((GHashTable *) attributes), (gpointer) key250);

        if ((ret = thrift_protocol_write_binary (protocol,  key250 ? ((GByteArray *)  key250)->data : NULL,  key250 ? ((GByteArray *)  key250)->len : 0, error)) < 0)
          return 0;
        xfer += ret;

        if ((ret = thrift_protocol_write_binary (protocol,  val251 ? ((GByteArray *)  val251)->data : NULL,  val251 ? ((GByteArray *)  val251)->len : 0, error)) < 0)
          return 0;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean hbase_client_recv_mutate_rows_ts (HbaseIf * iface, IOError ** io, IllegalArgument ** ia, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = HBASE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "mutateRowsTs", 12) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected mutateRowsTs", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *io != NULL)
            {
              g_object_unref (*io);
            }
            *io = g_object_new (TYPE_I_O_ERROR, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*io), protocol, error)) < 0)
            {
              g_object_unref (*io);
              *io = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 2:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ia != NULL)
            {
              g_object_unref (*ia);
            }
            *ia = g_object_new (TYPE_ILLEGAL_ARGUMENT, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ia), protocol, error)) < 0)
            {
              g_object_unref (*ia);
              *ia = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*io != NULL)
  {
      g_set_error (error, I_O_ERROR_ERROR, I_O_ERROR_ERROR_CODE, "IOError");
      return FALSE;
  }
  if (*ia != NULL)
  {
      g_set_error (error, ILLEGAL_ARGUMENT_ERROR, ILLEGAL_ARGUMENT_ERROR_CODE, "IllegalArgument");
      return FALSE;
  }
  return TRUE;
}

gboolean hbase_client_mutate_rows_ts (HbaseIf * iface, const Text tableName, const GPtrArray * rowBatches, const gint64 timestamp, const GHashTable * attributes, IOError ** io, IllegalArgument ** ia, GError ** error)
{
  if (!hbase_client_send_mutate_rows_ts (iface, tableName, rowBatches, timestamp, attributes, error))
    return FALSE;
  if (!hbase_client_recv_mutate_rows_ts (iface, io, ia, error))
    return FALSE;
  return TRUE;
}

gboolean hbase_client_send_atomic_increment (HbaseIf * iface, const Text tableName, const Text row, const Text column, const gint64 value, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = HBASE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "atomicIncrement", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "atomicIncrement_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "tableName", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, tableName ? ((GByteArray *) tableName)->data : NULL, tableName ? ((GByteArray *) tableName)->len : 0, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "row", T_STRING, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, row ? ((GByteArray *) row)->data : NULL, row ? ((GByteArray *) row)->len : 0, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "column", T_STRING, 3, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, column ? ((GByteArray *) column)->data : NULL, column ? ((GByteArray *) column)->len : 0, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "value", T_I64, 4, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, value, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean hbase_client_recv_atomic_increment (HbaseIf * iface, gint64* _return, IOError ** io, IllegalArgument ** ia, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = HBASE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "atomicIncrement", 15) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected atomicIncrement", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_I64)
          {
            if ((ret = thrift_protocol_read_i64 (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *io != NULL)
            {
              g_object_unref (*io);
            }
            *io = g_object_new (TYPE_I_O_ERROR, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*io), protocol, error)) < 0)
            {
              g_object_unref (*io);
              *io = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 2:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ia != NULL)
            {
              g_object_unref (*ia);
            }
            *ia = g_object_new (TYPE_ILLEGAL_ARGUMENT, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ia), protocol, error)) < 0)
            {
              g_object_unref (*ia);
              *ia = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*io != NULL)
  {
      g_set_error (error, I_O_ERROR_ERROR, I_O_ERROR_ERROR_CODE, "IOError");
      return FALSE;
  }
  if (*ia != NULL)
  {
      g_set_error (error, ILLEGAL_ARGUMENT_ERROR, ILLEGAL_ARGUMENT_ERROR_CODE, "IllegalArgument");
      return FALSE;
  }
  return TRUE;
}

gboolean hbase_client_atomic_increment (HbaseIf * iface, gint64* _return, const Text tableName, const Text row, const Text column, const gint64 value, IOError ** io, IllegalArgument ** ia, GError ** error)
{
  if (!hbase_client_send_atomic_increment (iface, tableName, row, column, value, error))
    return FALSE;
  if (!hbase_client_recv_atomic_increment (iface, _return, io, ia, error))
    return FALSE;
  return TRUE;
}

gboolean hbase_client_send_delete_all (HbaseIf * iface, const Text tableName, const Text row, const Text column, const GHashTable * attributes, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = HBASE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "deleteAll", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "deleteAll_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "tableName", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, tableName ? ((GByteArray *) tableName)->data : NULL, tableName ? ((GByteArray *) tableName)->len : 0, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "row", T_STRING, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, row ? ((GByteArray *) row)->data : NULL, row ? ((GByteArray *) row)->len : 0, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "column", T_STRING, 3, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, column ? ((GByteArray *) column)->data : NULL, column ? ((GByteArray *) column)->len : 0, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "attributes", T_MAP, 4, error)) < 0)
      return 0;
    xfer += ret;
    {
      Text key252 = NULL;
      Text val253 = NULL;
      GList *key_list = NULL, *iter = NULL;
      Text* keys;
      int i = 0, key_count;

      if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRING, attributes ? (gint32) g_hash_table_size ((GHashTable *) attributes) : 0, error)) < 0)
        return 0;
      xfer += ret;
      if (attributes)
        g_hash_table_foreach ((GHashTable *) attributes, thrift_hash_table_get_keys, &key_list);
      key_count = g_list_length (key_list);
      keys = g_newa (Text, key_count);
      for (iter = g_list_first (key_list); iter; iter = iter->next)
        keys[i++] = (Text) iter->data;
      g_list_free (key_list);

      for (i = 0; i < key_count; ++i)
      {
        key252 = keys[i];
        val253 = (Text) g_hash_table_lookup (((GHashTable *) attributes), (gpointer) key252);

        if ((ret = thrift_protocol_write_binary (protocol,  key252 ? ((GByteArray *)  key252)->data : NULL,  key252 ? ((GByteArray *)  key252)->len : 0, error)) < 0)
          return 0;
        xfer += ret;

        if ((ret = thrift_protocol_write_binary (protocol,  val253 ? ((GByteArray *)  val253)->data : NULL,  val253 ? ((GByteArray *)  val253)->len : 0, error)) < 0)
          return 0;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean hbase_client_recv_delete_all (HbaseIf * iface, IOError ** io, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = HBASE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "deleteAll", 9) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected deleteAll", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *io != NULL)
            {
              g_object_unref (*io);
            }
            *io = g_object_new (TYPE_I_O_ERROR, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*io), protocol, error)) < 0)
            {
              g_object_unref (*io);
              *io = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*io != NULL)
  {
      g_set_error (error, I_O_ERROR_ERROR, I_O_ERROR_ERROR_CODE, "IOError");
      return FALSE;
  }
  return TRUE;
}

gboolean hbase_client_delete_all (HbaseIf * iface, const Text tableName, const Text row, const Text column, const GHashTable * attributes, IOError ** io, GError ** error)
{
  if (!hbase_client_send_delete_all (iface, tableName, row, column, attributes, error))
    return FALSE;
  if (!hbase_client_recv_delete_all (iface, io, error))
    return FALSE;
  return TRUE;
}

gboolean hbase_client_send_delete_all_ts (HbaseIf * iface, const Text tableName, const Text row, const Text column, const gint64 timestamp, const GHashTable * attributes, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = HBASE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "deleteAllTs", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "deleteAllTs_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "tableName", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, tableName ? ((GByteArray *) tableName)->data : NULL, tableName ? ((GByteArray *) tableName)->len : 0, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "row", T_STRING, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, row ? ((GByteArray *) row)->data : NULL, row ? ((GByteArray *) row)->len : 0, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "column", T_STRING, 3, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, column ? ((GByteArray *) column)->data : NULL, column ? ((GByteArray *) column)->len : 0, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "timestamp", T_I64, 4, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, timestamp, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "attributes", T_MAP, 5, error)) < 0)
      return 0;
    xfer += ret;
    {
      Text key254 = NULL;
      Text val255 = NULL;
      GList *key_list = NULL, *iter = NULL;
      Text* keys;
      int i = 0, key_count;

      if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRING, attributes ? (gint32) g_hash_table_size ((GHashTable *) attributes) : 0, error)) < 0)
        return 0;
      xfer += ret;
      if (attributes)
        g_hash_table_foreach ((GHashTable *) attributes, thrift_hash_table_get_keys, &key_list);
      key_count = g_list_length (key_list);
      keys = g_newa (Text, key_count);
      for (iter = g_list_first (key_list); iter; iter = iter->next)
        keys[i++] = (Text) iter->data;
      g_list_free (key_list);

      for (i = 0; i < key_count; ++i)
      {
        key254 = keys[i];
        val255 = (Text) g_hash_table_lookup (((GHashTable *) attributes), (gpointer) key254);

        if ((ret = thrift_protocol_write_binary (protocol,  key254 ? ((GByteArray *)  key254)->data : NULL,  key254 ? ((GByteArray *)  key254)->len : 0, error)) < 0)
          return 0;
        xfer += ret;

        if ((ret = thrift_protocol_write_binary (protocol,  val255 ? ((GByteArray *)  val255)->data : NULL,  val255 ? ((GByteArray *)  val255)->len : 0, error)) < 0)
          return 0;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean hbase_client_recv_delete_all_ts (HbaseIf * iface, IOError ** io, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = HBASE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "deleteAllTs", 11) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected deleteAllTs", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *io != NULL)
            {
              g_object_unref (*io);
            }
            *io = g_object_new (TYPE_I_O_ERROR, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*io), protocol, error)) < 0)
            {
              g_object_unref (*io);
              *io = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*io != NULL)
  {
      g_set_error (error, I_O_ERROR_ERROR, I_O_ERROR_ERROR_CODE, "IOError");
      return FALSE;
  }
  return TRUE;
}

gboolean hbase_client_delete_all_ts (HbaseIf * iface, const Text tableName, const Text row, const Text column, const gint64 timestamp, const GHashTable * attributes, IOError ** io, GError ** error)
{
  if (!hbase_client_send_delete_all_ts (iface, tableName, row, column, timestamp, attributes, error))
    return FALSE;
  if (!hbase_client_recv_delete_all_ts (iface, io, error))
    return FALSE;
  return TRUE;
}

gboolean hbase_client_send_delete_all_row (HbaseIf * iface, const Text tableName, const Text row, const GHashTable * attributes, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = HBASE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "deleteAllRow", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "deleteAllRow_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "tableName", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, tableName ? ((GByteArray *) tableName)->data : NULL, tableName ? ((GByteArray *) tableName)->len : 0, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "row", T_STRING, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, row ? ((GByteArray *) row)->data : NULL, row ? ((GByteArray *) row)->len : 0, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "attributes", T_MAP, 3, error)) < 0)
      return 0;
    xfer += ret;
    {
      Text key256 = NULL;
      Text val257 = NULL;
      GList *key_list = NULL, *iter = NULL;
      Text* keys;
      int i = 0, key_count;

      if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRING, attributes ? (gint32) g_hash_table_size ((GHashTable *) attributes) : 0, error)) < 0)
        return 0;
      xfer += ret;
      if (attributes)
        g_hash_table_foreach ((GHashTable *) attributes, thrift_hash_table_get_keys, &key_list);
      key_count = g_list_length (key_list);
      keys = g_newa (Text, key_count);
      for (iter = g_list_first (key_list); iter; iter = iter->next)
        keys[i++] = (Text) iter->data;
      g_list_free (key_list);

      for (i = 0; i < key_count; ++i)
      {
        key256 = keys[i];
        val257 = (Text) g_hash_table_lookup (((GHashTable *) attributes), (gpointer) key256);

        if ((ret = thrift_protocol_write_binary (protocol,  key256 ? ((GByteArray *)  key256)->data : NULL,  key256 ? ((GByteArray *)  key256)->len : 0, error)) < 0)
          return 0;
        xfer += ret;

        if ((ret = thrift_protocol_write_binary (protocol,  val257 ? ((GByteArray *)  val257)->data : NULL,  val257 ? ((GByteArray *)  val257)->len : 0, error)) < 0)
          return 0;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean hbase_client_recv_delete_all_row (HbaseIf * iface, IOError ** io, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = HBASE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "deleteAllRow", 12) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected deleteAllRow", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *io != NULL)
            {
              g_object_unref (*io);
            }
            *io = g_object_new (TYPE_I_O_ERROR, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*io), protocol, error)) < 0)
            {
              g_object_unref (*io);
              *io = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*io != NULL)
  {
      g_set_error (error, I_O_ERROR_ERROR, I_O_ERROR_ERROR_CODE, "IOError");
      return FALSE;
  }
  return TRUE;
}

gboolean hbase_client_delete_all_row (HbaseIf * iface, const Text tableName, const Text row, const GHashTable * attributes, IOError ** io, GError ** error)
{
  if (!hbase_client_send_delete_all_row (iface, tableName, row, attributes, error))
    return FALSE;
  if (!hbase_client_recv_delete_all_row (iface, io, error))
    return FALSE;
  return TRUE;
}

gboolean hbase_client_send_increment (HbaseIf * iface, const TIncrement * increment, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = HBASE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "increment", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "increment_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "increment", T_STRUCT, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (increment), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean hbase_client_recv_increment (HbaseIf * iface, IOError ** io, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = HBASE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "increment", 9) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected increment", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *io != NULL)
            {
              g_object_unref (*io);
            }
            *io = g_object_new (TYPE_I_O_ERROR, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*io), protocol, error)) < 0)
            {
              g_object_unref (*io);
              *io = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*io != NULL)
  {
      g_set_error (error, I_O_ERROR_ERROR, I_O_ERROR_ERROR_CODE, "IOError");
      return FALSE;
  }
  return TRUE;
}

gboolean hbase_client_increment (HbaseIf * iface, const TIncrement * increment, IOError ** io, GError ** error)
{
  if (!hbase_client_send_increment (iface, increment, error))
    return FALSE;
  if (!hbase_client_recv_increment (iface, io, error))
    return FALSE;
  return TRUE;
}

gboolean hbase_client_send_increment_rows (HbaseIf * iface, const GPtrArray * increments, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = HBASE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "incrementRows", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "incrementRows_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "increments", T_LIST, 1, error)) < 0)
      return 0;
    xfer += ret;
    {
      guint i258;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (increments ? increments->len : 0), error)) < 0)
        return 0;
      xfer += ret;
      for (i258 = 0; i258 < (increments ? increments->len : 0); i258++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) increments, i258))), protocol, error)) < 0)
          return 0;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean hbase_client_recv_increment_rows (HbaseIf * iface, IOError ** io, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = HBASE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "incrementRows", 13) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected incrementRows", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *io != NULL)
            {
              g_object_unref (*io);
            }
            *io = g_object_new (TYPE_I_O_ERROR, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*io), protocol, error)) < 0)
            {
              g_object_unref (*io);
              *io = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*io != NULL)
  {
      g_set_error (error, I_O_ERROR_ERROR, I_O_ERROR_ERROR_CODE, "IOError");
      return FALSE;
  }
  return TRUE;
}

gboolean hbase_client_increment_rows (HbaseIf * iface, const GPtrArray * increments, IOError ** io, GError ** error)
{
  if (!hbase_client_send_increment_rows (iface, increments, error))
    return FALSE;
  if (!hbase_client_recv_increment_rows (iface, io, error))
    return FALSE;
  return TRUE;
}

gboolean hbase_client_send_delete_all_row_ts (HbaseIf * iface, const Text tableName, const Text row, const gint64 timestamp, const GHashTable * attributes, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = HBASE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "deleteAllRowTs", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "deleteAllRowTs_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "tableName", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, tableName ? ((GByteArray *) tableName)->data : NULL, tableName ? ((GByteArray *) tableName)->len : 0, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "row", T_STRING, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, row ? ((GByteArray *) row)->data : NULL, row ? ((GByteArray *) row)->len : 0, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "timestamp", T_I64, 3, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, timestamp, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "attributes", T_MAP, 4, error)) < 0)
      return 0;
    xfer += ret;
    {
      Text key259 = NULL;
      Text val260 = NULL;
      GList *key_list = NULL, *iter = NULL;
      Text* keys;
      int i = 0, key_count;

      if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRING, attributes ? (gint32) g_hash_table_size ((GHashTable *) attributes) : 0, error)) < 0)
        return 0;
      xfer += ret;
      if (attributes)
        g_hash_table_foreach ((GHashTable *) attributes, thrift_hash_table_get_keys, &key_list);
      key_count = g_list_length (key_list);
      keys = g_newa (Text, key_count);
      for (iter = g_list_first (key_list); iter; iter = iter->next)
        keys[i++] = (Text) iter->data;
      g_list_free (key_list);

      for (i = 0; i < key_count; ++i)
      {
        key259 = keys[i];
        val260 = (Text) g_hash_table_lookup (((GHashTable *) attributes), (gpointer) key259);

        if ((ret = thrift_protocol_write_binary (protocol,  key259 ? ((GByteArray *)  key259)->data : NULL,  key259 ? ((GByteArray *)  key259)->len : 0, error)) < 0)
          return 0;
        xfer += ret;

        if ((ret = thrift_protocol_write_binary (protocol,  val260 ? ((GByteArray *)  val260)->data : NULL,  val260 ? ((GByteArray *)  val260)->len : 0, error)) < 0)
          return 0;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean hbase_client_recv_delete_all_row_ts (HbaseIf * iface, IOError ** io, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = HBASE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "deleteAllRowTs", 14) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected deleteAllRowTs", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *io != NULL)
            {
              g_object_unref (*io);
            }
            *io = g_object_new (TYPE_I_O_ERROR, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*io), protocol, error)) < 0)
            {
              g_object_unref (*io);
              *io = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*io != NULL)
  {
      g_set_error (error, I_O_ERROR_ERROR, I_O_ERROR_ERROR_CODE, "IOError");
      return FALSE;
  }
  return TRUE;
}

gboolean hbase_client_delete_all_row_ts (HbaseIf * iface, const Text tableName, const Text row, const gint64 timestamp, const GHashTable * attributes, IOError ** io, GError ** error)
{
  if (!hbase_client_send_delete_all_row_ts (iface, tableName, row, timestamp, attributes, error))
    return FALSE;
  if (!hbase_client_recv_delete_all_row_ts (iface, io, error))
    return FALSE;
  return TRUE;
}

gboolean hbase_client_send_scanner_open_with_scan (HbaseIf * iface, const Text tableName, const TScan * scan, const GHashTable * attributes, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = HBASE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "scannerOpenWithScan", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "scannerOpenWithScan_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "tableName", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, tableName ? ((GByteArray *) tableName)->data : NULL, tableName ? ((GByteArray *) tableName)->len : 0, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "scan", T_STRUCT, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (scan), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "attributes", T_MAP, 3, error)) < 0)
      return 0;
    xfer += ret;
    {
      Text key261 = NULL;
      Text val262 = NULL;
      GList *key_list = NULL, *iter = NULL;
      Text* keys;
      int i = 0, key_count;

      if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRING, attributes ? (gint32) g_hash_table_size ((GHashTable *) attributes) : 0, error)) < 0)
        return 0;
      xfer += ret;
      if (attributes)
        g_hash_table_foreach ((GHashTable *) attributes, thrift_hash_table_get_keys, &key_list);
      key_count = g_list_length (key_list);
      keys = g_newa (Text, key_count);
      for (iter = g_list_first (key_list); iter; iter = iter->next)
        keys[i++] = (Text) iter->data;
      g_list_free (key_list);

      for (i = 0; i < key_count; ++i)
      {
        key261 = keys[i];
        val262 = (Text) g_hash_table_lookup (((GHashTable *) attributes), (gpointer) key261);

        if ((ret = thrift_protocol_write_binary (protocol,  key261 ? ((GByteArray *)  key261)->data : NULL,  key261 ? ((GByteArray *)  key261)->len : 0, error)) < 0)
          return 0;
        xfer += ret;

        if ((ret = thrift_protocol_write_binary (protocol,  val262 ? ((GByteArray *)  val262)->data : NULL,  val262 ? ((GByteArray *)  val262)->len : 0, error)) < 0)
          return 0;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean hbase_client_recv_scanner_open_with_scan (HbaseIf * iface, ScannerID* _return, IOError ** io, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = HBASE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "scannerOpenWithScan", 19) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected scannerOpenWithScan", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_I32)
          {
            if ((ret = thrift_protocol_read_i32 (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *io != NULL)
            {
              g_object_unref (*io);
            }
            *io = g_object_new (TYPE_I_O_ERROR, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*io), protocol, error)) < 0)
            {
              g_object_unref (*io);
              *io = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*io != NULL)
  {
      g_set_error (error, I_O_ERROR_ERROR, I_O_ERROR_ERROR_CODE, "IOError");
      return FALSE;
  }
  return TRUE;
}

gboolean hbase_client_scanner_open_with_scan (HbaseIf * iface, ScannerID* _return, const Text tableName, const TScan * scan, const GHashTable * attributes, IOError ** io, GError ** error)
{
  if (!hbase_client_send_scanner_open_with_scan (iface, tableName, scan, attributes, error))
    return FALSE;
  if (!hbase_client_recv_scanner_open_with_scan (iface, _return, io, error))
    return FALSE;
  return TRUE;
}

gboolean hbase_client_send_scanner_open (HbaseIf * iface, const Text tableName, const Text startRow, const GPtrArray * columns, const GHashTable * attributes, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = HBASE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "scannerOpen", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "scannerOpen_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "tableName", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, tableName ? ((GByteArray *) tableName)->data : NULL, tableName ? ((GByteArray *) tableName)->len : 0, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "startRow", T_STRING, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, startRow ? ((GByteArray *) startRow)->data : NULL, startRow ? ((GByteArray *) startRow)->len : 0, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "columns", T_LIST, 3, error)) < 0)
      return 0;
    xfer += ret;
    {
      guint i263;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (columns ? columns->len : 0), error)) < 0)
        return 0;
      xfer += ret;
      for (i263 = 0; i263 < (columns ? columns->len : 0); i263++)
      {
        if ((ret = thrift_protocol_write_binary (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) columns, i263)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) columns, i263)))->data : NULL, ((gchar*)g_ptr_array_index ((GPtrArray *) columns, i263)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) columns, i263)))->len : 0, error)) < 0)
          return 0;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "attributes", T_MAP, 4, error)) < 0)
      return 0;
    xfer += ret;
    {
      Text key264 = NULL;
      Text val265 = NULL;
      GList *key_list = NULL, *iter = NULL;
      Text* keys;
      int i = 0, key_count;

      if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRING, attributes ? (gint32) g_hash_table_size ((GHashTable *) attributes) : 0, error)) < 0)
        return 0;
      xfer += ret;
      if (attributes)
        g_hash_table_foreach ((GHashTable *) attributes, thrift_hash_table_get_keys, &key_list);
      key_count = g_list_length (key_list);
      keys = g_newa (Text, key_count);
      for (iter = g_list_first (key_list); iter; iter = iter->next)
        keys[i++] = (Text) iter->data;
      g_list_free (key_list);

      for (i = 0; i < key_count; ++i)
      {
        key264 = keys[i];
        val265 = (Text) g_hash_table_lookup (((GHashTable *) attributes), (gpointer) key264);

        if ((ret = thrift_protocol_write_binary (protocol,  key264 ? ((GByteArray *)  key264)->data : NULL,  key264 ? ((GByteArray *)  key264)->len : 0, error)) < 0)
          return 0;
        xfer += ret;

        if ((ret = thrift_protocol_write_binary (protocol,  val265 ? ((GByteArray *)  val265)->data : NULL,  val265 ? ((GByteArray *)  val265)->len : 0, error)) < 0)
          return 0;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean hbase_client_recv_scanner_open (HbaseIf * iface, ScannerID* _return, IOError ** io, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = HBASE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "scannerOpen", 11) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected scannerOpen", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_I32)
          {
            if ((ret = thrift_protocol_read_i32 (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *io != NULL)
            {
              g_object_unref (*io);
            }
            *io = g_object_new (TYPE_I_O_ERROR, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*io), protocol, error)) < 0)
            {
              g_object_unref (*io);
              *io = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*io != NULL)
  {
      g_set_error (error, I_O_ERROR_ERROR, I_O_ERROR_ERROR_CODE, "IOError");
      return FALSE;
  }
  return TRUE;
}

gboolean hbase_client_scanner_open (HbaseIf * iface, ScannerID* _return, const Text tableName, const Text startRow, const GPtrArray * columns, const GHashTable * attributes, IOError ** io, GError ** error)
{
  if (!hbase_client_send_scanner_open (iface, tableName, startRow, columns, attributes, error))
    return FALSE;
  if (!hbase_client_recv_scanner_open (iface, _return, io, error))
    return FALSE;
  return TRUE;
}

gboolean hbase_client_send_scanner_open_with_stop (HbaseIf * iface, const Text tableName, const Text startRow, const Text stopRow, const GPtrArray * columns, const GHashTable * attributes, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = HBASE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "scannerOpenWithStop", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "scannerOpenWithStop_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "tableName", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, tableName ? ((GByteArray *) tableName)->data : NULL, tableName ? ((GByteArray *) tableName)->len : 0, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "startRow", T_STRING, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, startRow ? ((GByteArray *) startRow)->data : NULL, startRow ? ((GByteArray *) startRow)->len : 0, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "stopRow", T_STRING, 3, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, stopRow ? ((GByteArray *) stopRow)->data : NULL, stopRow ? ((GByteArray *) stopRow)->len : 0, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "columns", T_LIST, 4, error)) < 0)
      return 0;
    xfer += ret;
    {
      guint i266;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (columns ? columns->len : 0), error)) < 0)
        return 0;
      xfer += ret;
      for (i266 = 0; i266 < (columns ? columns->len : 0); i266++)
      {
        if ((ret = thrift_protocol_write_binary (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) columns, i266)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) columns, i266)))->data : NULL, ((gchar*)g_ptr_array_index ((GPtrArray *) columns, i266)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) columns, i266)))->len : 0, error)) < 0)
          return 0;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "attributes", T_MAP, 5, error)) < 0)
      return 0;
    xfer += ret;
    {
      Text key267 = NULL;
      Text val268 = NULL;
      GList *key_list = NULL, *iter = NULL;
      Text* keys;
      int i = 0, key_count;

      if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRING, attributes ? (gint32) g_hash_table_size ((GHashTable *) attributes) : 0, error)) < 0)
        return 0;
      xfer += ret;
      if (attributes)
        g_hash_table_foreach ((GHashTable *) attributes, thrift_hash_table_get_keys, &key_list);
      key_count = g_list_length (key_list);
      keys = g_newa (Text, key_count);
      for (iter = g_list_first (key_list); iter; iter = iter->next)
        keys[i++] = (Text) iter->data;
      g_list_free (key_list);

      for (i = 0; i < key_count; ++i)
      {
        key267 = keys[i];
        val268 = (Text) g_hash_table_lookup (((GHashTable *) attributes), (gpointer) key267);

        if ((ret = thrift_protocol_write_binary (protocol,  key267 ? ((GByteArray *)  key267)->data : NULL,  key267 ? ((GByteArray *)  key267)->len : 0, error)) < 0)
          return 0;
        xfer += ret;

        if ((ret = thrift_protocol_write_binary (protocol,  val268 ? ((GByteArray *)  val268)->data : NULL,  val268 ? ((GByteArray *)  val268)->len : 0, error)) < 0)
          return 0;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean hbase_client_recv_scanner_open_with_stop (HbaseIf * iface, ScannerID* _return, IOError ** io, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = HBASE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "scannerOpenWithStop", 19) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected scannerOpenWithStop", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_I32)
          {
            if ((ret = thrift_protocol_read_i32 (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *io != NULL)
            {
              g_object_unref (*io);
            }
            *io = g_object_new (TYPE_I_O_ERROR, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*io), protocol, error)) < 0)
            {
              g_object_unref (*io);
              *io = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*io != NULL)
  {
      g_set_error (error, I_O_ERROR_ERROR, I_O_ERROR_ERROR_CODE, "IOError");
      return FALSE;
  }
  return TRUE;
}

gboolean hbase_client_scanner_open_with_stop (HbaseIf * iface, ScannerID* _return, const Text tableName, const Text startRow, const Text stopRow, const GPtrArray * columns, const GHashTable * attributes, IOError ** io, GError ** error)
{
  if (!hbase_client_send_scanner_open_with_stop (iface, tableName, startRow, stopRow, columns, attributes, error))
    return FALSE;
  if (!hbase_client_recv_scanner_open_with_stop (iface, _return, io, error))
    return FALSE;
  return TRUE;
}

gboolean hbase_client_send_scanner_open_with_prefix (HbaseIf * iface, const Text tableName, const Text startAndPrefix, const GPtrArray * columns, const GHashTable * attributes, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = HBASE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "scannerOpenWithPrefix", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "scannerOpenWithPrefix_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "tableName", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, tableName ? ((GByteArray *) tableName)->data : NULL, tableName ? ((GByteArray *) tableName)->len : 0, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "startAndPrefix", T_STRING, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, startAndPrefix ? ((GByteArray *) startAndPrefix)->data : NULL, startAndPrefix ? ((GByteArray *) startAndPrefix)->len : 0, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "columns", T_LIST, 3, error)) < 0)
      return 0;
    xfer += ret;
    {
      guint i269;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (columns ? columns->len : 0), error)) < 0)
        return 0;
      xfer += ret;
      for (i269 = 0; i269 < (columns ? columns->len : 0); i269++)
      {
        if ((ret = thrift_protocol_write_binary (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) columns, i269)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) columns, i269)))->data : NULL, ((gchar*)g_ptr_array_index ((GPtrArray *) columns, i269)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) columns, i269)))->len : 0, error)) < 0)
          return 0;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "attributes", T_MAP, 4, error)) < 0)
      return 0;
    xfer += ret;
    {
      Text key270 = NULL;
      Text val271 = NULL;
      GList *key_list = NULL, *iter = NULL;
      Text* keys;
      int i = 0, key_count;

      if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRING, attributes ? (gint32) g_hash_table_size ((GHashTable *) attributes) : 0, error)) < 0)
        return 0;
      xfer += ret;
      if (attributes)
        g_hash_table_foreach ((GHashTable *) attributes, thrift_hash_table_get_keys, &key_list);
      key_count = g_list_length (key_list);
      keys = g_newa (Text, key_count);
      for (iter = g_list_first (key_list); iter; iter = iter->next)
        keys[i++] = (Text) iter->data;
      g_list_free (key_list);

      for (i = 0; i < key_count; ++i)
      {
        key270 = keys[i];
        val271 = (Text) g_hash_table_lookup (((GHashTable *) attributes), (gpointer) key270);

        if ((ret = thrift_protocol_write_binary (protocol,  key270 ? ((GByteArray *)  key270)->data : NULL,  key270 ? ((GByteArray *)  key270)->len : 0, error)) < 0)
          return 0;
        xfer += ret;

        if ((ret = thrift_protocol_write_binary (protocol,  val271 ? ((GByteArray *)  val271)->data : NULL,  val271 ? ((GByteArray *)  val271)->len : 0, error)) < 0)
          return 0;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean hbase_client_recv_scanner_open_with_prefix (HbaseIf * iface, ScannerID* _return, IOError ** io, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = HBASE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "scannerOpenWithPrefix", 21) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected scannerOpenWithPrefix", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_I32)
          {
            if ((ret = thrift_protocol_read_i32 (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *io != NULL)
            {
              g_object_unref (*io);
            }
            *io = g_object_new (TYPE_I_O_ERROR, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*io), protocol, error)) < 0)
            {
              g_object_unref (*io);
              *io = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*io != NULL)
  {
      g_set_error (error, I_O_ERROR_ERROR, I_O_ERROR_ERROR_CODE, "IOError");
      return FALSE;
  }
  return TRUE;
}

gboolean hbase_client_scanner_open_with_prefix (HbaseIf * iface, ScannerID* _return, const Text tableName, const Text startAndPrefix, const GPtrArray * columns, const GHashTable * attributes, IOError ** io, GError ** error)
{
  if (!hbase_client_send_scanner_open_with_prefix (iface, tableName, startAndPrefix, columns, attributes, error))
    return FALSE;
  if (!hbase_client_recv_scanner_open_with_prefix (iface, _return, io, error))
    return FALSE;
  return TRUE;
}

gboolean hbase_client_send_scanner_open_ts (HbaseIf * iface, const Text tableName, const Text startRow, const GPtrArray * columns, const gint64 timestamp, const GHashTable * attributes, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = HBASE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "scannerOpenTs", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "scannerOpenTs_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "tableName", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, tableName ? ((GByteArray *) tableName)->data : NULL, tableName ? ((GByteArray *) tableName)->len : 0, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "startRow", T_STRING, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, startRow ? ((GByteArray *) startRow)->data : NULL, startRow ? ((GByteArray *) startRow)->len : 0, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "columns", T_LIST, 3, error)) < 0)
      return 0;
    xfer += ret;
    {
      guint i272;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (columns ? columns->len : 0), error)) < 0)
        return 0;
      xfer += ret;
      for (i272 = 0; i272 < (columns ? columns->len : 0); i272++)
      {
        if ((ret = thrift_protocol_write_binary (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) columns, i272)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) columns, i272)))->data : NULL, ((gchar*)g_ptr_array_index ((GPtrArray *) columns, i272)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) columns, i272)))->len : 0, error)) < 0)
          return 0;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "timestamp", T_I64, 4, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, timestamp, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "attributes", T_MAP, 5, error)) < 0)
      return 0;
    xfer += ret;
    {
      Text key273 = NULL;
      Text val274 = NULL;
      GList *key_list = NULL, *iter = NULL;
      Text* keys;
      int i = 0, key_count;

      if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRING, attributes ? (gint32) g_hash_table_size ((GHashTable *) attributes) : 0, error)) < 0)
        return 0;
      xfer += ret;
      if (attributes)
        g_hash_table_foreach ((GHashTable *) attributes, thrift_hash_table_get_keys, &key_list);
      key_count = g_list_length (key_list);
      keys = g_newa (Text, key_count);
      for (iter = g_list_first (key_list); iter; iter = iter->next)
        keys[i++] = (Text) iter->data;
      g_list_free (key_list);

      for (i = 0; i < key_count; ++i)
      {
        key273 = keys[i];
        val274 = (Text) g_hash_table_lookup (((GHashTable *) attributes), (gpointer) key273);

        if ((ret = thrift_protocol_write_binary (protocol,  key273 ? ((GByteArray *)  key273)->data : NULL,  key273 ? ((GByteArray *)  key273)->len : 0, error)) < 0)
          return 0;
        xfer += ret;

        if ((ret = thrift_protocol_write_binary (protocol,  val274 ? ((GByteArray *)  val274)->data : NULL,  val274 ? ((GByteArray *)  val274)->len : 0, error)) < 0)
          return 0;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean hbase_client_recv_scanner_open_ts (HbaseIf * iface, ScannerID* _return, IOError ** io, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = HBASE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "scannerOpenTs", 13) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected scannerOpenTs", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_I32)
          {
            if ((ret = thrift_protocol_read_i32 (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *io != NULL)
            {
              g_object_unref (*io);
            }
            *io = g_object_new (TYPE_I_O_ERROR, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*io), protocol, error)) < 0)
            {
              g_object_unref (*io);
              *io = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*io != NULL)
  {
      g_set_error (error, I_O_ERROR_ERROR, I_O_ERROR_ERROR_CODE, "IOError");
      return FALSE;
  }
  return TRUE;
}

gboolean hbase_client_scanner_open_ts (HbaseIf * iface, ScannerID* _return, const Text tableName, const Text startRow, const GPtrArray * columns, const gint64 timestamp, const GHashTable * attributes, IOError ** io, GError ** error)
{
  if (!hbase_client_send_scanner_open_ts (iface, tableName, startRow, columns, timestamp, attributes, error))
    return FALSE;
  if (!hbase_client_recv_scanner_open_ts (iface, _return, io, error))
    return FALSE;
  return TRUE;
}

gboolean hbase_client_send_scanner_open_with_stop_ts (HbaseIf * iface, const Text tableName, const Text startRow, const Text stopRow, const GPtrArray * columns, const gint64 timestamp, const GHashTable * attributes, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = HBASE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "scannerOpenWithStopTs", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "scannerOpenWithStopTs_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "tableName", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, tableName ? ((GByteArray *) tableName)->data : NULL, tableName ? ((GByteArray *) tableName)->len : 0, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "startRow", T_STRING, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, startRow ? ((GByteArray *) startRow)->data : NULL, startRow ? ((GByteArray *) startRow)->len : 0, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "stopRow", T_STRING, 3, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, stopRow ? ((GByteArray *) stopRow)->data : NULL, stopRow ? ((GByteArray *) stopRow)->len : 0, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "columns", T_LIST, 4, error)) < 0)
      return 0;
    xfer += ret;
    {
      guint i275;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (columns ? columns->len : 0), error)) < 0)
        return 0;
      xfer += ret;
      for (i275 = 0; i275 < (columns ? columns->len : 0); i275++)
      {
        if ((ret = thrift_protocol_write_binary (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) columns, i275)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) columns, i275)))->data : NULL, ((gchar*)g_ptr_array_index ((GPtrArray *) columns, i275)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) columns, i275)))->len : 0, error)) < 0)
          return 0;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "timestamp", T_I64, 5, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, timestamp, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "attributes", T_MAP, 6, error)) < 0)
      return 0;
    xfer += ret;
    {
      Text key276 = NULL;
      Text val277 = NULL;
      GList *key_list = NULL, *iter = NULL;
      Text* keys;
      int i = 0, key_count;

      if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRING, attributes ? (gint32) g_hash_table_size ((GHashTable *) attributes) : 0, error)) < 0)
        return 0;
      xfer += ret;
      if (attributes)
        g_hash_table_foreach ((GHashTable *) attributes, thrift_hash_table_get_keys, &key_list);
      key_count = g_list_length (key_list);
      keys = g_newa (Text, key_count);
      for (iter = g_list_first (key_list); iter; iter = iter->next)
        keys[i++] = (Text) iter->data;
      g_list_free (key_list);

      for (i = 0; i < key_count; ++i)
      {
        key276 = keys[i];
        val277 = (Text) g_hash_table_lookup (((GHashTable *) attributes), (gpointer) key276);

        if ((ret = thrift_protocol_write_binary (protocol,  key276 ? ((GByteArray *)  key276)->data : NULL,  key276 ? ((GByteArray *)  key276)->len : 0, error)) < 0)
          return 0;
        xfer += ret;

        if ((ret = thrift_protocol_write_binary (protocol,  val277 ? ((GByteArray *)  val277)->data : NULL,  val277 ? ((GByteArray *)  val277)->len : 0, error)) < 0)
          return 0;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean hbase_client_recv_scanner_open_with_stop_ts (HbaseIf * iface, ScannerID* _return, IOError ** io, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = HBASE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "scannerOpenWithStopTs", 21) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected scannerOpenWithStopTs", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_I32)
          {
            if ((ret = thrift_protocol_read_i32 (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *io != NULL)
            {
              g_object_unref (*io);
            }
            *io = g_object_new (TYPE_I_O_ERROR, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*io), protocol, error)) < 0)
            {
              g_object_unref (*io);
              *io = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*io != NULL)
  {
      g_set_error (error, I_O_ERROR_ERROR, I_O_ERROR_ERROR_CODE, "IOError");
      return FALSE;
  }
  return TRUE;
}

gboolean hbase_client_scanner_open_with_stop_ts (HbaseIf * iface, ScannerID* _return, const Text tableName, const Text startRow, const Text stopRow, const GPtrArray * columns, const gint64 timestamp, const GHashTable * attributes, IOError ** io, GError ** error)
{
  if (!hbase_client_send_scanner_open_with_stop_ts (iface, tableName, startRow, stopRow, columns, timestamp, attributes, error))
    return FALSE;
  if (!hbase_client_recv_scanner_open_with_stop_ts (iface, _return, io, error))
    return FALSE;
  return TRUE;
}

gboolean hbase_client_send_scanner_get (HbaseIf * iface, const ScannerID id, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = HBASE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "scannerGet", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "scannerGet_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "id", T_I32, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, id, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean hbase_client_recv_scanner_get (HbaseIf * iface, GPtrArray ** _return, IOError ** io, IllegalArgument ** ia, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = HBASE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "scannerGet", 10) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected scannerGet", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_LIST)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType element_type;

              if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through list elements */
              for (i = 0; i < size; i++)
              {
                TRowResult * _elem278 = NULL;
                if ( _elem278 != NULL)
                {
                  g_object_unref (_elem278);
                }
                _elem278 = g_object_new (TYPE_T_ROW_RESULT, NULL);
                if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem278), protocol, error)) < 0)
                {
                  g_object_unref (_elem278);
                  return 0;
                }
                xfer += ret;
                g_ptr_array_add (*_return, _elem278);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *io != NULL)
            {
              g_object_unref (*io);
            }
            *io = g_object_new (TYPE_I_O_ERROR, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*io), protocol, error)) < 0)
            {
              g_object_unref (*io);
              *io = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 2:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ia != NULL)
            {
              g_object_unref (*ia);
            }
            *ia = g_object_new (TYPE_ILLEGAL_ARGUMENT, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ia), protocol, error)) < 0)
            {
              g_object_unref (*ia);
              *ia = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*io != NULL)
  {
      g_set_error (error, I_O_ERROR_ERROR, I_O_ERROR_ERROR_CODE, "IOError");
      return FALSE;
  }
  if (*ia != NULL)
  {
      g_set_error (error, ILLEGAL_ARGUMENT_ERROR, ILLEGAL_ARGUMENT_ERROR_CODE, "IllegalArgument");
      return FALSE;
  }
  return TRUE;
}

gboolean hbase_client_scanner_get (HbaseIf * iface, GPtrArray ** _return, const ScannerID id, IOError ** io, IllegalArgument ** ia, GError ** error)
{
  if (!hbase_client_send_scanner_get (iface, id, error))
    return FALSE;
  if (!hbase_client_recv_scanner_get (iface, _return, io, ia, error))
    return FALSE;
  return TRUE;
}

gboolean hbase_client_send_scanner_get_list (HbaseIf * iface, const ScannerID id, const gint32 nbRows, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = HBASE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "scannerGetList", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "scannerGetList_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "id", T_I32, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, id, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "nbRows", T_I32, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, nbRows, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean hbase_client_recv_scanner_get_list (HbaseIf * iface, GPtrArray ** _return, IOError ** io, IllegalArgument ** ia, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = HBASE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "scannerGetList", 14) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected scannerGetList", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_LIST)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType element_type;

              if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through list elements */
              for (i = 0; i < size; i++)
              {
                TRowResult * _elem279 = NULL;
                if ( _elem279 != NULL)
                {
                  g_object_unref (_elem279);
                }
                _elem279 = g_object_new (TYPE_T_ROW_RESULT, NULL);
                if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem279), protocol, error)) < 0)
                {
                  g_object_unref (_elem279);
                  return 0;
                }
                xfer += ret;
                g_ptr_array_add (*_return, _elem279);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *io != NULL)
            {
              g_object_unref (*io);
            }
            *io = g_object_new (TYPE_I_O_ERROR, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*io), protocol, error)) < 0)
            {
              g_object_unref (*io);
              *io = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 2:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ia != NULL)
            {
              g_object_unref (*ia);
            }
            *ia = g_object_new (TYPE_ILLEGAL_ARGUMENT, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ia), protocol, error)) < 0)
            {
              g_object_unref (*ia);
              *ia = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*io != NULL)
  {
      g_set_error (error, I_O_ERROR_ERROR, I_O_ERROR_ERROR_CODE, "IOError");
      return FALSE;
  }
  if (*ia != NULL)
  {
      g_set_error (error, ILLEGAL_ARGUMENT_ERROR, ILLEGAL_ARGUMENT_ERROR_CODE, "IllegalArgument");
      return FALSE;
  }
  return TRUE;
}

gboolean hbase_client_scanner_get_list (HbaseIf * iface, GPtrArray ** _return, const ScannerID id, const gint32 nbRows, IOError ** io, IllegalArgument ** ia, GError ** error)
{
  if (!hbase_client_send_scanner_get_list (iface, id, nbRows, error))
    return FALSE;
  if (!hbase_client_recv_scanner_get_list (iface, _return, io, ia, error))
    return FALSE;
  return TRUE;
}

gboolean hbase_client_send_scanner_close (HbaseIf * iface, const ScannerID id, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = HBASE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "scannerClose", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "scannerClose_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "id", T_I32, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, id, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean hbase_client_recv_scanner_close (HbaseIf * iface, IOError ** io, IllegalArgument ** ia, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = HBASE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "scannerClose", 12) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected scannerClose", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *io != NULL)
            {
              g_object_unref (*io);
            }
            *io = g_object_new (TYPE_I_O_ERROR, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*io), protocol, error)) < 0)
            {
              g_object_unref (*io);
              *io = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 2:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ia != NULL)
            {
              g_object_unref (*ia);
            }
            *ia = g_object_new (TYPE_ILLEGAL_ARGUMENT, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ia), protocol, error)) < 0)
            {
              g_object_unref (*ia);
              *ia = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*io != NULL)
  {
      g_set_error (error, I_O_ERROR_ERROR, I_O_ERROR_ERROR_CODE, "IOError");
      return FALSE;
  }
  if (*ia != NULL)
  {
      g_set_error (error, ILLEGAL_ARGUMENT_ERROR, ILLEGAL_ARGUMENT_ERROR_CODE, "IllegalArgument");
      return FALSE;
  }
  return TRUE;
}

gboolean hbase_client_scanner_close (HbaseIf * iface, const ScannerID id, IOError ** io, IllegalArgument ** ia, GError ** error)
{
  if (!hbase_client_send_scanner_close (iface, id, error))
    return FALSE;
  if (!hbase_client_recv_scanner_close (iface, io, ia, error))
    return FALSE;
  return TRUE;
}

gboolean hbase_client_send_get_row_or_before (HbaseIf * iface, const Text tableName, const Text row, const Text family, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = HBASE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getRowOrBefore", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getRowOrBefore_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "tableName", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, tableName ? ((GByteArray *) tableName)->data : NULL, tableName ? ((GByteArray *) tableName)->len : 0, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "row", T_STRING, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, row ? ((GByteArray *) row)->data : NULL, row ? ((GByteArray *) row)->len : 0, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "family", T_STRING, 3, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, family ? ((GByteArray *) family)->data : NULL, family ? ((GByteArray *) family)->len : 0, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean hbase_client_recv_get_row_or_before (HbaseIf * iface, GPtrArray ** _return, IOError ** io, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = HBASE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getRowOrBefore", 14) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getRowOrBefore", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_LIST)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType element_type;

              if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through list elements */
              for (i = 0; i < size; i++)
              {
                TCell * _elem280 = NULL;
                if ( _elem280 != NULL)
                {
                  g_object_unref (_elem280);
                }
                _elem280 = g_object_new (TYPE_T_CELL, NULL);
                if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem280), protocol, error)) < 0)
                {
                  g_object_unref (_elem280);
                  return 0;
                }
                xfer += ret;
                g_ptr_array_add (*_return, _elem280);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *io != NULL)
            {
              g_object_unref (*io);
            }
            *io = g_object_new (TYPE_I_O_ERROR, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*io), protocol, error)) < 0)
            {
              g_object_unref (*io);
              *io = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*io != NULL)
  {
      g_set_error (error, I_O_ERROR_ERROR, I_O_ERROR_ERROR_CODE, "IOError");
      return FALSE;
  }
  return TRUE;
}

gboolean hbase_client_get_row_or_before (HbaseIf * iface, GPtrArray ** _return, const Text tableName, const Text row, const Text family, IOError ** io, GError ** error)
{
  if (!hbase_client_send_get_row_or_before (iface, tableName, row, family, error))
    return FALSE;
  if (!hbase_client_recv_get_row_or_before (iface, _return, io, error))
    return FALSE;
  return TRUE;
}

gboolean hbase_client_send_get_region_info (HbaseIf * iface, const Text row, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = HBASE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getRegionInfo", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getRegionInfo_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "row", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, row ? ((GByteArray *) row)->data : NULL, row ? ((GByteArray *) row)->len : 0, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean hbase_client_recv_get_region_info (HbaseIf * iface, TRegionInfo ** _return, IOError ** io, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = HBASE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getRegionInfo", 13) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getRegionInfo", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRUCT)
          {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*_return), protocol, error)) < 0)
            {
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *io != NULL)
            {
              g_object_unref (*io);
            }
            *io = g_object_new (TYPE_I_O_ERROR, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*io), protocol, error)) < 0)
            {
              g_object_unref (*io);
              *io = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*io != NULL)
  {
      g_set_error (error, I_O_ERROR_ERROR, I_O_ERROR_ERROR_CODE, "IOError");
      return FALSE;
  }
  return TRUE;
}

gboolean hbase_client_get_region_info (HbaseIf * iface, TRegionInfo ** _return, const Text row, IOError ** io, GError ** error)
{
  if (!hbase_client_send_get_region_info (iface, row, error))
    return FALSE;
  if (!hbase_client_recv_get_region_info (iface, _return, io, error))
    return FALSE;
  return TRUE;
}

gboolean hbase_client_send_append (HbaseIf * iface, const TAppend * append, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = HBASE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "append", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "append_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "append", T_STRUCT, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (append), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean hbase_client_recv_append (HbaseIf * iface, GPtrArray ** _return, IOError ** io, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = HBASE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "append", 6) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected append", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_LIST)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType element_type;

              if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through list elements */
              for (i = 0; i < size; i++)
              {
                TCell * _elem281 = NULL;
                if ( _elem281 != NULL)
                {
                  g_object_unref (_elem281);
                }
                _elem281 = g_object_new (TYPE_T_CELL, NULL);
                if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem281), protocol, error)) < 0)
                {
                  g_object_unref (_elem281);
                  return 0;
                }
                xfer += ret;
                g_ptr_array_add (*_return, _elem281);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *io != NULL)
            {
              g_object_unref (*io);
            }
            *io = g_object_new (TYPE_I_O_ERROR, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*io), protocol, error)) < 0)
            {
              g_object_unref (*io);
              *io = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*io != NULL)
  {
      g_set_error (error, I_O_ERROR_ERROR, I_O_ERROR_ERROR_CODE, "IOError");
      return FALSE;
  }
  return TRUE;
}

gboolean hbase_client_append (HbaseIf * iface, GPtrArray ** _return, const TAppend * append, IOError ** io, GError ** error)
{
  if (!hbase_client_send_append (iface, append, error))
    return FALSE;
  if (!hbase_client_recv_append (iface, _return, io, error))
    return FALSE;
  return TRUE;
}

gboolean hbase_client_send_check_and_put (HbaseIf * iface, const Text tableName, const Text row, const Text column, const Text value, const Mutation * mput, const GHashTable * attributes, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = HBASE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "checkAndPut", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "checkAndPut_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "tableName", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, tableName ? ((GByteArray *) tableName)->data : NULL, tableName ? ((GByteArray *) tableName)->len : 0, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "row", T_STRING, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, row ? ((GByteArray *) row)->data : NULL, row ? ((GByteArray *) row)->len : 0, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "column", T_STRING, 3, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, column ? ((GByteArray *) column)->data : NULL, column ? ((GByteArray *) column)->len : 0, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "value", T_STRING, 5, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, value ? ((GByteArray *) value)->data : NULL, value ? ((GByteArray *) value)->len : 0, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "mput", T_STRUCT, 6, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (mput), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "attributes", T_MAP, 7, error)) < 0)
      return 0;
    xfer += ret;
    {
      Text key282 = NULL;
      Text val283 = NULL;
      GList *key_list = NULL, *iter = NULL;
      Text* keys;
      int i = 0, key_count;

      if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRING, attributes ? (gint32) g_hash_table_size ((GHashTable *) attributes) : 0, error)) < 0)
        return 0;
      xfer += ret;
      if (attributes)
        g_hash_table_foreach ((GHashTable *) attributes, thrift_hash_table_get_keys, &key_list);
      key_count = g_list_length (key_list);
      keys = g_newa (Text, key_count);
      for (iter = g_list_first (key_list); iter; iter = iter->next)
        keys[i++] = (Text) iter->data;
      g_list_free (key_list);

      for (i = 0; i < key_count; ++i)
      {
        key282 = keys[i];
        val283 = (Text) g_hash_table_lookup (((GHashTable *) attributes), (gpointer) key282);

        if ((ret = thrift_protocol_write_binary (protocol,  key282 ? ((GByteArray *)  key282)->data : NULL,  key282 ? ((GByteArray *)  key282)->len : 0, error)) < 0)
          return 0;
        xfer += ret;

        if ((ret = thrift_protocol_write_binary (protocol,  val283 ? ((GByteArray *)  val283)->data : NULL,  val283 ? ((GByteArray *)  val283)->len : 0, error)) < 0)
          return 0;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean hbase_client_recv_check_and_put (HbaseIf * iface, gboolean* _return, IOError ** io, IllegalArgument ** ia, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = HBASE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "checkAndPut", 11) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected checkAndPut", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_BOOL)
          {
            if ((ret = thrift_protocol_read_bool (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *io != NULL)
            {
              g_object_unref (*io);
            }
            *io = g_object_new (TYPE_I_O_ERROR, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*io), protocol, error)) < 0)
            {
              g_object_unref (*io);
              *io = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 2:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ia != NULL)
            {
              g_object_unref (*ia);
            }
            *ia = g_object_new (TYPE_ILLEGAL_ARGUMENT, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ia), protocol, error)) < 0)
            {
              g_object_unref (*ia);
              *ia = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*io != NULL)
  {
      g_set_error (error, I_O_ERROR_ERROR, I_O_ERROR_ERROR_CODE, "IOError");
      return FALSE;
  }
  if (*ia != NULL)
  {
      g_set_error (error, ILLEGAL_ARGUMENT_ERROR, ILLEGAL_ARGUMENT_ERROR_CODE, "IllegalArgument");
      return FALSE;
  }
  return TRUE;
}

gboolean hbase_client_check_and_put (HbaseIf * iface, gboolean* _return, const Text tableName, const Text row, const Text column, const Text value, const Mutation * mput, const GHashTable * attributes, IOError ** io, IllegalArgument ** ia, GError ** error)
{
  if (!hbase_client_send_check_and_put (iface, tableName, row, column, value, mput, attributes, error))
    return FALSE;
  if (!hbase_client_recv_check_and_put (iface, _return, io, ia, error))
    return FALSE;
  return TRUE;
}

static void
hbase_if_interface_init (HbaseIfInterface *iface)
{
  iface->enable_table = hbase_client_enable_table;
  iface->disable_table = hbase_client_disable_table;
  iface->is_table_enabled = hbase_client_is_table_enabled;
  iface->compact = hbase_client_compact;
  iface->major_compact = hbase_client_major_compact;
  iface->get_table_names = hbase_client_get_table_names;
  iface->get_column_descriptors = hbase_client_get_column_descriptors;
  iface->get_table_regions = hbase_client_get_table_regions;
  iface->create_table = hbase_client_create_table;
  iface->delete_table = hbase_client_delete_table;
  iface->get = hbase_client_get;
  iface->get_ver = hbase_client_get_ver;
  iface->get_ver_ts = hbase_client_get_ver_ts;
  iface->get_row = hbase_client_get_row;
  iface->get_row_with_columns = hbase_client_get_row_with_columns;
  iface->get_row_ts = hbase_client_get_row_ts;
  iface->get_row_with_columns_ts = hbase_client_get_row_with_columns_ts;
  iface->get_rows = hbase_client_get_rows;
  iface->get_rows_with_columns = hbase_client_get_rows_with_columns;
  iface->get_rows_ts = hbase_client_get_rows_ts;
  iface->get_rows_with_columns_ts = hbase_client_get_rows_with_columns_ts;
  iface->mutate_row = hbase_client_mutate_row;
  iface->mutate_row_ts = hbase_client_mutate_row_ts;
  iface->mutate_rows = hbase_client_mutate_rows;
  iface->mutate_rows_ts = hbase_client_mutate_rows_ts;
  iface->atomic_increment = hbase_client_atomic_increment;
  iface->delete_all = hbase_client_delete_all;
  iface->delete_all_ts = hbase_client_delete_all_ts;
  iface->delete_all_row = hbase_client_delete_all_row;
  iface->increment = hbase_client_increment;
  iface->increment_rows = hbase_client_increment_rows;
  iface->delete_all_row_ts = hbase_client_delete_all_row_ts;
  iface->scanner_open_with_scan = hbase_client_scanner_open_with_scan;
  iface->scanner_open = hbase_client_scanner_open;
  iface->scanner_open_with_stop = hbase_client_scanner_open_with_stop;
  iface->scanner_open_with_prefix = hbase_client_scanner_open_with_prefix;
  iface->scanner_open_ts = hbase_client_scanner_open_ts;
  iface->scanner_open_with_stop_ts = hbase_client_scanner_open_with_stop_ts;
  iface->scanner_get = hbase_client_scanner_get;
  iface->scanner_get_list = hbase_client_scanner_get_list;
  iface->scanner_close = hbase_client_scanner_close;
  iface->get_row_or_before = hbase_client_get_row_or_before;
  iface->get_region_info = hbase_client_get_region_info;
  iface->append = hbase_client_append;
  iface->check_and_put = hbase_client_check_and_put;
}

static void
hbase_client_init (HbaseClient *client)
{
  client->input_protocol = NULL;
  client->output_protocol = NULL;
}

static void
hbase_client_class_init (HbaseClientClass *cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  GParamSpec *param_spec;

  gobject_class->set_property = hbase_client_set_property;
  gobject_class->get_property = hbase_client_get_property;

  param_spec = g_param_spec_object ("input_protocol",
                                    "input protocol (construct)",
                                    "Set the client input protocol",
                                    THRIFT_TYPE_PROTOCOL,
                                    G_PARAM_READWRITE);
  g_object_class_install_property (gobject_class,
                                   PROP_HBASE_CLIENT_INPUT_PROTOCOL, param_spec);

  param_spec = g_param_spec_object ("output_protocol",
                                    "output protocol (construct)",
                                    "Set the client output protocol",
                                    THRIFT_TYPE_PROTOCOL,
                                    G_PARAM_READWRITE);
  g_object_class_install_property (gobject_class,
                                   PROP_HBASE_CLIENT_OUTPUT_PROTOCOL, param_spec);
}

static void
hbase_handler_hbase_if_interface_init (HbaseIfInterface *iface);

G_DEFINE_TYPE_WITH_CODE (HbaseHandler, 
                         hbase_handler,
                         G_TYPE_OBJECT,
                         G_IMPLEMENT_INTERFACE (TYPE_HBASE_IF,
                                                hbase_handler_hbase_if_interface_init))

gboolean hbase_handler_enable_table (HbaseIf * iface, const Bytes tableName, IOError ** io, GError ** error)
{
  g_return_val_if_fail (IS_HBASE_HANDLER (iface), FALSE);

  return HBASE_HANDLER_GET_CLASS (iface)->enable_table (iface, tableName, io, error);
}

gboolean hbase_handler_disable_table (HbaseIf * iface, const Bytes tableName, IOError ** io, GError ** error)
{
  g_return_val_if_fail (IS_HBASE_HANDLER (iface), FALSE);

  return HBASE_HANDLER_GET_CLASS (iface)->disable_table (iface, tableName, io, error);
}

gboolean hbase_handler_is_table_enabled (HbaseIf * iface, gboolean* _return, const Bytes tableName, IOError ** io, GError ** error)
{
  g_return_val_if_fail (IS_HBASE_HANDLER (iface), FALSE);

  return HBASE_HANDLER_GET_CLASS (iface)->is_table_enabled (iface, _return, tableName, io, error);
}

gboolean hbase_handler_compact (HbaseIf * iface, const Bytes tableNameOrRegionName, IOError ** io, GError ** error)
{
  g_return_val_if_fail (IS_HBASE_HANDLER (iface), FALSE);

  return HBASE_HANDLER_GET_CLASS (iface)->compact (iface, tableNameOrRegionName, io, error);
}

gboolean hbase_handler_major_compact (HbaseIf * iface, const Bytes tableNameOrRegionName, IOError ** io, GError ** error)
{
  g_return_val_if_fail (IS_HBASE_HANDLER (iface), FALSE);

  return HBASE_HANDLER_GET_CLASS (iface)->major_compact (iface, tableNameOrRegionName, io, error);
}

gboolean hbase_handler_get_table_names (HbaseIf * iface, GPtrArray ** _return, IOError ** io, GError ** error)
{
  g_return_val_if_fail (IS_HBASE_HANDLER (iface), FALSE);

  return HBASE_HANDLER_GET_CLASS (iface)->get_table_names (iface, _return, io, error);
}

gboolean hbase_handler_get_column_descriptors (HbaseIf * iface, GHashTable ** _return, const Text tableName, IOError ** io, GError ** error)
{
  g_return_val_if_fail (IS_HBASE_HANDLER (iface), FALSE);

  return HBASE_HANDLER_GET_CLASS (iface)->get_column_descriptors (iface, _return, tableName, io, error);
}

gboolean hbase_handler_get_table_regions (HbaseIf * iface, GPtrArray ** _return, const Text tableName, IOError ** io, GError ** error)
{
  g_return_val_if_fail (IS_HBASE_HANDLER (iface), FALSE);

  return HBASE_HANDLER_GET_CLASS (iface)->get_table_regions (iface, _return, tableName, io, error);
}

gboolean hbase_handler_create_table (HbaseIf * iface, const Text tableName, const GPtrArray * columnFamilies, IOError ** io, IllegalArgument ** ia, AlreadyExists ** exist, GError ** error)
{
  g_return_val_if_fail (IS_HBASE_HANDLER (iface), FALSE);

  return HBASE_HANDLER_GET_CLASS (iface)->create_table (iface, tableName, columnFamilies, io, ia, exist, error);
}

gboolean hbase_handler_delete_table (HbaseIf * iface, const Text tableName, IOError ** io, GError ** error)
{
  g_return_val_if_fail (IS_HBASE_HANDLER (iface), FALSE);

  return HBASE_HANDLER_GET_CLASS (iface)->delete_table (iface, tableName, io, error);
}

gboolean hbase_handler_get (HbaseIf * iface, GPtrArray ** _return, const Text tableName, const Text row, const Text column, const GHashTable * attributes, IOError ** io, GError ** error)
{
  g_return_val_if_fail (IS_HBASE_HANDLER (iface), FALSE);

  return HBASE_HANDLER_GET_CLASS (iface)->get (iface, _return, tableName, row, column, attributes, io, error);
}

gboolean hbase_handler_get_ver (HbaseIf * iface, GPtrArray ** _return, const Text tableName, const Text row, const Text column, const gint32 numVersions, const GHashTable * attributes, IOError ** io, GError ** error)
{
  g_return_val_if_fail (IS_HBASE_HANDLER (iface), FALSE);

  return HBASE_HANDLER_GET_CLASS (iface)->get_ver (iface, _return, tableName, row, column, numVersions, attributes, io, error);
}

gboolean hbase_handler_get_ver_ts (HbaseIf * iface, GPtrArray ** _return, const Text tableName, const Text row, const Text column, const gint64 timestamp, const gint32 numVersions, const GHashTable * attributes, IOError ** io, GError ** error)
{
  g_return_val_if_fail (IS_HBASE_HANDLER (iface), FALSE);

  return HBASE_HANDLER_GET_CLASS (iface)->get_ver_ts (iface, _return, tableName, row, column, timestamp, numVersions, attributes, io, error);
}

gboolean hbase_handler_get_row (HbaseIf * iface, GPtrArray ** _return, const Text tableName, const Text row, const GHashTable * attributes, IOError ** io, GError ** error)
{
  g_return_val_if_fail (IS_HBASE_HANDLER (iface), FALSE);

  return HBASE_HANDLER_GET_CLASS (iface)->get_row (iface, _return, tableName, row, attributes, io, error);
}

gboolean hbase_handler_get_row_with_columns (HbaseIf * iface, GPtrArray ** _return, const Text tableName, const Text row, const GPtrArray * columns, const GHashTable * attributes, IOError ** io, GError ** error)
{
  g_return_val_if_fail (IS_HBASE_HANDLER (iface), FALSE);

  return HBASE_HANDLER_GET_CLASS (iface)->get_row_with_columns (iface, _return, tableName, row, columns, attributes, io, error);
}

gboolean hbase_handler_get_row_ts (HbaseIf * iface, GPtrArray ** _return, const Text tableName, const Text row, const gint64 timestamp, const GHashTable * attributes, IOError ** io, GError ** error)
{
  g_return_val_if_fail (IS_HBASE_HANDLER (iface), FALSE);

  return HBASE_HANDLER_GET_CLASS (iface)->get_row_ts (iface, _return, tableName, row, timestamp, attributes, io, error);
}

gboolean hbase_handler_get_row_with_columns_ts (HbaseIf * iface, GPtrArray ** _return, const Text tableName, const Text row, const GPtrArray * columns, const gint64 timestamp, const GHashTable * attributes, IOError ** io, GError ** error)
{
  g_return_val_if_fail (IS_HBASE_HANDLER (iface), FALSE);

  return HBASE_HANDLER_GET_CLASS (iface)->get_row_with_columns_ts (iface, _return, tableName, row, columns, timestamp, attributes, io, error);
}

gboolean hbase_handler_get_rows (HbaseIf * iface, GPtrArray ** _return, const Text tableName, const GPtrArray * rows, const GHashTable * attributes, IOError ** io, GError ** error)
{
  g_return_val_if_fail (IS_HBASE_HANDLER (iface), FALSE);

  return HBASE_HANDLER_GET_CLASS (iface)->get_rows (iface, _return, tableName, rows, attributes, io, error);
}

gboolean hbase_handler_get_rows_with_columns (HbaseIf * iface, GPtrArray ** _return, const Text tableName, const GPtrArray * rows, const GPtrArray * columns, const GHashTable * attributes, IOError ** io, GError ** error)
{
  g_return_val_if_fail (IS_HBASE_HANDLER (iface), FALSE);

  return HBASE_HANDLER_GET_CLASS (iface)->get_rows_with_columns (iface, _return, tableName, rows, columns, attributes, io, error);
}

gboolean hbase_handler_get_rows_ts (HbaseIf * iface, GPtrArray ** _return, const Text tableName, const GPtrArray * rows, const gint64 timestamp, const GHashTable * attributes, IOError ** io, GError ** error)
{
  g_return_val_if_fail (IS_HBASE_HANDLER (iface), FALSE);

  return HBASE_HANDLER_GET_CLASS (iface)->get_rows_ts (iface, _return, tableName, rows, timestamp, attributes, io, error);
}

gboolean hbase_handler_get_rows_with_columns_ts (HbaseIf * iface, GPtrArray ** _return, const Text tableName, const GPtrArray * rows, const GPtrArray * columns, const gint64 timestamp, const GHashTable * attributes, IOError ** io, GError ** error)
{
  g_return_val_if_fail (IS_HBASE_HANDLER (iface), FALSE);

  return HBASE_HANDLER_GET_CLASS (iface)->get_rows_with_columns_ts (iface, _return, tableName, rows, columns, timestamp, attributes, io, error);
}

gboolean hbase_handler_mutate_row (HbaseIf * iface, const Text tableName, const Text row, const GPtrArray * mutations, const GHashTable * attributes, IOError ** io, IllegalArgument ** ia, GError ** error)
{
  g_return_val_if_fail (IS_HBASE_HANDLER (iface), FALSE);

  return HBASE_HANDLER_GET_CLASS (iface)->mutate_row (iface, tableName, row, mutations, attributes, io, ia, error);
}

gboolean hbase_handler_mutate_row_ts (HbaseIf * iface, const Text tableName, const Text row, const GPtrArray * mutations, const gint64 timestamp, const GHashTable * attributes, IOError ** io, IllegalArgument ** ia, GError ** error)
{
  g_return_val_if_fail (IS_HBASE_HANDLER (iface), FALSE);

  return HBASE_HANDLER_GET_CLASS (iface)->mutate_row_ts (iface, tableName, row, mutations, timestamp, attributes, io, ia, error);
}

gboolean hbase_handler_mutate_rows (HbaseIf * iface, const Text tableName, const GPtrArray * rowBatches, const GHashTable * attributes, IOError ** io, IllegalArgument ** ia, GError ** error)
{
  g_return_val_if_fail (IS_HBASE_HANDLER (iface), FALSE);

  return HBASE_HANDLER_GET_CLASS (iface)->mutate_rows (iface, tableName, rowBatches, attributes, io, ia, error);
}

gboolean hbase_handler_mutate_rows_ts (HbaseIf * iface, const Text tableName, const GPtrArray * rowBatches, const gint64 timestamp, const GHashTable * attributes, IOError ** io, IllegalArgument ** ia, GError ** error)
{
  g_return_val_if_fail (IS_HBASE_HANDLER (iface), FALSE);

  return HBASE_HANDLER_GET_CLASS (iface)->mutate_rows_ts (iface, tableName, rowBatches, timestamp, attributes, io, ia, error);
}

gboolean hbase_handler_atomic_increment (HbaseIf * iface, gint64* _return, const Text tableName, const Text row, const Text column, const gint64 value, IOError ** io, IllegalArgument ** ia, GError ** error)
{
  g_return_val_if_fail (IS_HBASE_HANDLER (iface), FALSE);

  return HBASE_HANDLER_GET_CLASS (iface)->atomic_increment (iface, _return, tableName, row, column, value, io, ia, error);
}

gboolean hbase_handler_delete_all (HbaseIf * iface, const Text tableName, const Text row, const Text column, const GHashTable * attributes, IOError ** io, GError ** error)
{
  g_return_val_if_fail (IS_HBASE_HANDLER (iface), FALSE);

  return HBASE_HANDLER_GET_CLASS (iface)->delete_all (iface, tableName, row, column, attributes, io, error);
}

gboolean hbase_handler_delete_all_ts (HbaseIf * iface, const Text tableName, const Text row, const Text column, const gint64 timestamp, const GHashTable * attributes, IOError ** io, GError ** error)
{
  g_return_val_if_fail (IS_HBASE_HANDLER (iface), FALSE);

  return HBASE_HANDLER_GET_CLASS (iface)->delete_all_ts (iface, tableName, row, column, timestamp, attributes, io, error);
}

gboolean hbase_handler_delete_all_row (HbaseIf * iface, const Text tableName, const Text row, const GHashTable * attributes, IOError ** io, GError ** error)
{
  g_return_val_if_fail (IS_HBASE_HANDLER (iface), FALSE);

  return HBASE_HANDLER_GET_CLASS (iface)->delete_all_row (iface, tableName, row, attributes, io, error);
}

gboolean hbase_handler_increment (HbaseIf * iface, const TIncrement * increment, IOError ** io, GError ** error)
{
  g_return_val_if_fail (IS_HBASE_HANDLER (iface), FALSE);

  return HBASE_HANDLER_GET_CLASS (iface)->increment (iface, increment, io, error);
}

gboolean hbase_handler_increment_rows (HbaseIf * iface, const GPtrArray * increments, IOError ** io, GError ** error)
{
  g_return_val_if_fail (IS_HBASE_HANDLER (iface), FALSE);

  return HBASE_HANDLER_GET_CLASS (iface)->increment_rows (iface, increments, io, error);
}

gboolean hbase_handler_delete_all_row_ts (HbaseIf * iface, const Text tableName, const Text row, const gint64 timestamp, const GHashTable * attributes, IOError ** io, GError ** error)
{
  g_return_val_if_fail (IS_HBASE_HANDLER (iface), FALSE);

  return HBASE_HANDLER_GET_CLASS (iface)->delete_all_row_ts (iface, tableName, row, timestamp, attributes, io, error);
}

gboolean hbase_handler_scanner_open_with_scan (HbaseIf * iface, ScannerID* _return, const Text tableName, const TScan * scan, const GHashTable * attributes, IOError ** io, GError ** error)
{
  g_return_val_if_fail (IS_HBASE_HANDLER (iface), FALSE);

  return HBASE_HANDLER_GET_CLASS (iface)->scanner_open_with_scan (iface, _return, tableName, scan, attributes, io, error);
}

gboolean hbase_handler_scanner_open (HbaseIf * iface, ScannerID* _return, const Text tableName, const Text startRow, const GPtrArray * columns, const GHashTable * attributes, IOError ** io, GError ** error)
{
  g_return_val_if_fail (IS_HBASE_HANDLER (iface), FALSE);

  return HBASE_HANDLER_GET_CLASS (iface)->scanner_open (iface, _return, tableName, startRow, columns, attributes, io, error);
}

gboolean hbase_handler_scanner_open_with_stop (HbaseIf * iface, ScannerID* _return, const Text tableName, const Text startRow, const Text stopRow, const GPtrArray * columns, const GHashTable * attributes, IOError ** io, GError ** error)
{
  g_return_val_if_fail (IS_HBASE_HANDLER (iface), FALSE);

  return HBASE_HANDLER_GET_CLASS (iface)->scanner_open_with_stop (iface, _return, tableName, startRow, stopRow, columns, attributes, io, error);
}

gboolean hbase_handler_scanner_open_with_prefix (HbaseIf * iface, ScannerID* _return, const Text tableName, const Text startAndPrefix, const GPtrArray * columns, const GHashTable * attributes, IOError ** io, GError ** error)
{
  g_return_val_if_fail (IS_HBASE_HANDLER (iface), FALSE);

  return HBASE_HANDLER_GET_CLASS (iface)->scanner_open_with_prefix (iface, _return, tableName, startAndPrefix, columns, attributes, io, error);
}

gboolean hbase_handler_scanner_open_ts (HbaseIf * iface, ScannerID* _return, const Text tableName, const Text startRow, const GPtrArray * columns, const gint64 timestamp, const GHashTable * attributes, IOError ** io, GError ** error)
{
  g_return_val_if_fail (IS_HBASE_HANDLER (iface), FALSE);

  return HBASE_HANDLER_GET_CLASS (iface)->scanner_open_ts (iface, _return, tableName, startRow, columns, timestamp, attributes, io, error);
}

gboolean hbase_handler_scanner_open_with_stop_ts (HbaseIf * iface, ScannerID* _return, const Text tableName, const Text startRow, const Text stopRow, const GPtrArray * columns, const gint64 timestamp, const GHashTable * attributes, IOError ** io, GError ** error)
{
  g_return_val_if_fail (IS_HBASE_HANDLER (iface), FALSE);

  return HBASE_HANDLER_GET_CLASS (iface)->scanner_open_with_stop_ts (iface, _return, tableName, startRow, stopRow, columns, timestamp, attributes, io, error);
}

gboolean hbase_handler_scanner_get (HbaseIf * iface, GPtrArray ** _return, const ScannerID id, IOError ** io, IllegalArgument ** ia, GError ** error)
{
  g_return_val_if_fail (IS_HBASE_HANDLER (iface), FALSE);

  return HBASE_HANDLER_GET_CLASS (iface)->scanner_get (iface, _return, id, io, ia, error);
}

gboolean hbase_handler_scanner_get_list (HbaseIf * iface, GPtrArray ** _return, const ScannerID id, const gint32 nbRows, IOError ** io, IllegalArgument ** ia, GError ** error)
{
  g_return_val_if_fail (IS_HBASE_HANDLER (iface), FALSE);

  return HBASE_HANDLER_GET_CLASS (iface)->scanner_get_list (iface, _return, id, nbRows, io, ia, error);
}

gboolean hbase_handler_scanner_close (HbaseIf * iface, const ScannerID id, IOError ** io, IllegalArgument ** ia, GError ** error)
{
  g_return_val_if_fail (IS_HBASE_HANDLER (iface), FALSE);

  return HBASE_HANDLER_GET_CLASS (iface)->scanner_close (iface, id, io, ia, error);
}

gboolean hbase_handler_get_row_or_before (HbaseIf * iface, GPtrArray ** _return, const Text tableName, const Text row, const Text family, IOError ** io, GError ** error)
{
  g_return_val_if_fail (IS_HBASE_HANDLER (iface), FALSE);

  return HBASE_HANDLER_GET_CLASS (iface)->get_row_or_before (iface, _return, tableName, row, family, io, error);
}

gboolean hbase_handler_get_region_info (HbaseIf * iface, TRegionInfo ** _return, const Text row, IOError ** io, GError ** error)
{
  g_return_val_if_fail (IS_HBASE_HANDLER (iface), FALSE);

  return HBASE_HANDLER_GET_CLASS (iface)->get_region_info (iface, _return, row, io, error);
}

gboolean hbase_handler_append (HbaseIf * iface, GPtrArray ** _return, const TAppend * append, IOError ** io, GError ** error)
{
  g_return_val_if_fail (IS_HBASE_HANDLER (iface), FALSE);

  return HBASE_HANDLER_GET_CLASS (iface)->append (iface, _return, append, io, error);
}

gboolean hbase_handler_check_and_put (HbaseIf * iface, gboolean* _return, const Text tableName, const Text row, const Text column, const Text value, const Mutation * mput, const GHashTable * attributes, IOError ** io, IllegalArgument ** ia, GError ** error)
{
  g_return_val_if_fail (IS_HBASE_HANDLER (iface), FALSE);

  return HBASE_HANDLER_GET_CLASS (iface)->check_and_put (iface, _return, tableName, row, column, value, mput, attributes, io, ia, error);
}

static void
hbase_handler_hbase_if_interface_init (HbaseIfInterface *iface)
{
  iface->enable_table = hbase_handler_enable_table;
  iface->disable_table = hbase_handler_disable_table;
  iface->is_table_enabled = hbase_handler_is_table_enabled;
  iface->compact = hbase_handler_compact;
  iface->major_compact = hbase_handler_major_compact;
  iface->get_table_names = hbase_handler_get_table_names;
  iface->get_column_descriptors = hbase_handler_get_column_descriptors;
  iface->get_table_regions = hbase_handler_get_table_regions;
  iface->create_table = hbase_handler_create_table;
  iface->delete_table = hbase_handler_delete_table;
  iface->get = hbase_handler_get;
  iface->get_ver = hbase_handler_get_ver;
  iface->get_ver_ts = hbase_handler_get_ver_ts;
  iface->get_row = hbase_handler_get_row;
  iface->get_row_with_columns = hbase_handler_get_row_with_columns;
  iface->get_row_ts = hbase_handler_get_row_ts;
  iface->get_row_with_columns_ts = hbase_handler_get_row_with_columns_ts;
  iface->get_rows = hbase_handler_get_rows;
  iface->get_rows_with_columns = hbase_handler_get_rows_with_columns;
  iface->get_rows_ts = hbase_handler_get_rows_ts;
  iface->get_rows_with_columns_ts = hbase_handler_get_rows_with_columns_ts;
  iface->mutate_row = hbase_handler_mutate_row;
  iface->mutate_row_ts = hbase_handler_mutate_row_ts;
  iface->mutate_rows = hbase_handler_mutate_rows;
  iface->mutate_rows_ts = hbase_handler_mutate_rows_ts;
  iface->atomic_increment = hbase_handler_atomic_increment;
  iface->delete_all = hbase_handler_delete_all;
  iface->delete_all_ts = hbase_handler_delete_all_ts;
  iface->delete_all_row = hbase_handler_delete_all_row;
  iface->increment = hbase_handler_increment;
  iface->increment_rows = hbase_handler_increment_rows;
  iface->delete_all_row_ts = hbase_handler_delete_all_row_ts;
  iface->scanner_open_with_scan = hbase_handler_scanner_open_with_scan;
  iface->scanner_open = hbase_handler_scanner_open;
  iface->scanner_open_with_stop = hbase_handler_scanner_open_with_stop;
  iface->scanner_open_with_prefix = hbase_handler_scanner_open_with_prefix;
  iface->scanner_open_ts = hbase_handler_scanner_open_ts;
  iface->scanner_open_with_stop_ts = hbase_handler_scanner_open_with_stop_ts;
  iface->scanner_get = hbase_handler_scanner_get;
  iface->scanner_get_list = hbase_handler_scanner_get_list;
  iface->scanner_close = hbase_handler_scanner_close;
  iface->get_row_or_before = hbase_handler_get_row_or_before;
  iface->get_region_info = hbase_handler_get_region_info;
  iface->append = hbase_handler_append;
  iface->check_and_put = hbase_handler_check_and_put;
}

static void
hbase_handler_init (HbaseHandler *self)
{
  THRIFT_UNUSED_VAR (self);
}

static void
hbase_handler_class_init (HbaseHandlerClass *cls)
{
  cls->enable_table = NULL;
  cls->disable_table = NULL;
  cls->is_table_enabled = NULL;
  cls->compact = NULL;
  cls->major_compact = NULL;
  cls->get_table_names = NULL;
  cls->get_column_descriptors = NULL;
  cls->get_table_regions = NULL;
  cls->create_table = NULL;
  cls->delete_table = NULL;
  cls->get = NULL;
  cls->get_ver = NULL;
  cls->get_ver_ts = NULL;
  cls->get_row = NULL;
  cls->get_row_with_columns = NULL;
  cls->get_row_ts = NULL;
  cls->get_row_with_columns_ts = NULL;
  cls->get_rows = NULL;
  cls->get_rows_with_columns = NULL;
  cls->get_rows_ts = NULL;
  cls->get_rows_with_columns_ts = NULL;
  cls->mutate_row = NULL;
  cls->mutate_row_ts = NULL;
  cls->mutate_rows = NULL;
  cls->mutate_rows_ts = NULL;
  cls->atomic_increment = NULL;
  cls->delete_all = NULL;
  cls->delete_all_ts = NULL;
  cls->delete_all_row = NULL;
  cls->increment = NULL;
  cls->increment_rows = NULL;
  cls->delete_all_row_ts = NULL;
  cls->scanner_open_with_scan = NULL;
  cls->scanner_open = NULL;
  cls->scanner_open_with_stop = NULL;
  cls->scanner_open_with_prefix = NULL;
  cls->scanner_open_ts = NULL;
  cls->scanner_open_with_stop_ts = NULL;
  cls->scanner_get = NULL;
  cls->scanner_get_list = NULL;
  cls->scanner_close = NULL;
  cls->get_row_or_before = NULL;
  cls->get_region_info = NULL;
  cls->append = NULL;
  cls->check_and_put = NULL;
}

enum _HbaseProcessorProperties
{
  PROP_HBASE_PROCESSOR_0,
  PROP_HBASE_PROCESSOR_HANDLER
};

G_DEFINE_TYPE (HbaseProcessor,
               hbase_processor,
               THRIFT_TYPE_DISPATCH_PROCESSOR)

typedef gboolean (* HbaseProcessorProcessFunction) (HbaseProcessor *, 
                                                    gint32,
                                                    ThriftProtocol *,
                                                    ThriftProtocol *,
                                                    GError **);

typedef struct
{
  gchar *name;
  HbaseProcessorProcessFunction function;
} hbase_processor_process_function_def;

static gboolean
hbase_processor_process_enable_table (HbaseProcessor *,
                                      gint32,
                                      ThriftProtocol *,
                                      ThriftProtocol *,
                                      GError **);
static gboolean
hbase_processor_process_disable_table (HbaseProcessor *,
                                       gint32,
                                       ThriftProtocol *,
                                       ThriftProtocol *,
                                       GError **);
static gboolean
hbase_processor_process_is_table_enabled (HbaseProcessor *,
                                          gint32,
                                          ThriftProtocol *,
                                          ThriftProtocol *,
                                          GError **);
static gboolean
hbase_processor_process_compact (HbaseProcessor *,
                                 gint32,
                                 ThriftProtocol *,
                                 ThriftProtocol *,
                                 GError **);
static gboolean
hbase_processor_process_major_compact (HbaseProcessor *,
                                       gint32,
                                       ThriftProtocol *,
                                       ThriftProtocol *,
                                       GError **);
static gboolean
hbase_processor_process_get_table_names (HbaseProcessor *,
                                         gint32,
                                         ThriftProtocol *,
                                         ThriftProtocol *,
                                         GError **);
static gboolean
hbase_processor_process_get_column_descriptors (HbaseProcessor *,
                                                gint32,
                                                ThriftProtocol *,
                                                ThriftProtocol *,
                                                GError **);
static gboolean
hbase_processor_process_get_table_regions (HbaseProcessor *,
                                           gint32,
                                           ThriftProtocol *,
                                           ThriftProtocol *,
                                           GError **);
static gboolean
hbase_processor_process_create_table (HbaseProcessor *,
                                      gint32,
                                      ThriftProtocol *,
                                      ThriftProtocol *,
                                      GError **);
static gboolean
hbase_processor_process_delete_table (HbaseProcessor *,
                                      gint32,
                                      ThriftProtocol *,
                                      ThriftProtocol *,
                                      GError **);
static gboolean
hbase_processor_process_get (HbaseProcessor *,
                             gint32,
                             ThriftProtocol *,
                             ThriftProtocol *,
                             GError **);
static gboolean
hbase_processor_process_get_ver (HbaseProcessor *,
                                 gint32,
                                 ThriftProtocol *,
                                 ThriftProtocol *,
                                 GError **);
static gboolean
hbase_processor_process_get_ver_ts (HbaseProcessor *,
                                    gint32,
                                    ThriftProtocol *,
                                    ThriftProtocol *,
                                    GError **);
static gboolean
hbase_processor_process_get_row (HbaseProcessor *,
                                 gint32,
                                 ThriftProtocol *,
                                 ThriftProtocol *,
                                 GError **);
static gboolean
hbase_processor_process_get_row_with_columns (HbaseProcessor *,
                                              gint32,
                                              ThriftProtocol *,
                                              ThriftProtocol *,
                                              GError **);
static gboolean
hbase_processor_process_get_row_ts (HbaseProcessor *,
                                    gint32,
                                    ThriftProtocol *,
                                    ThriftProtocol *,
                                    GError **);
static gboolean
hbase_processor_process_get_row_with_columns_ts (HbaseProcessor *,
                                                 gint32,
                                                 ThriftProtocol *,
                                                 ThriftProtocol *,
                                                 GError **);
static gboolean
hbase_processor_process_get_rows (HbaseProcessor *,
                                  gint32,
                                  ThriftProtocol *,
                                  ThriftProtocol *,
                                  GError **);
static gboolean
hbase_processor_process_get_rows_with_columns (HbaseProcessor *,
                                               gint32,
                                               ThriftProtocol *,
                                               ThriftProtocol *,
                                               GError **);
static gboolean
hbase_processor_process_get_rows_ts (HbaseProcessor *,
                                     gint32,
                                     ThriftProtocol *,
                                     ThriftProtocol *,
                                     GError **);
static gboolean
hbase_processor_process_get_rows_with_columns_ts (HbaseProcessor *,
                                                  gint32,
                                                  ThriftProtocol *,
                                                  ThriftProtocol *,
                                                  GError **);
static gboolean
hbase_processor_process_mutate_row (HbaseProcessor *,
                                    gint32,
                                    ThriftProtocol *,
                                    ThriftProtocol *,
                                    GError **);
static gboolean
hbase_processor_process_mutate_row_ts (HbaseProcessor *,
                                       gint32,
                                       ThriftProtocol *,
                                       ThriftProtocol *,
                                       GError **);
static gboolean
hbase_processor_process_mutate_rows (HbaseProcessor *,
                                     gint32,
                                     ThriftProtocol *,
                                     ThriftProtocol *,
                                     GError **);
static gboolean
hbase_processor_process_mutate_rows_ts (HbaseProcessor *,
                                        gint32,
                                        ThriftProtocol *,
                                        ThriftProtocol *,
                                        GError **);
static gboolean
hbase_processor_process_atomic_increment (HbaseProcessor *,
                                          gint32,
                                          ThriftProtocol *,
                                          ThriftProtocol *,
                                          GError **);
static gboolean
hbase_processor_process_delete_all (HbaseProcessor *,
                                    gint32,
                                    ThriftProtocol *,
                                    ThriftProtocol *,
                                    GError **);
static gboolean
hbase_processor_process_delete_all_ts (HbaseProcessor *,
                                       gint32,
                                       ThriftProtocol *,
                                       ThriftProtocol *,
                                       GError **);
static gboolean
hbase_processor_process_delete_all_row (HbaseProcessor *,
                                        gint32,
                                        ThriftProtocol *,
                                        ThriftProtocol *,
                                        GError **);
static gboolean
hbase_processor_process_increment (HbaseProcessor *,
                                   gint32,
                                   ThriftProtocol *,
                                   ThriftProtocol *,
                                   GError **);
static gboolean
hbase_processor_process_increment_rows (HbaseProcessor *,
                                        gint32,
                                        ThriftProtocol *,
                                        ThriftProtocol *,
                                        GError **);
static gboolean
hbase_processor_process_delete_all_row_ts (HbaseProcessor *,
                                           gint32,
                                           ThriftProtocol *,
                                           ThriftProtocol *,
                                           GError **);
static gboolean
hbase_processor_process_scanner_open_with_scan (HbaseProcessor *,
                                                gint32,
                                                ThriftProtocol *,
                                                ThriftProtocol *,
                                                GError **);
static gboolean
hbase_processor_process_scanner_open (HbaseProcessor *,
                                      gint32,
                                      ThriftProtocol *,
                                      ThriftProtocol *,
                                      GError **);
static gboolean
hbase_processor_process_scanner_open_with_stop (HbaseProcessor *,
                                                gint32,
                                                ThriftProtocol *,
                                                ThriftProtocol *,
                                                GError **);
static gboolean
hbase_processor_process_scanner_open_with_prefix (HbaseProcessor *,
                                                  gint32,
                                                  ThriftProtocol *,
                                                  ThriftProtocol *,
                                                  GError **);
static gboolean
hbase_processor_process_scanner_open_ts (HbaseProcessor *,
                                         gint32,
                                         ThriftProtocol *,
                                         ThriftProtocol *,
                                         GError **);
static gboolean
hbase_processor_process_scanner_open_with_stop_ts (HbaseProcessor *,
                                                   gint32,
                                                   ThriftProtocol *,
                                                   ThriftProtocol *,
                                                   GError **);
static gboolean
hbase_processor_process_scanner_get (HbaseProcessor *,
                                     gint32,
                                     ThriftProtocol *,
                                     ThriftProtocol *,
                                     GError **);
static gboolean
hbase_processor_process_scanner_get_list (HbaseProcessor *,
                                          gint32,
                                          ThriftProtocol *,
                                          ThriftProtocol *,
                                          GError **);
static gboolean
hbase_processor_process_scanner_close (HbaseProcessor *,
                                       gint32,
                                       ThriftProtocol *,
                                       ThriftProtocol *,
                                       GError **);
static gboolean
hbase_processor_process_get_row_or_before (HbaseProcessor *,
                                           gint32,
                                           ThriftProtocol *,
                                           ThriftProtocol *,
                                           GError **);
static gboolean
hbase_processor_process_get_region_info (HbaseProcessor *,
                                         gint32,
                                         ThriftProtocol *,
                                         ThriftProtocol *,
                                         GError **);
static gboolean
hbase_processor_process_append (HbaseProcessor *,
                                gint32,
                                ThriftProtocol *,
                                ThriftProtocol *,
                                GError **);
static gboolean
hbase_processor_process_check_and_put (HbaseProcessor *,
                                       gint32,
                                       ThriftProtocol *,
                                       ThriftProtocol *,
                                       GError **);

static hbase_processor_process_function_def
hbase_processor_process_function_defs[45] = {
  {
    "enableTable",
    hbase_processor_process_enable_table
  },
  {
    "disableTable",
    hbase_processor_process_disable_table
  },
  {
    "isTableEnabled",
    hbase_processor_process_is_table_enabled
  },
  {
    "compact",
    hbase_processor_process_compact
  },
  {
    "majorCompact",
    hbase_processor_process_major_compact
  },
  {
    "getTableNames",
    hbase_processor_process_get_table_names
  },
  {
    "getColumnDescriptors",
    hbase_processor_process_get_column_descriptors
  },
  {
    "getTableRegions",
    hbase_processor_process_get_table_regions
  },
  {
    "createTable",
    hbase_processor_process_create_table
  },
  {
    "deleteTable",
    hbase_processor_process_delete_table
  },
  {
    "get",
    hbase_processor_process_get
  },
  {
    "getVer",
    hbase_processor_process_get_ver
  },
  {
    "getVerTs",
    hbase_processor_process_get_ver_ts
  },
  {
    "getRow",
    hbase_processor_process_get_row
  },
  {
    "getRowWithColumns",
    hbase_processor_process_get_row_with_columns
  },
  {
    "getRowTs",
    hbase_processor_process_get_row_ts
  },
  {
    "getRowWithColumnsTs",
    hbase_processor_process_get_row_with_columns_ts
  },
  {
    "getRows",
    hbase_processor_process_get_rows
  },
  {
    "getRowsWithColumns",
    hbase_processor_process_get_rows_with_columns
  },
  {
    "getRowsTs",
    hbase_processor_process_get_rows_ts
  },
  {
    "getRowsWithColumnsTs",
    hbase_processor_process_get_rows_with_columns_ts
  },
  {
    "mutateRow",
    hbase_processor_process_mutate_row
  },
  {
    "mutateRowTs",
    hbase_processor_process_mutate_row_ts
  },
  {
    "mutateRows",
    hbase_processor_process_mutate_rows
  },
  {
    "mutateRowsTs",
    hbase_processor_process_mutate_rows_ts
  },
  {
    "atomicIncrement",
    hbase_processor_process_atomic_increment
  },
  {
    "deleteAll",
    hbase_processor_process_delete_all
  },
  {
    "deleteAllTs",
    hbase_processor_process_delete_all_ts
  },
  {
    "deleteAllRow",
    hbase_processor_process_delete_all_row
  },
  {
    "increment",
    hbase_processor_process_increment
  },
  {
    "incrementRows",
    hbase_processor_process_increment_rows
  },
  {
    "deleteAllRowTs",
    hbase_processor_process_delete_all_row_ts
  },
  {
    "scannerOpenWithScan",
    hbase_processor_process_scanner_open_with_scan
  },
  {
    "scannerOpen",
    hbase_processor_process_scanner_open
  },
  {
    "scannerOpenWithStop",
    hbase_processor_process_scanner_open_with_stop
  },
  {
    "scannerOpenWithPrefix",
    hbase_processor_process_scanner_open_with_prefix
  },
  {
    "scannerOpenTs",
    hbase_processor_process_scanner_open_ts
  },
  {
    "scannerOpenWithStopTs",
    hbase_processor_process_scanner_open_with_stop_ts
  },
  {
    "scannerGet",
    hbase_processor_process_scanner_get
  },
  {
    "scannerGetList",
    hbase_processor_process_scanner_get_list
  },
  {
    "scannerClose",
    hbase_processor_process_scanner_close
  },
  {
    "getRowOrBefore",
    hbase_processor_process_get_row_or_before
  },
  {
    "getRegionInfo",
    hbase_processor_process_get_region_info
  },
  {
    "append",
    hbase_processor_process_append
  },
  {
    "checkAndPut",
    hbase_processor_process_check_and_put
  }
};

static gboolean
hbase_processor_process_enable_table (HbaseProcessor *self,
                                      gint32 sequence_id,
                                      ThriftProtocol *input_protocol,
                                      ThriftProtocol *output_protocol,
                                      GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  HbaseEnableTableArgs * args =
    g_object_new (TYPE_HBASE_ENABLE_TABLE_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    Bytes tableName;
    IOError * io = NULL;
    HbaseEnableTableResult * result_struct;

    g_object_get (args,
                  "tableName", &tableName,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_HBASE_ENABLE_TABLE_RESULT, NULL);

    if (hbase_handler_enable_table (HBASE_IF (self->handler),
                                    tableName,
                                    &io,
                                    error) == TRUE)
    {
      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "enableTable",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (io != NULL)
      {
        g_object_set (result_struct,
                      "io", io,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "enableTable",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("Hbase.enableTable implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "enableTable",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (tableName != NULL)
      g_byte_array_unref (tableName);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
hbase_processor_process_disable_table (HbaseProcessor *self,
                                       gint32 sequence_id,
                                       ThriftProtocol *input_protocol,
                                       ThriftProtocol *output_protocol,
                                       GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  HbaseDisableTableArgs * args =
    g_object_new (TYPE_HBASE_DISABLE_TABLE_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    Bytes tableName;
    IOError * io = NULL;
    HbaseDisableTableResult * result_struct;

    g_object_get (args,
                  "tableName", &tableName,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_HBASE_DISABLE_TABLE_RESULT, NULL);

    if (hbase_handler_disable_table (HBASE_IF (self->handler),
                                     tableName,
                                     &io,
                                     error) == TRUE)
    {
      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "disableTable",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (io != NULL)
      {
        g_object_set (result_struct,
                      "io", io,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "disableTable",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("Hbase.disableTable implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "disableTable",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (tableName != NULL)
      g_byte_array_unref (tableName);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
hbase_processor_process_is_table_enabled (HbaseProcessor *self,
                                          gint32 sequence_id,
                                          ThriftProtocol *input_protocol,
                                          ThriftProtocol *output_protocol,
                                          GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  HbaseIsTableEnabledArgs * args =
    g_object_new (TYPE_HBASE_IS_TABLE_ENABLED_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    Bytes tableName;
    IOError * io = NULL;
    gboolean return_value;
    HbaseIsTableEnabledResult * result_struct;

    g_object_get (args,
                  "tableName", &tableName,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_HBASE_IS_TABLE_ENABLED_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (hbase_handler_is_table_enabled (HBASE_IF (self->handler),
                                        &return_value,
                                        tableName,
                                        &io,
                                        error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "isTableEnabled",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (io != NULL)
      {
        g_object_set (result_struct,
                      "io", io,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "isTableEnabled",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("Hbase.isTableEnabled implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "isTableEnabled",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (tableName != NULL)
      g_byte_array_unref (tableName);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
hbase_processor_process_compact (HbaseProcessor *self,
                                 gint32 sequence_id,
                                 ThriftProtocol *input_protocol,
                                 ThriftProtocol *output_protocol,
                                 GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  HbaseCompactArgs * args =
    g_object_new (TYPE_HBASE_COMPACT_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    Bytes tableNameOrRegionName;
    IOError * io = NULL;
    HbaseCompactResult * result_struct;

    g_object_get (args,
                  "tableNameOrRegionName", &tableNameOrRegionName,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_HBASE_COMPACT_RESULT, NULL);

    if (hbase_handler_compact (HBASE_IF (self->handler),
                               tableNameOrRegionName,
                               &io,
                               error) == TRUE)
    {
      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "compact",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (io != NULL)
      {
        g_object_set (result_struct,
                      "io", io,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "compact",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("Hbase.compact implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "compact",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (tableNameOrRegionName != NULL)
      g_byte_array_unref (tableNameOrRegionName);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
hbase_processor_process_major_compact (HbaseProcessor *self,
                                       gint32 sequence_id,
                                       ThriftProtocol *input_protocol,
                                       ThriftProtocol *output_protocol,
                                       GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  HbaseMajorCompactArgs * args =
    g_object_new (TYPE_HBASE_MAJOR_COMPACT_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    Bytes tableNameOrRegionName;
    IOError * io = NULL;
    HbaseMajorCompactResult * result_struct;

    g_object_get (args,
                  "tableNameOrRegionName", &tableNameOrRegionName,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_HBASE_MAJOR_COMPACT_RESULT, NULL);

    if (hbase_handler_major_compact (HBASE_IF (self->handler),
                                     tableNameOrRegionName,
                                     &io,
                                     error) == TRUE)
    {
      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "majorCompact",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (io != NULL)
      {
        g_object_set (result_struct,
                      "io", io,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "majorCompact",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("Hbase.majorCompact implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "majorCompact",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (tableNameOrRegionName != NULL)
      g_byte_array_unref (tableNameOrRegionName);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
hbase_processor_process_get_table_names (HbaseProcessor *self,
                                         gint32 sequence_id,
                                         ThriftProtocol *input_protocol,
                                         ThriftProtocol *output_protocol,
                                         GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  HbaseGetTableNamesArgs * args =
    g_object_new (TYPE_HBASE_GET_TABLE_NAMES_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    IOError * io = NULL;
    GPtrArray * return_value;
    HbaseGetTableNamesResult * result_struct;

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_HBASE_GET_TABLE_NAMES_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (hbase_handler_get_table_names (HBASE_IF (self->handler),
                                       &return_value,
                                       &io,
                                       error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_ptr_array_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getTableNames",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (io != NULL)
      {
        g_object_set (result_struct,
                      "io", io,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getTableNames",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("Hbase.getTableNames implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getTableNames",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
hbase_processor_process_get_column_descriptors (HbaseProcessor *self,
                                                gint32 sequence_id,
                                                ThriftProtocol *input_protocol,
                                                ThriftProtocol *output_protocol,
                                                GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  HbaseGetColumnDescriptorsArgs * args =
    g_object_new (TYPE_HBASE_GET_COLUMN_DESCRIPTORS_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    Text tableName;
    IOError * io = NULL;
    GHashTable * return_value;
    HbaseGetColumnDescriptorsResult * result_struct;

    g_object_get (args,
                  "tableName", &tableName,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_HBASE_GET_COLUMN_DESCRIPTORS_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (hbase_handler_get_column_descriptors (HBASE_IF (self->handler),
                                              &return_value,
                                              tableName,
                                              &io,
                                              error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_hash_table_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getColumnDescriptors",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (io != NULL)
      {
        g_object_set (result_struct,
                      "io", io,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getColumnDescriptors",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("Hbase.getColumnDescriptors implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getColumnDescriptors",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (tableName != NULL)
      g_byte_array_unref (tableName);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
hbase_processor_process_get_table_regions (HbaseProcessor *self,
                                           gint32 sequence_id,
                                           ThriftProtocol *input_protocol,
                                           ThriftProtocol *output_protocol,
                                           GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  HbaseGetTableRegionsArgs * args =
    g_object_new (TYPE_HBASE_GET_TABLE_REGIONS_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    Text tableName;
    IOError * io = NULL;
    GPtrArray * return_value;
    HbaseGetTableRegionsResult * result_struct;

    g_object_get (args,
                  "tableName", &tableName,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_HBASE_GET_TABLE_REGIONS_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (hbase_handler_get_table_regions (HBASE_IF (self->handler),
                                         &return_value,
                                         tableName,
                                         &io,
                                         error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_ptr_array_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getTableRegions",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (io != NULL)
      {
        g_object_set (result_struct,
                      "io", io,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getTableRegions",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("Hbase.getTableRegions implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getTableRegions",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (tableName != NULL)
      g_byte_array_unref (tableName);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
hbase_processor_process_create_table (HbaseProcessor *self,
                                      gint32 sequence_id,
                                      ThriftProtocol *input_protocol,
                                      ThriftProtocol *output_protocol,
                                      GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  HbaseCreateTableArgs * args =
    g_object_new (TYPE_HBASE_CREATE_TABLE_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    Text tableName;
    GPtrArray * columnFamilies;
    IOError * io = NULL;
    IllegalArgument * ia = NULL;
    AlreadyExists * exist = NULL;
    HbaseCreateTableResult * result_struct;

    g_object_get (args,
                  "tableName", &tableName,
                  "columnFamilies", &columnFamilies,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_HBASE_CREATE_TABLE_RESULT, NULL);

    if (hbase_handler_create_table (HBASE_IF (self->handler),
                                    tableName,
                                    columnFamilies,
                                    &io,
                                    &ia,
                                    &exist,
                                    error) == TRUE)
    {
      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "createTable",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (io != NULL)
      {
        g_object_set (result_struct,
                      "io", io,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "createTable",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (ia != NULL)
      {
        g_object_set (result_struct,
                      "ia", ia,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "createTable",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (exist != NULL)
      {
        g_object_set (result_struct,
                      "exist", exist,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "createTable",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("Hbase.createTable implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "createTable",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (tableName != NULL)
      g_byte_array_unref (tableName);
    if (columnFamilies != NULL)
      g_ptr_array_unref (columnFamilies);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
hbase_processor_process_delete_table (HbaseProcessor *self,
                                      gint32 sequence_id,
                                      ThriftProtocol *input_protocol,
                                      ThriftProtocol *output_protocol,
                                      GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  HbaseDeleteTableArgs * args =
    g_object_new (TYPE_HBASE_DELETE_TABLE_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    Text tableName;
    IOError * io = NULL;
    HbaseDeleteTableResult * result_struct;

    g_object_get (args,
                  "tableName", &tableName,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_HBASE_DELETE_TABLE_RESULT, NULL);

    if (hbase_handler_delete_table (HBASE_IF (self->handler),
                                    tableName,
                                    &io,
                                    error) == TRUE)
    {
      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "deleteTable",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (io != NULL)
      {
        g_object_set (result_struct,
                      "io", io,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "deleteTable",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("Hbase.deleteTable implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "deleteTable",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (tableName != NULL)
      g_byte_array_unref (tableName);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
hbase_processor_process_get (HbaseProcessor *self,
                             gint32 sequence_id,
                             ThriftProtocol *input_protocol,
                             ThriftProtocol *output_protocol,
                             GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  HbaseGetArgs * args =
    g_object_new (TYPE_HBASE_GET_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    Text tableName;
    Text row;
    Text column;
    GHashTable * attributes;
    IOError * io = NULL;
    GPtrArray * return_value;
    HbaseGetResult * result_struct;

    g_object_get (args,
                  "tableName", &tableName,
                  "row", &row,
                  "column", &column,
                  "attributes", &attributes,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_HBASE_GET_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (hbase_handler_get (HBASE_IF (self->handler),
                           &return_value,
                           tableName,
                           row,
                           column,
                           attributes,
                           &io,
                           error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_ptr_array_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "get",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (io != NULL)
      {
        g_object_set (result_struct,
                      "io", io,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "get",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("Hbase.get implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "get",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (tableName != NULL)
      g_byte_array_unref (tableName);
    if (row != NULL)
      g_byte_array_unref (row);
    if (column != NULL)
      g_byte_array_unref (column);
    if (attributes != NULL)
      g_hash_table_unref (attributes);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
hbase_processor_process_get_ver (HbaseProcessor *self,
                                 gint32 sequence_id,
                                 ThriftProtocol *input_protocol,
                                 ThriftProtocol *output_protocol,
                                 GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  HbaseGetVerArgs * args =
    g_object_new (TYPE_HBASE_GET_VER_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    Text tableName;
    Text row;
    Text column;
    gint numVersions;
    GHashTable * attributes;
    IOError * io = NULL;
    GPtrArray * return_value;
    HbaseGetVerResult * result_struct;

    g_object_get (args,
                  "tableName", &tableName,
                  "row", &row,
                  "column", &column,
                  "numVersions", &numVersions,
                  "attributes", &attributes,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_HBASE_GET_VER_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (hbase_handler_get_ver (HBASE_IF (self->handler),
                               &return_value,
                               tableName,
                               row,
                               column,
                               numVersions,
                               attributes,
                               &io,
                               error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_ptr_array_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getVer",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (io != NULL)
      {
        g_object_set (result_struct,
                      "io", io,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getVer",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("Hbase.getVer implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getVer",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (tableName != NULL)
      g_byte_array_unref (tableName);
    if (row != NULL)
      g_byte_array_unref (row);
    if (column != NULL)
      g_byte_array_unref (column);
    if (attributes != NULL)
      g_hash_table_unref (attributes);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
hbase_processor_process_get_ver_ts (HbaseProcessor *self,
                                    gint32 sequence_id,
                                    ThriftProtocol *input_protocol,
                                    ThriftProtocol *output_protocol,
                                    GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  HbaseGetVerTsArgs * args =
    g_object_new (TYPE_HBASE_GET_VER_TS_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    Text tableName;
    Text row;
    Text column;
    gint64 timestamp;
    gint numVersions;
    GHashTable * attributes;
    IOError * io = NULL;
    GPtrArray * return_value;
    HbaseGetVerTsResult * result_struct;

    g_object_get (args,
                  "tableName", &tableName,
                  "row", &row,
                  "column", &column,
                  "timestamp", &timestamp,
                  "numVersions", &numVersions,
                  "attributes", &attributes,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_HBASE_GET_VER_TS_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (hbase_handler_get_ver_ts (HBASE_IF (self->handler),
                                  &return_value,
                                  tableName,
                                  row,
                                  column,
                                  timestamp,
                                  numVersions,
                                  attributes,
                                  &io,
                                  error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_ptr_array_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getVerTs",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (io != NULL)
      {
        g_object_set (result_struct,
                      "io", io,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getVerTs",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("Hbase.getVerTs implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getVerTs",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (tableName != NULL)
      g_byte_array_unref (tableName);
    if (row != NULL)
      g_byte_array_unref (row);
    if (column != NULL)
      g_byte_array_unref (column);
    if (attributes != NULL)
      g_hash_table_unref (attributes);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
hbase_processor_process_get_row (HbaseProcessor *self,
                                 gint32 sequence_id,
                                 ThriftProtocol *input_protocol,
                                 ThriftProtocol *output_protocol,
                                 GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  HbaseGetRowArgs * args =
    g_object_new (TYPE_HBASE_GET_ROW_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    Text tableName;
    Text row;
    GHashTable * attributes;
    IOError * io = NULL;
    GPtrArray * return_value;
    HbaseGetRowResult * result_struct;

    g_object_get (args,
                  "tableName", &tableName,
                  "row", &row,
                  "attributes", &attributes,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_HBASE_GET_ROW_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (hbase_handler_get_row (HBASE_IF (self->handler),
                               &return_value,
                               tableName,
                               row,
                               attributes,
                               &io,
                               error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_ptr_array_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getRow",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (io != NULL)
      {
        g_object_set (result_struct,
                      "io", io,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getRow",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("Hbase.getRow implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getRow",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (tableName != NULL)
      g_byte_array_unref (tableName);
    if (row != NULL)
      g_byte_array_unref (row);
    if (attributes != NULL)
      g_hash_table_unref (attributes);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
hbase_processor_process_get_row_with_columns (HbaseProcessor *self,
                                              gint32 sequence_id,
                                              ThriftProtocol *input_protocol,
                                              ThriftProtocol *output_protocol,
                                              GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  HbaseGetRowWithColumnsArgs * args =
    g_object_new (TYPE_HBASE_GET_ROW_WITH_COLUMNS_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    Text tableName;
    Text row;
    GPtrArray * columns;
    GHashTable * attributes;
    IOError * io = NULL;
    GPtrArray * return_value;
    HbaseGetRowWithColumnsResult * result_struct;

    g_object_get (args,
                  "tableName", &tableName,
                  "row", &row,
                  "columns", &columns,
                  "attributes", &attributes,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_HBASE_GET_ROW_WITH_COLUMNS_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (hbase_handler_get_row_with_columns (HBASE_IF (self->handler),
                                            &return_value,
                                            tableName,
                                            row,
                                            columns,
                                            attributes,
                                            &io,
                                            error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_ptr_array_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getRowWithColumns",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (io != NULL)
      {
        g_object_set (result_struct,
                      "io", io,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getRowWithColumns",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("Hbase.getRowWithColumns implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getRowWithColumns",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (tableName != NULL)
      g_byte_array_unref (tableName);
    if (row != NULL)
      g_byte_array_unref (row);
    if (columns != NULL)
      g_ptr_array_unref (columns);
    if (attributes != NULL)
      g_hash_table_unref (attributes);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
hbase_processor_process_get_row_ts (HbaseProcessor *self,
                                    gint32 sequence_id,
                                    ThriftProtocol *input_protocol,
                                    ThriftProtocol *output_protocol,
                                    GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  HbaseGetRowTsArgs * args =
    g_object_new (TYPE_HBASE_GET_ROW_TS_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    Text tableName;
    Text row;
    gint64 timestamp;
    GHashTable * attributes;
    IOError * io = NULL;
    GPtrArray * return_value;
    HbaseGetRowTsResult * result_struct;

    g_object_get (args,
                  "tableName", &tableName,
                  "row", &row,
                  "timestamp", &timestamp,
                  "attributes", &attributes,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_HBASE_GET_ROW_TS_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (hbase_handler_get_row_ts (HBASE_IF (self->handler),
                                  &return_value,
                                  tableName,
                                  row,
                                  timestamp,
                                  attributes,
                                  &io,
                                  error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_ptr_array_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getRowTs",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (io != NULL)
      {
        g_object_set (result_struct,
                      "io", io,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getRowTs",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("Hbase.getRowTs implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getRowTs",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (tableName != NULL)
      g_byte_array_unref (tableName);
    if (row != NULL)
      g_byte_array_unref (row);
    if (attributes != NULL)
      g_hash_table_unref (attributes);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
hbase_processor_process_get_row_with_columns_ts (HbaseProcessor *self,
                                                 gint32 sequence_id,
                                                 ThriftProtocol *input_protocol,
                                                 ThriftProtocol *output_protocol,
                                                 GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  HbaseGetRowWithColumnsTsArgs * args =
    g_object_new (TYPE_HBASE_GET_ROW_WITH_COLUMNS_TS_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    Text tableName;
    Text row;
    GPtrArray * columns;
    gint64 timestamp;
    GHashTable * attributes;
    IOError * io = NULL;
    GPtrArray * return_value;
    HbaseGetRowWithColumnsTsResult * result_struct;

    g_object_get (args,
                  "tableName", &tableName,
                  "row", &row,
                  "columns", &columns,
                  "timestamp", &timestamp,
                  "attributes", &attributes,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_HBASE_GET_ROW_WITH_COLUMNS_TS_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (hbase_handler_get_row_with_columns_ts (HBASE_IF (self->handler),
                                               &return_value,
                                               tableName,
                                               row,
                                               columns,
                                               timestamp,
                                               attributes,
                                               &io,
                                               error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_ptr_array_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getRowWithColumnsTs",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (io != NULL)
      {
        g_object_set (result_struct,
                      "io", io,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getRowWithColumnsTs",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("Hbase.getRowWithColumnsTs implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getRowWithColumnsTs",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (tableName != NULL)
      g_byte_array_unref (tableName);
    if (row != NULL)
      g_byte_array_unref (row);
    if (columns != NULL)
      g_ptr_array_unref (columns);
    if (attributes != NULL)
      g_hash_table_unref (attributes);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
hbase_processor_process_get_rows (HbaseProcessor *self,
                                  gint32 sequence_id,
                                  ThriftProtocol *input_protocol,
                                  ThriftProtocol *output_protocol,
                                  GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  HbaseGetRowsArgs * args =
    g_object_new (TYPE_HBASE_GET_ROWS_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    Text tableName;
    GPtrArray * rows;
    GHashTable * attributes;
    IOError * io = NULL;
    GPtrArray * return_value;
    HbaseGetRowsResult * result_struct;

    g_object_get (args,
                  "tableName", &tableName,
                  "rows", &rows,
                  "attributes", &attributes,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_HBASE_GET_ROWS_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (hbase_handler_get_rows (HBASE_IF (self->handler),
                                &return_value,
                                tableName,
                                rows,
                                attributes,
                                &io,
                                error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_ptr_array_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getRows",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (io != NULL)
      {
        g_object_set (result_struct,
                      "io", io,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getRows",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("Hbase.getRows implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getRows",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (tableName != NULL)
      g_byte_array_unref (tableName);
    if (rows != NULL)
      g_ptr_array_unref (rows);
    if (attributes != NULL)
      g_hash_table_unref (attributes);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
hbase_processor_process_get_rows_with_columns (HbaseProcessor *self,
                                               gint32 sequence_id,
                                               ThriftProtocol *input_protocol,
                                               ThriftProtocol *output_protocol,
                                               GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  HbaseGetRowsWithColumnsArgs * args =
    g_object_new (TYPE_HBASE_GET_ROWS_WITH_COLUMNS_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    Text tableName;
    GPtrArray * rows;
    GPtrArray * columns;
    GHashTable * attributes;
    IOError * io = NULL;
    GPtrArray * return_value;
    HbaseGetRowsWithColumnsResult * result_struct;

    g_object_get (args,
                  "tableName", &tableName,
                  "rows", &rows,
                  "columns", &columns,
                  "attributes", &attributes,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_HBASE_GET_ROWS_WITH_COLUMNS_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (hbase_handler_get_rows_with_columns (HBASE_IF (self->handler),
                                             &return_value,
                                             tableName,
                                             rows,
                                             columns,
                                             attributes,
                                             &io,
                                             error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_ptr_array_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getRowsWithColumns",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (io != NULL)
      {
        g_object_set (result_struct,
                      "io", io,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getRowsWithColumns",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("Hbase.getRowsWithColumns implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getRowsWithColumns",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (tableName != NULL)
      g_byte_array_unref (tableName);
    if (rows != NULL)
      g_ptr_array_unref (rows);
    if (columns != NULL)
      g_ptr_array_unref (columns);
    if (attributes != NULL)
      g_hash_table_unref (attributes);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
hbase_processor_process_get_rows_ts (HbaseProcessor *self,
                                     gint32 sequence_id,
                                     ThriftProtocol *input_protocol,
                                     ThriftProtocol *output_protocol,
                                     GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  HbaseGetRowsTsArgs * args =
    g_object_new (TYPE_HBASE_GET_ROWS_TS_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    Text tableName;
    GPtrArray * rows;
    gint64 timestamp;
    GHashTable * attributes;
    IOError * io = NULL;
    GPtrArray * return_value;
    HbaseGetRowsTsResult * result_struct;

    g_object_get (args,
                  "tableName", &tableName,
                  "rows", &rows,
                  "timestamp", &timestamp,
                  "attributes", &attributes,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_HBASE_GET_ROWS_TS_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (hbase_handler_get_rows_ts (HBASE_IF (self->handler),
                                   &return_value,
                                   tableName,
                                   rows,
                                   timestamp,
                                   attributes,
                                   &io,
                                   error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_ptr_array_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getRowsTs",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (io != NULL)
      {
        g_object_set (result_struct,
                      "io", io,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getRowsTs",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("Hbase.getRowsTs implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getRowsTs",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (tableName != NULL)
      g_byte_array_unref (tableName);
    if (rows != NULL)
      g_ptr_array_unref (rows);
    if (attributes != NULL)
      g_hash_table_unref (attributes);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
hbase_processor_process_get_rows_with_columns_ts (HbaseProcessor *self,
                                                  gint32 sequence_id,
                                                  ThriftProtocol *input_protocol,
                                                  ThriftProtocol *output_protocol,
                                                  GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  HbaseGetRowsWithColumnsTsArgs * args =
    g_object_new (TYPE_HBASE_GET_ROWS_WITH_COLUMNS_TS_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    Text tableName;
    GPtrArray * rows;
    GPtrArray * columns;
    gint64 timestamp;
    GHashTable * attributes;
    IOError * io = NULL;
    GPtrArray * return_value;
    HbaseGetRowsWithColumnsTsResult * result_struct;

    g_object_get (args,
                  "tableName", &tableName,
                  "rows", &rows,
                  "columns", &columns,
                  "timestamp", &timestamp,
                  "attributes", &attributes,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_HBASE_GET_ROWS_WITH_COLUMNS_TS_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (hbase_handler_get_rows_with_columns_ts (HBASE_IF (self->handler),
                                                &return_value,
                                                tableName,
                                                rows,
                                                columns,
                                                timestamp,
                                                attributes,
                                                &io,
                                                error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_ptr_array_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getRowsWithColumnsTs",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (io != NULL)
      {
        g_object_set (result_struct,
                      "io", io,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getRowsWithColumnsTs",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("Hbase.getRowsWithColumnsTs implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getRowsWithColumnsTs",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (tableName != NULL)
      g_byte_array_unref (tableName);
    if (rows != NULL)
      g_ptr_array_unref (rows);
    if (columns != NULL)
      g_ptr_array_unref (columns);
    if (attributes != NULL)
      g_hash_table_unref (attributes);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
hbase_processor_process_mutate_row (HbaseProcessor *self,
                                    gint32 sequence_id,
                                    ThriftProtocol *input_protocol,
                                    ThriftProtocol *output_protocol,
                                    GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  HbaseMutateRowArgs * args =
    g_object_new (TYPE_HBASE_MUTATE_ROW_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    Text tableName;
    Text row;
    GPtrArray * mutations;
    GHashTable * attributes;
    IOError * io = NULL;
    IllegalArgument * ia = NULL;
    HbaseMutateRowResult * result_struct;

    g_object_get (args,
                  "tableName", &tableName,
                  "row", &row,
                  "mutations", &mutations,
                  "attributes", &attributes,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_HBASE_MUTATE_ROW_RESULT, NULL);

    if (hbase_handler_mutate_row (HBASE_IF (self->handler),
                                  tableName,
                                  row,
                                  mutations,
                                  attributes,
                                  &io,
                                  &ia,
                                  error) == TRUE)
    {
      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "mutateRow",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (io != NULL)
      {
        g_object_set (result_struct,
                      "io", io,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "mutateRow",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (ia != NULL)
      {
        g_object_set (result_struct,
                      "ia", ia,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "mutateRow",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("Hbase.mutateRow implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "mutateRow",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (tableName != NULL)
      g_byte_array_unref (tableName);
    if (row != NULL)
      g_byte_array_unref (row);
    if (mutations != NULL)
      g_ptr_array_unref (mutations);
    if (attributes != NULL)
      g_hash_table_unref (attributes);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
hbase_processor_process_mutate_row_ts (HbaseProcessor *self,
                                       gint32 sequence_id,
                                       ThriftProtocol *input_protocol,
                                       ThriftProtocol *output_protocol,
                                       GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  HbaseMutateRowTsArgs * args =
    g_object_new (TYPE_HBASE_MUTATE_ROW_TS_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    Text tableName;
    Text row;
    GPtrArray * mutations;
    gint64 timestamp;
    GHashTable * attributes;
    IOError * io = NULL;
    IllegalArgument * ia = NULL;
    HbaseMutateRowTsResult * result_struct;

    g_object_get (args,
                  "tableName", &tableName,
                  "row", &row,
                  "mutations", &mutations,
                  "timestamp", &timestamp,
                  "attributes", &attributes,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_HBASE_MUTATE_ROW_TS_RESULT, NULL);

    if (hbase_handler_mutate_row_ts (HBASE_IF (self->handler),
                                     tableName,
                                     row,
                                     mutations,
                                     timestamp,
                                     attributes,
                                     &io,
                                     &ia,
                                     error) == TRUE)
    {
      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "mutateRowTs",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (io != NULL)
      {
        g_object_set (result_struct,
                      "io", io,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "mutateRowTs",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (ia != NULL)
      {
        g_object_set (result_struct,
                      "ia", ia,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "mutateRowTs",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("Hbase.mutateRowTs implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "mutateRowTs",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (tableName != NULL)
      g_byte_array_unref (tableName);
    if (row != NULL)
      g_byte_array_unref (row);
    if (mutations != NULL)
      g_ptr_array_unref (mutations);
    if (attributes != NULL)
      g_hash_table_unref (attributes);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
hbase_processor_process_mutate_rows (HbaseProcessor *self,
                                     gint32 sequence_id,
                                     ThriftProtocol *input_protocol,
                                     ThriftProtocol *output_protocol,
                                     GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  HbaseMutateRowsArgs * args =
    g_object_new (TYPE_HBASE_MUTATE_ROWS_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    Text tableName;
    GPtrArray * rowBatches;
    GHashTable * attributes;
    IOError * io = NULL;
    IllegalArgument * ia = NULL;
    HbaseMutateRowsResult * result_struct;

    g_object_get (args,
                  "tableName", &tableName,
                  "rowBatches", &rowBatches,
                  "attributes", &attributes,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_HBASE_MUTATE_ROWS_RESULT, NULL);

    if (hbase_handler_mutate_rows (HBASE_IF (self->handler),
                                   tableName,
                                   rowBatches,
                                   attributes,
                                   &io,
                                   &ia,
                                   error) == TRUE)
    {
      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "mutateRows",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (io != NULL)
      {
        g_object_set (result_struct,
                      "io", io,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "mutateRows",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (ia != NULL)
      {
        g_object_set (result_struct,
                      "ia", ia,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "mutateRows",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("Hbase.mutateRows implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "mutateRows",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (tableName != NULL)
      g_byte_array_unref (tableName);
    if (rowBatches != NULL)
      g_ptr_array_unref (rowBatches);
    if (attributes != NULL)
      g_hash_table_unref (attributes);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
hbase_processor_process_mutate_rows_ts (HbaseProcessor *self,
                                        gint32 sequence_id,
                                        ThriftProtocol *input_protocol,
                                        ThriftProtocol *output_protocol,
                                        GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  HbaseMutateRowsTsArgs * args =
    g_object_new (TYPE_HBASE_MUTATE_ROWS_TS_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    Text tableName;
    GPtrArray * rowBatches;
    gint64 timestamp;
    GHashTable * attributes;
    IOError * io = NULL;
    IllegalArgument * ia = NULL;
    HbaseMutateRowsTsResult * result_struct;

    g_object_get (args,
                  "tableName", &tableName,
                  "rowBatches", &rowBatches,
                  "timestamp", &timestamp,
                  "attributes", &attributes,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_HBASE_MUTATE_ROWS_TS_RESULT, NULL);

    if (hbase_handler_mutate_rows_ts (HBASE_IF (self->handler),
                                      tableName,
                                      rowBatches,
                                      timestamp,
                                      attributes,
                                      &io,
                                      &ia,
                                      error) == TRUE)
    {
      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "mutateRowsTs",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (io != NULL)
      {
        g_object_set (result_struct,
                      "io", io,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "mutateRowsTs",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (ia != NULL)
      {
        g_object_set (result_struct,
                      "ia", ia,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "mutateRowsTs",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("Hbase.mutateRowsTs implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "mutateRowsTs",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (tableName != NULL)
      g_byte_array_unref (tableName);
    if (rowBatches != NULL)
      g_ptr_array_unref (rowBatches);
    if (attributes != NULL)
      g_hash_table_unref (attributes);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
hbase_processor_process_atomic_increment (HbaseProcessor *self,
                                          gint32 sequence_id,
                                          ThriftProtocol *input_protocol,
                                          ThriftProtocol *output_protocol,
                                          GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  HbaseAtomicIncrementArgs * args =
    g_object_new (TYPE_HBASE_ATOMIC_INCREMENT_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    Text tableName;
    Text row;
    Text column;
    gint64 value;
    IOError * io = NULL;
    IllegalArgument * ia = NULL;
    gint64 return_value;
    HbaseAtomicIncrementResult * result_struct;

    g_object_get (args,
                  "tableName", &tableName,
                  "row", &row,
                  "column", &column,
                  "value", &value,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_HBASE_ATOMIC_INCREMENT_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (hbase_handler_atomic_increment (HBASE_IF (self->handler),
                                        &return_value,
                                        tableName,
                                        row,
                                        column,
                                        value,
                                        &io,
                                        &ia,
                                        error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "atomicIncrement",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (io != NULL)
      {
        g_object_set (result_struct,
                      "io", io,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "atomicIncrement",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (ia != NULL)
      {
        g_object_set (result_struct,
                      "ia", ia,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "atomicIncrement",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("Hbase.atomicIncrement implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "atomicIncrement",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (tableName != NULL)
      g_byte_array_unref (tableName);
    if (row != NULL)
      g_byte_array_unref (row);
    if (column != NULL)
      g_byte_array_unref (column);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
hbase_processor_process_delete_all (HbaseProcessor *self,
                                    gint32 sequence_id,
                                    ThriftProtocol *input_protocol,
                                    ThriftProtocol *output_protocol,
                                    GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  HbaseDeleteAllArgs * args =
    g_object_new (TYPE_HBASE_DELETE_ALL_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    Text tableName;
    Text row;
    Text column;
    GHashTable * attributes;
    IOError * io = NULL;
    HbaseDeleteAllResult * result_struct;

    g_object_get (args,
                  "tableName", &tableName,
                  "row", &row,
                  "column", &column,
                  "attributes", &attributes,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_HBASE_DELETE_ALL_RESULT, NULL);

    if (hbase_handler_delete_all (HBASE_IF (self->handler),
                                  tableName,
                                  row,
                                  column,
                                  attributes,
                                  &io,
                                  error) == TRUE)
    {
      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "deleteAll",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (io != NULL)
      {
        g_object_set (result_struct,
                      "io", io,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "deleteAll",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("Hbase.deleteAll implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "deleteAll",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (tableName != NULL)
      g_byte_array_unref (tableName);
    if (row != NULL)
      g_byte_array_unref (row);
    if (column != NULL)
      g_byte_array_unref (column);
    if (attributes != NULL)
      g_hash_table_unref (attributes);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
hbase_processor_process_delete_all_ts (HbaseProcessor *self,
                                       gint32 sequence_id,
                                       ThriftProtocol *input_protocol,
                                       ThriftProtocol *output_protocol,
                                       GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  HbaseDeleteAllTsArgs * args =
    g_object_new (TYPE_HBASE_DELETE_ALL_TS_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    Text tableName;
    Text row;
    Text column;
    gint64 timestamp;
    GHashTable * attributes;
    IOError * io = NULL;
    HbaseDeleteAllTsResult * result_struct;

    g_object_get (args,
                  "tableName", &tableName,
                  "row", &row,
                  "column", &column,
                  "timestamp", &timestamp,
                  "attributes", &attributes,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_HBASE_DELETE_ALL_TS_RESULT, NULL);

    if (hbase_handler_delete_all_ts (HBASE_IF (self->handler),
                                     tableName,
                                     row,
                                     column,
                                     timestamp,
                                     attributes,
                                     &io,
                                     error) == TRUE)
    {
      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "deleteAllTs",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (io != NULL)
      {
        g_object_set (result_struct,
                      "io", io,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "deleteAllTs",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("Hbase.deleteAllTs implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "deleteAllTs",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (tableName != NULL)
      g_byte_array_unref (tableName);
    if (row != NULL)
      g_byte_array_unref (row);
    if (column != NULL)
      g_byte_array_unref (column);
    if (attributes != NULL)
      g_hash_table_unref (attributes);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
hbase_processor_process_delete_all_row (HbaseProcessor *self,
                                        gint32 sequence_id,
                                        ThriftProtocol *input_protocol,
                                        ThriftProtocol *output_protocol,
                                        GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  HbaseDeleteAllRowArgs * args =
    g_object_new (TYPE_HBASE_DELETE_ALL_ROW_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    Text tableName;
    Text row;
    GHashTable * attributes;
    IOError * io = NULL;
    HbaseDeleteAllRowResult * result_struct;

    g_object_get (args,
                  "tableName", &tableName,
                  "row", &row,
                  "attributes", &attributes,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_HBASE_DELETE_ALL_ROW_RESULT, NULL);

    if (hbase_handler_delete_all_row (HBASE_IF (self->handler),
                                      tableName,
                                      row,
                                      attributes,
                                      &io,
                                      error) == TRUE)
    {
      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "deleteAllRow",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (io != NULL)
      {
        g_object_set (result_struct,
                      "io", io,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "deleteAllRow",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("Hbase.deleteAllRow implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "deleteAllRow",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (tableName != NULL)
      g_byte_array_unref (tableName);
    if (row != NULL)
      g_byte_array_unref (row);
    if (attributes != NULL)
      g_hash_table_unref (attributes);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
hbase_processor_process_increment (HbaseProcessor *self,
                                   gint32 sequence_id,
                                   ThriftProtocol *input_protocol,
                                   ThriftProtocol *output_protocol,
                                   GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  HbaseIncrementArgs * args =
    g_object_new (TYPE_HBASE_INCREMENT_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    TIncrement * increment;
    IOError * io = NULL;
    HbaseIncrementResult * result_struct;

    g_object_get (args,
                  "increment", &increment,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_HBASE_INCREMENT_RESULT, NULL);

    if (hbase_handler_increment (HBASE_IF (self->handler),
                                 increment,
                                 &io,
                                 error) == TRUE)
    {
      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "increment",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (io != NULL)
      {
        g_object_set (result_struct,
                      "io", io,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "increment",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("Hbase.increment implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "increment",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (increment != NULL)
      g_object_unref (increment);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
hbase_processor_process_increment_rows (HbaseProcessor *self,
                                        gint32 sequence_id,
                                        ThriftProtocol *input_protocol,
                                        ThriftProtocol *output_protocol,
                                        GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  HbaseIncrementRowsArgs * args =
    g_object_new (TYPE_HBASE_INCREMENT_ROWS_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    GPtrArray * increments;
    IOError * io = NULL;
    HbaseIncrementRowsResult * result_struct;

    g_object_get (args,
                  "increments", &increments,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_HBASE_INCREMENT_ROWS_RESULT, NULL);

    if (hbase_handler_increment_rows (HBASE_IF (self->handler),
                                      increments,
                                      &io,
                                      error) == TRUE)
    {
      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "incrementRows",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (io != NULL)
      {
        g_object_set (result_struct,
                      "io", io,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "incrementRows",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("Hbase.incrementRows implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "incrementRows",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (increments != NULL)
      g_ptr_array_unref (increments);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
hbase_processor_process_delete_all_row_ts (HbaseProcessor *self,
                                           gint32 sequence_id,
                                           ThriftProtocol *input_protocol,
                                           ThriftProtocol *output_protocol,
                                           GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  HbaseDeleteAllRowTsArgs * args =
    g_object_new (TYPE_HBASE_DELETE_ALL_ROW_TS_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    Text tableName;
    Text row;
    gint64 timestamp;
    GHashTable * attributes;
    IOError * io = NULL;
    HbaseDeleteAllRowTsResult * result_struct;

    g_object_get (args,
                  "tableName", &tableName,
                  "row", &row,
                  "timestamp", &timestamp,
                  "attributes", &attributes,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_HBASE_DELETE_ALL_ROW_TS_RESULT, NULL);

    if (hbase_handler_delete_all_row_ts (HBASE_IF (self->handler),
                                         tableName,
                                         row,
                                         timestamp,
                                         attributes,
                                         &io,
                                         error) == TRUE)
    {
      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "deleteAllRowTs",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (io != NULL)
      {
        g_object_set (result_struct,
                      "io", io,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "deleteAllRowTs",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("Hbase.deleteAllRowTs implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "deleteAllRowTs",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (tableName != NULL)
      g_byte_array_unref (tableName);
    if (row != NULL)
      g_byte_array_unref (row);
    if (attributes != NULL)
      g_hash_table_unref (attributes);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
hbase_processor_process_scanner_open_with_scan (HbaseProcessor *self,
                                                gint32 sequence_id,
                                                ThriftProtocol *input_protocol,
                                                ThriftProtocol *output_protocol,
                                                GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  HbaseScannerOpenWithScanArgs * args =
    g_object_new (TYPE_HBASE_SCANNER_OPEN_WITH_SCAN_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    Text tableName;
    TScan * scan;
    GHashTable * attributes;
    IOError * io = NULL;
    ScannerID return_value;
    HbaseScannerOpenWithScanResult * result_struct;

    g_object_get (args,
                  "tableName", &tableName,
                  "scan", &scan,
                  "attributes", &attributes,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_HBASE_SCANNER_OPEN_WITH_SCAN_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (hbase_handler_scanner_open_with_scan (HBASE_IF (self->handler),
                                              &return_value,
                                              tableName,
                                              scan,
                                              attributes,
                                              &io,
                                              error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "scannerOpenWithScan",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (io != NULL)
      {
        g_object_set (result_struct,
                      "io", io,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "scannerOpenWithScan",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("Hbase.scannerOpenWithScan implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "scannerOpenWithScan",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (tableName != NULL)
      g_byte_array_unref (tableName);
    if (scan != NULL)
      g_object_unref (scan);
    if (attributes != NULL)
      g_hash_table_unref (attributes);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
hbase_processor_process_scanner_open (HbaseProcessor *self,
                                      gint32 sequence_id,
                                      ThriftProtocol *input_protocol,
                                      ThriftProtocol *output_protocol,
                                      GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  HbaseScannerOpenArgs * args =
    g_object_new (TYPE_HBASE_SCANNER_OPEN_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    Text tableName;
    Text startRow;
    GPtrArray * columns;
    GHashTable * attributes;
    IOError * io = NULL;
    ScannerID return_value;
    HbaseScannerOpenResult * result_struct;

    g_object_get (args,
                  "tableName", &tableName,
                  "startRow", &startRow,
                  "columns", &columns,
                  "attributes", &attributes,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_HBASE_SCANNER_OPEN_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (hbase_handler_scanner_open (HBASE_IF (self->handler),
                                    &return_value,
                                    tableName,
                                    startRow,
                                    columns,
                                    attributes,
                                    &io,
                                    error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "scannerOpen",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (io != NULL)
      {
        g_object_set (result_struct,
                      "io", io,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "scannerOpen",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("Hbase.scannerOpen implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "scannerOpen",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (tableName != NULL)
      g_byte_array_unref (tableName);
    if (startRow != NULL)
      g_byte_array_unref (startRow);
    if (columns != NULL)
      g_ptr_array_unref (columns);
    if (attributes != NULL)
      g_hash_table_unref (attributes);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
hbase_processor_process_scanner_open_with_stop (HbaseProcessor *self,
                                                gint32 sequence_id,
                                                ThriftProtocol *input_protocol,
                                                ThriftProtocol *output_protocol,
                                                GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  HbaseScannerOpenWithStopArgs * args =
    g_object_new (TYPE_HBASE_SCANNER_OPEN_WITH_STOP_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    Text tableName;
    Text startRow;
    Text stopRow;
    GPtrArray * columns;
    GHashTable * attributes;
    IOError * io = NULL;
    ScannerID return_value;
    HbaseScannerOpenWithStopResult * result_struct;

    g_object_get (args,
                  "tableName", &tableName,
                  "startRow", &startRow,
                  "stopRow", &stopRow,
                  "columns", &columns,
                  "attributes", &attributes,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_HBASE_SCANNER_OPEN_WITH_STOP_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (hbase_handler_scanner_open_with_stop (HBASE_IF (self->handler),
                                              &return_value,
                                              tableName,
                                              startRow,
                                              stopRow,
                                              columns,
                                              attributes,
                                              &io,
                                              error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "scannerOpenWithStop",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (io != NULL)
      {
        g_object_set (result_struct,
                      "io", io,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "scannerOpenWithStop",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("Hbase.scannerOpenWithStop implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "scannerOpenWithStop",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (tableName != NULL)
      g_byte_array_unref (tableName);
    if (startRow != NULL)
      g_byte_array_unref (startRow);
    if (stopRow != NULL)
      g_byte_array_unref (stopRow);
    if (columns != NULL)
      g_ptr_array_unref (columns);
    if (attributes != NULL)
      g_hash_table_unref (attributes);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
hbase_processor_process_scanner_open_with_prefix (HbaseProcessor *self,
                                                  gint32 sequence_id,
                                                  ThriftProtocol *input_protocol,
                                                  ThriftProtocol *output_protocol,
                                                  GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  HbaseScannerOpenWithPrefixArgs * args =
    g_object_new (TYPE_HBASE_SCANNER_OPEN_WITH_PREFIX_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    Text tableName;
    Text startAndPrefix;
    GPtrArray * columns;
    GHashTable * attributes;
    IOError * io = NULL;
    ScannerID return_value;
    HbaseScannerOpenWithPrefixResult * result_struct;

    g_object_get (args,
                  "tableName", &tableName,
                  "startAndPrefix", &startAndPrefix,
                  "columns", &columns,
                  "attributes", &attributes,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_HBASE_SCANNER_OPEN_WITH_PREFIX_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (hbase_handler_scanner_open_with_prefix (HBASE_IF (self->handler),
                                                &return_value,
                                                tableName,
                                                startAndPrefix,
                                                columns,
                                                attributes,
                                                &io,
                                                error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "scannerOpenWithPrefix",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (io != NULL)
      {
        g_object_set (result_struct,
                      "io", io,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "scannerOpenWithPrefix",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("Hbase.scannerOpenWithPrefix implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "scannerOpenWithPrefix",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (tableName != NULL)
      g_byte_array_unref (tableName);
    if (startAndPrefix != NULL)
      g_byte_array_unref (startAndPrefix);
    if (columns != NULL)
      g_ptr_array_unref (columns);
    if (attributes != NULL)
      g_hash_table_unref (attributes);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
hbase_processor_process_scanner_open_ts (HbaseProcessor *self,
                                         gint32 sequence_id,
                                         ThriftProtocol *input_protocol,
                                         ThriftProtocol *output_protocol,
                                         GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  HbaseScannerOpenTsArgs * args =
    g_object_new (TYPE_HBASE_SCANNER_OPEN_TS_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    Text tableName;
    Text startRow;
    GPtrArray * columns;
    gint64 timestamp;
    GHashTable * attributes;
    IOError * io = NULL;
    ScannerID return_value;
    HbaseScannerOpenTsResult * result_struct;

    g_object_get (args,
                  "tableName", &tableName,
                  "startRow", &startRow,
                  "columns", &columns,
                  "timestamp", &timestamp,
                  "attributes", &attributes,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_HBASE_SCANNER_OPEN_TS_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (hbase_handler_scanner_open_ts (HBASE_IF (self->handler),
                                       &return_value,
                                       tableName,
                                       startRow,
                                       columns,
                                       timestamp,
                                       attributes,
                                       &io,
                                       error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "scannerOpenTs",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (io != NULL)
      {
        g_object_set (result_struct,
                      "io", io,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "scannerOpenTs",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("Hbase.scannerOpenTs implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "scannerOpenTs",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (tableName != NULL)
      g_byte_array_unref (tableName);
    if (startRow != NULL)
      g_byte_array_unref (startRow);
    if (columns != NULL)
      g_ptr_array_unref (columns);
    if (attributes != NULL)
      g_hash_table_unref (attributes);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
hbase_processor_process_scanner_open_with_stop_ts (HbaseProcessor *self,
                                                   gint32 sequence_id,
                                                   ThriftProtocol *input_protocol,
                                                   ThriftProtocol *output_protocol,
                                                   GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  HbaseScannerOpenWithStopTsArgs * args =
    g_object_new (TYPE_HBASE_SCANNER_OPEN_WITH_STOP_TS_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    Text tableName;
    Text startRow;
    Text stopRow;
    GPtrArray * columns;
    gint64 timestamp;
    GHashTable * attributes;
    IOError * io = NULL;
    ScannerID return_value;
    HbaseScannerOpenWithStopTsResult * result_struct;

    g_object_get (args,
                  "tableName", &tableName,
                  "startRow", &startRow,
                  "stopRow", &stopRow,
                  "columns", &columns,
                  "timestamp", &timestamp,
                  "attributes", &attributes,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_HBASE_SCANNER_OPEN_WITH_STOP_TS_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (hbase_handler_scanner_open_with_stop_ts (HBASE_IF (self->handler),
                                                 &return_value,
                                                 tableName,
                                                 startRow,
                                                 stopRow,
                                                 columns,
                                                 timestamp,
                                                 attributes,
                                                 &io,
                                                 error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "scannerOpenWithStopTs",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (io != NULL)
      {
        g_object_set (result_struct,
                      "io", io,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "scannerOpenWithStopTs",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("Hbase.scannerOpenWithStopTs implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "scannerOpenWithStopTs",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (tableName != NULL)
      g_byte_array_unref (tableName);
    if (startRow != NULL)
      g_byte_array_unref (startRow);
    if (stopRow != NULL)
      g_byte_array_unref (stopRow);
    if (columns != NULL)
      g_ptr_array_unref (columns);
    if (attributes != NULL)
      g_hash_table_unref (attributes);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
hbase_processor_process_scanner_get (HbaseProcessor *self,
                                     gint32 sequence_id,
                                     ThriftProtocol *input_protocol,
                                     ThriftProtocol *output_protocol,
                                     GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  HbaseScannerGetArgs * args =
    g_object_new (TYPE_HBASE_SCANNER_GET_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    ScannerID id;
    IOError * io = NULL;
    IllegalArgument * ia = NULL;
    GPtrArray * return_value;
    HbaseScannerGetResult * result_struct;

    g_object_get (args,
                  "id", &id,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_HBASE_SCANNER_GET_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (hbase_handler_scanner_get (HBASE_IF (self->handler),
                                   &return_value,
                                   id,
                                   &io,
                                   &ia,
                                   error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_ptr_array_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "scannerGet",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (io != NULL)
      {
        g_object_set (result_struct,
                      "io", io,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "scannerGet",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (ia != NULL)
      {
        g_object_set (result_struct,
                      "ia", ia,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "scannerGet",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("Hbase.scannerGet implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "scannerGet",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
hbase_processor_process_scanner_get_list (HbaseProcessor *self,
                                          gint32 sequence_id,
                                          ThriftProtocol *input_protocol,
                                          ThriftProtocol *output_protocol,
                                          GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  HbaseScannerGetListArgs * args =
    g_object_new (TYPE_HBASE_SCANNER_GET_LIST_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    ScannerID id;
    gint nbRows;
    IOError * io = NULL;
    IllegalArgument * ia = NULL;
    GPtrArray * return_value;
    HbaseScannerGetListResult * result_struct;

    g_object_get (args,
                  "id", &id,
                  "nbRows", &nbRows,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_HBASE_SCANNER_GET_LIST_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (hbase_handler_scanner_get_list (HBASE_IF (self->handler),
                                        &return_value,
                                        id,
                                        nbRows,
                                        &io,
                                        &ia,
                                        error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_ptr_array_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "scannerGetList",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (io != NULL)
      {
        g_object_set (result_struct,
                      "io", io,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "scannerGetList",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (ia != NULL)
      {
        g_object_set (result_struct,
                      "ia", ia,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "scannerGetList",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("Hbase.scannerGetList implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "scannerGetList",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
hbase_processor_process_scanner_close (HbaseProcessor *self,
                                       gint32 sequence_id,
                                       ThriftProtocol *input_protocol,
                                       ThriftProtocol *output_protocol,
                                       GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  HbaseScannerCloseArgs * args =
    g_object_new (TYPE_HBASE_SCANNER_CLOSE_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    ScannerID id;
    IOError * io = NULL;
    IllegalArgument * ia = NULL;
    HbaseScannerCloseResult * result_struct;

    g_object_get (args,
                  "id", &id,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_HBASE_SCANNER_CLOSE_RESULT, NULL);

    if (hbase_handler_scanner_close (HBASE_IF (self->handler),
                                     id,
                                     &io,
                                     &ia,
                                     error) == TRUE)
    {
      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "scannerClose",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (io != NULL)
      {
        g_object_set (result_struct,
                      "io", io,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "scannerClose",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (ia != NULL)
      {
        g_object_set (result_struct,
                      "ia", ia,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "scannerClose",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("Hbase.scannerClose implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "scannerClose",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
hbase_processor_process_get_row_or_before (HbaseProcessor *self,
                                           gint32 sequence_id,
                                           ThriftProtocol *input_protocol,
                                           ThriftProtocol *output_protocol,
                                           GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  HbaseGetRowOrBeforeArgs * args =
    g_object_new (TYPE_HBASE_GET_ROW_OR_BEFORE_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    Text tableName;
    Text row;
    Text family;
    IOError * io = NULL;
    GPtrArray * return_value;
    HbaseGetRowOrBeforeResult * result_struct;

    g_object_get (args,
                  "tableName", &tableName,
                  "row", &row,
                  "family", &family,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_HBASE_GET_ROW_OR_BEFORE_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (hbase_handler_get_row_or_before (HBASE_IF (self->handler),
                                         &return_value,
                                         tableName,
                                         row,
                                         family,
                                         &io,
                                         error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_ptr_array_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getRowOrBefore",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (io != NULL)
      {
        g_object_set (result_struct,
                      "io", io,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getRowOrBefore",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("Hbase.getRowOrBefore implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getRowOrBefore",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (tableName != NULL)
      g_byte_array_unref (tableName);
    if (row != NULL)
      g_byte_array_unref (row);
    if (family != NULL)
      g_byte_array_unref (family);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
hbase_processor_process_get_region_info (HbaseProcessor *self,
                                         gint32 sequence_id,
                                         ThriftProtocol *input_protocol,
                                         ThriftProtocol *output_protocol,
                                         GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  HbaseGetRegionInfoArgs * args =
    g_object_new (TYPE_HBASE_GET_REGION_INFO_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    Text row;
    IOError * io = NULL;
    TRegionInfo * return_value;
    HbaseGetRegionInfoResult * result_struct;

    g_object_get (args,
                  "row", &row,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_HBASE_GET_REGION_INFO_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (hbase_handler_get_region_info (HBASE_IF (self->handler),
                                       &return_value,
                                       row,
                                       &io,
                                       error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_object_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getRegionInfo",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (io != NULL)
      {
        g_object_set (result_struct,
                      "io", io,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getRegionInfo",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("Hbase.getRegionInfo implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getRegionInfo",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (row != NULL)
      g_byte_array_unref (row);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
hbase_processor_process_append (HbaseProcessor *self,
                                gint32 sequence_id,
                                ThriftProtocol *input_protocol,
                                ThriftProtocol *output_protocol,
                                GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  HbaseAppendArgs * args =
    g_object_new (TYPE_HBASE_APPEND_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    TAppend * append;
    IOError * io = NULL;
    GPtrArray * return_value;
    HbaseAppendResult * result_struct;

    g_object_get (args,
                  "append", &append,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_HBASE_APPEND_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (hbase_handler_append (HBASE_IF (self->handler),
                              &return_value,
                              append,
                              &io,
                              error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_ptr_array_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "append",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (io != NULL)
      {
        g_object_set (result_struct,
                      "io", io,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "append",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("Hbase.append implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "append",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (append != NULL)
      g_object_unref (append);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
hbase_processor_process_check_and_put (HbaseProcessor *self,
                                       gint32 sequence_id,
                                       ThriftProtocol *input_protocol,
                                       ThriftProtocol *output_protocol,
                                       GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  HbaseCheckAndPutArgs * args =
    g_object_new (TYPE_HBASE_CHECK_AND_PUT_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    Text tableName;
    Text row;
    Text column;
    Text value;
    Mutation * mput;
    GHashTable * attributes;
    IOError * io = NULL;
    IllegalArgument * ia = NULL;
    gboolean return_value;
    HbaseCheckAndPutResult * result_struct;

    g_object_get (args,
                  "tableName", &tableName,
                  "row", &row,
                  "column", &column,
                  "value", &value,
                  "mput", &mput,
                  "attributes", &attributes,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_HBASE_CHECK_AND_PUT_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (hbase_handler_check_and_put (HBASE_IF (self->handler),
                                     &return_value,
                                     tableName,
                                     row,
                                     column,
                                     value,
                                     mput,
                                     attributes,
                                     &io,
                                     &ia,
                                     error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "checkAndPut",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (io != NULL)
      {
        g_object_set (result_struct,
                      "io", io,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "checkAndPut",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (ia != NULL)
      {
        g_object_set (result_struct,
                      "ia", ia,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "checkAndPut",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("Hbase.checkAndPut implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "checkAndPut",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (tableName != NULL)
      g_byte_array_unref (tableName);
    if (row != NULL)
      g_byte_array_unref (row);
    if (column != NULL)
      g_byte_array_unref (column);
    if (value != NULL)
      g_byte_array_unref (value);
    if (mput != NULL)
      g_object_unref (mput);
    if (attributes != NULL)
      g_hash_table_unref (attributes);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
hbase_processor_dispatch_call (ThriftDispatchProcessor *dispatch_processor,
                               ThriftProtocol *input_protocol,
                               ThriftProtocol *output_protocol,
                               gchar *method_name,
                               gint32 sequence_id,
                               GError **error)
{
  hbase_processor_process_function_def *process_function_def;
  gboolean dispatch_result = FALSE;

  HbaseProcessor *self = HBASE_PROCESSOR (dispatch_processor);
  ThriftDispatchProcessorClass *parent_class =
    g_type_class_peek_parent (HBASE_PROCESSOR_GET_CLASS (self));

  process_function_def = g_hash_table_lookup (self->process_map, method_name);
  if (process_function_def != NULL)
  {
    g_free (method_name);
    dispatch_result = (*process_function_def->function) (self,
                                                         sequence_id,
                                                         input_protocol,
                                                         output_protocol,
                                                         error);
  }
  else
  {
    dispatch_result = parent_class->dispatch_call (dispatch_processor,
                                                   input_protocol,
                                                   output_protocol,
                                                   method_name,
                                                   sequence_id,
                                                   error);
  }

  return dispatch_result;
}

static void
hbase_processor_set_property (GObject *object,
                              guint property_id,
                              const GValue *value,
                              GParamSpec *pspec)
{
  HbaseProcessor *self = HBASE_PROCESSOR (object);

  switch (property_id)
  {
    case PROP_HBASE_PROCESSOR_HANDLER:
      if (self->handler != NULL)
        g_object_unref (self->handler);
      self->handler = g_value_get_object (value);
      g_object_ref (self->handler);
      break;
    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
hbase_processor_get_property (GObject *object,
                              guint property_id,
                              GValue *value,
                              GParamSpec *pspec)
{
  HbaseProcessor *self = HBASE_PROCESSOR (object);

  switch (property_id)
  {
    case PROP_HBASE_PROCESSOR_HANDLER:
      g_value_set_object (value, self->handler);
      break;
    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
hbase_processor_dispose (GObject *gobject)
{
  HbaseProcessor *self = HBASE_PROCESSOR (gobject);

  if (self->handler != NULL)
  {
    g_object_unref (self->handler);
    self->handler = NULL;
  }

  G_OBJECT_CLASS (hbase_processor_parent_class)->dispose (gobject);
}

static void
hbase_processor_finalize (GObject *gobject)
{
  HbaseProcessor *self = HBASE_PROCESSOR (gobject);

  thrift_safe_hash_table_destroy (self->process_map);

  G_OBJECT_CLASS (hbase_processor_parent_class)->finalize (gobject);
}

static void
hbase_processor_init (HbaseProcessor *self)
{
  guint index;

  self->handler = NULL;
  self->process_map = g_hash_table_new (g_str_hash, g_str_equal);

  for (index = 0; index < 45; index += 1)
    g_hash_table_insert (self->process_map,
                         hbase_processor_process_function_defs[index].name,
                         &hbase_processor_process_function_defs[index]);
}

static void
hbase_processor_class_init (HbaseProcessorClass *cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftDispatchProcessorClass *dispatch_processor_class =
    THRIFT_DISPATCH_PROCESSOR_CLASS (cls);
  GParamSpec *param_spec;

  gobject_class->dispose = hbase_processor_dispose;
  gobject_class->finalize = hbase_processor_finalize;
  gobject_class->set_property = hbase_processor_set_property;
  gobject_class->get_property = hbase_processor_get_property;

  dispatch_processor_class->dispatch_call = hbase_processor_dispatch_call;
  cls->dispatch_call = hbase_processor_dispatch_call;

  param_spec = g_param_spec_object ("handler",
                                    "Service handler implementation",
                                    "The service handler implementation "
                                    "to which method calls are dispatched.",
                                    TYPE_HBASE_HANDLER,
                                    G_PARAM_READWRITE);
  g_object_class_install_property (gobject_class,
                                   PROP_HBASE_PROCESSOR_HANDLER,
                                   param_spec);
}
