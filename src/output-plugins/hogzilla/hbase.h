/**
 * Autogenerated by Thrift Compiler (0.10.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef HBASE_H
#define HBASE_H

#include <thrift/c_glib/processor/thrift_dispatch_processor.h>

#include "hbase_types.h"

/* Hbase service interface */
typedef struct _HbaseIf HbaseIf;  /* dummy object */

struct _HbaseIfInterface
{
  GTypeInterface parent;

  gboolean (*enable_table) (HbaseIf *iface, const Bytes tableName, IOError ** io, GError **error);
  gboolean (*disable_table) (HbaseIf *iface, const Bytes tableName, IOError ** io, GError **error);
  gboolean (*is_table_enabled) (HbaseIf *iface, gboolean* _return, const Bytes tableName, IOError ** io, GError **error);
  gboolean (*compact) (HbaseIf *iface, const Bytes tableNameOrRegionName, IOError ** io, GError **error);
  gboolean (*major_compact) (HbaseIf *iface, const Bytes tableNameOrRegionName, IOError ** io, GError **error);
  gboolean (*get_table_names) (HbaseIf *iface, GPtrArray ** _return, IOError ** io, GError **error);
  gboolean (*get_column_descriptors) (HbaseIf *iface, GHashTable ** _return, const Text tableName, IOError ** io, GError **error);
  gboolean (*get_table_regions) (HbaseIf *iface, GPtrArray ** _return, const Text tableName, IOError ** io, GError **error);
  gboolean (*create_table) (HbaseIf *iface, const Text tableName, const GPtrArray * columnFamilies, IOError ** io, IllegalArgument ** ia, AlreadyExists ** exist, GError **error);
  gboolean (*delete_table) (HbaseIf *iface, const Text tableName, IOError ** io, GError **error);
  gboolean (*get) (HbaseIf *iface, GPtrArray ** _return, const Text tableName, const Text row, const Text column, const GHashTable * attributes, IOError ** io, GError **error);
  gboolean (*get_ver) (HbaseIf *iface, GPtrArray ** _return, const Text tableName, const Text row, const Text column, const gint32 numVersions, const GHashTable * attributes, IOError ** io, GError **error);
  gboolean (*get_ver_ts) (HbaseIf *iface, GPtrArray ** _return, const Text tableName, const Text row, const Text column, const gint64 timestamp, const gint32 numVersions, const GHashTable * attributes, IOError ** io, GError **error);
  gboolean (*get_row) (HbaseIf *iface, GPtrArray ** _return, const Text tableName, const Text row, const GHashTable * attributes, IOError ** io, GError **error);
  gboolean (*get_row_with_columns) (HbaseIf *iface, GPtrArray ** _return, const Text tableName, const Text row, const GPtrArray * columns, const GHashTable * attributes, IOError ** io, GError **error);
  gboolean (*get_row_ts) (HbaseIf *iface, GPtrArray ** _return, const Text tableName, const Text row, const gint64 timestamp, const GHashTable * attributes, IOError ** io, GError **error);
  gboolean (*get_row_with_columns_ts) (HbaseIf *iface, GPtrArray ** _return, const Text tableName, const Text row, const GPtrArray * columns, const gint64 timestamp, const GHashTable * attributes, IOError ** io, GError **error);
  gboolean (*get_rows) (HbaseIf *iface, GPtrArray ** _return, const Text tableName, const GPtrArray * rows, const GHashTable * attributes, IOError ** io, GError **error);
  gboolean (*get_rows_with_columns) (HbaseIf *iface, GPtrArray ** _return, const Text tableName, const GPtrArray * rows, const GPtrArray * columns, const GHashTable * attributes, IOError ** io, GError **error);
  gboolean (*get_rows_ts) (HbaseIf *iface, GPtrArray ** _return, const Text tableName, const GPtrArray * rows, const gint64 timestamp, const GHashTable * attributes, IOError ** io, GError **error);
  gboolean (*get_rows_with_columns_ts) (HbaseIf *iface, GPtrArray ** _return, const Text tableName, const GPtrArray * rows, const GPtrArray * columns, const gint64 timestamp, const GHashTable * attributes, IOError ** io, GError **error);
  gboolean (*mutate_row) (HbaseIf *iface, const Text tableName, const Text row, const GPtrArray * mutations, const GHashTable * attributes, IOError ** io, IllegalArgument ** ia, GError **error);
  gboolean (*mutate_row_ts) (HbaseIf *iface, const Text tableName, const Text row, const GPtrArray * mutations, const gint64 timestamp, const GHashTable * attributes, IOError ** io, IllegalArgument ** ia, GError **error);
  gboolean (*mutate_rows) (HbaseIf *iface, const Text tableName, const GPtrArray * rowBatches, const GHashTable * attributes, IOError ** io, IllegalArgument ** ia, GError **error);
  gboolean (*mutate_rows_ts) (HbaseIf *iface, const Text tableName, const GPtrArray * rowBatches, const gint64 timestamp, const GHashTable * attributes, IOError ** io, IllegalArgument ** ia, GError **error);
  gboolean (*atomic_increment) (HbaseIf *iface, gint64* _return, const Text tableName, const Text row, const Text column, const gint64 value, IOError ** io, IllegalArgument ** ia, GError **error);
  gboolean (*delete_all) (HbaseIf *iface, const Text tableName, const Text row, const Text column, const GHashTable * attributes, IOError ** io, GError **error);
  gboolean (*delete_all_ts) (HbaseIf *iface, const Text tableName, const Text row, const Text column, const gint64 timestamp, const GHashTable * attributes, IOError ** io, GError **error);
  gboolean (*delete_all_row) (HbaseIf *iface, const Text tableName, const Text row, const GHashTable * attributes, IOError ** io, GError **error);
  gboolean (*increment) (HbaseIf *iface, const TIncrement * increment, IOError ** io, GError **error);
  gboolean (*increment_rows) (HbaseIf *iface, const GPtrArray * increments, IOError ** io, GError **error);
  gboolean (*delete_all_row_ts) (HbaseIf *iface, const Text tableName, const Text row, const gint64 timestamp, const GHashTable * attributes, IOError ** io, GError **error);
  gboolean (*scanner_open_with_scan) (HbaseIf *iface, ScannerID* _return, const Text tableName, const TScan * scan, const GHashTable * attributes, IOError ** io, GError **error);
  gboolean (*scanner_open) (HbaseIf *iface, ScannerID* _return, const Text tableName, const Text startRow, const GPtrArray * columns, const GHashTable * attributes, IOError ** io, GError **error);
  gboolean (*scanner_open_with_stop) (HbaseIf *iface, ScannerID* _return, const Text tableName, const Text startRow, const Text stopRow, const GPtrArray * columns, const GHashTable * attributes, IOError ** io, GError **error);
  gboolean (*scanner_open_with_prefix) (HbaseIf *iface, ScannerID* _return, const Text tableName, const Text startAndPrefix, const GPtrArray * columns, const GHashTable * attributes, IOError ** io, GError **error);
  gboolean (*scanner_open_ts) (HbaseIf *iface, ScannerID* _return, const Text tableName, const Text startRow, const GPtrArray * columns, const gint64 timestamp, const GHashTable * attributes, IOError ** io, GError **error);
  gboolean (*scanner_open_with_stop_ts) (HbaseIf *iface, ScannerID* _return, const Text tableName, const Text startRow, const Text stopRow, const GPtrArray * columns, const gint64 timestamp, const GHashTable * attributes, IOError ** io, GError **error);
  gboolean (*scanner_get) (HbaseIf *iface, GPtrArray ** _return, const ScannerID id, IOError ** io, IllegalArgument ** ia, GError **error);
  gboolean (*scanner_get_list) (HbaseIf *iface, GPtrArray ** _return, const ScannerID id, const gint32 nbRows, IOError ** io, IllegalArgument ** ia, GError **error);
  gboolean (*scanner_close) (HbaseIf *iface, const ScannerID id, IOError ** io, IllegalArgument ** ia, GError **error);
  gboolean (*get_row_or_before) (HbaseIf *iface, GPtrArray ** _return, const Text tableName, const Text row, const Text family, IOError ** io, GError **error);
  gboolean (*get_region_info) (HbaseIf *iface, TRegionInfo ** _return, const Text row, IOError ** io, GError **error);
  gboolean (*append) (HbaseIf *iface, GPtrArray ** _return, const TAppend * append, IOError ** io, GError **error);
  gboolean (*check_and_put) (HbaseIf *iface, gboolean* _return, const Text tableName, const Text row, const Text column, const Text value, const Mutation * mput, const GHashTable * attributes, IOError ** io, IllegalArgument ** ia, GError **error);
};
typedef struct _HbaseIfInterface HbaseIfInterface;

GType hbase_if_get_type (void);
#define TYPE_HBASE_IF (hbase_if_get_type())
#define HBASE_IF(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_HBASE_IF, HbaseIf))
#define IS_HBASE_IF(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_HBASE_IF))
#define HBASE_IF_GET_INTERFACE(inst) (G_TYPE_INSTANCE_GET_INTERFACE ((inst), TYPE_HBASE_IF, HbaseIfInterface))

gboolean hbase_if_enable_table (HbaseIf *iface, const Bytes tableName, IOError ** io, GError **error);
gboolean hbase_if_disable_table (HbaseIf *iface, const Bytes tableName, IOError ** io, GError **error);
gboolean hbase_if_is_table_enabled (HbaseIf *iface, gboolean* _return, const Bytes tableName, IOError ** io, GError **error);
gboolean hbase_if_compact (HbaseIf *iface, const Bytes tableNameOrRegionName, IOError ** io, GError **error);
gboolean hbase_if_major_compact (HbaseIf *iface, const Bytes tableNameOrRegionName, IOError ** io, GError **error);
gboolean hbase_if_get_table_names (HbaseIf *iface, GPtrArray ** _return, IOError ** io, GError **error);
gboolean hbase_if_get_column_descriptors (HbaseIf *iface, GHashTable ** _return, const Text tableName, IOError ** io, GError **error);
gboolean hbase_if_get_table_regions (HbaseIf *iface, GPtrArray ** _return, const Text tableName, IOError ** io, GError **error);
gboolean hbase_if_create_table (HbaseIf *iface, const Text tableName, const GPtrArray * columnFamilies, IOError ** io, IllegalArgument ** ia, AlreadyExists ** exist, GError **error);
gboolean hbase_if_delete_table (HbaseIf *iface, const Text tableName, IOError ** io, GError **error);
gboolean hbase_if_get (HbaseIf *iface, GPtrArray ** _return, const Text tableName, const Text row, const Text column, const GHashTable * attributes, IOError ** io, GError **error);
gboolean hbase_if_get_ver (HbaseIf *iface, GPtrArray ** _return, const Text tableName, const Text row, const Text column, const gint32 numVersions, const GHashTable * attributes, IOError ** io, GError **error);
gboolean hbase_if_get_ver_ts (HbaseIf *iface, GPtrArray ** _return, const Text tableName, const Text row, const Text column, const gint64 timestamp, const gint32 numVersions, const GHashTable * attributes, IOError ** io, GError **error);
gboolean hbase_if_get_row (HbaseIf *iface, GPtrArray ** _return, const Text tableName, const Text row, const GHashTable * attributes, IOError ** io, GError **error);
gboolean hbase_if_get_row_with_columns (HbaseIf *iface, GPtrArray ** _return, const Text tableName, const Text row, const GPtrArray * columns, const GHashTable * attributes, IOError ** io, GError **error);
gboolean hbase_if_get_row_ts (HbaseIf *iface, GPtrArray ** _return, const Text tableName, const Text row, const gint64 timestamp, const GHashTable * attributes, IOError ** io, GError **error);
gboolean hbase_if_get_row_with_columns_ts (HbaseIf *iface, GPtrArray ** _return, const Text tableName, const Text row, const GPtrArray * columns, const gint64 timestamp, const GHashTable * attributes, IOError ** io, GError **error);
gboolean hbase_if_get_rows (HbaseIf *iface, GPtrArray ** _return, const Text tableName, const GPtrArray * rows, const GHashTable * attributes, IOError ** io, GError **error);
gboolean hbase_if_get_rows_with_columns (HbaseIf *iface, GPtrArray ** _return, const Text tableName, const GPtrArray * rows, const GPtrArray * columns, const GHashTable * attributes, IOError ** io, GError **error);
gboolean hbase_if_get_rows_ts (HbaseIf *iface, GPtrArray ** _return, const Text tableName, const GPtrArray * rows, const gint64 timestamp, const GHashTable * attributes, IOError ** io, GError **error);
gboolean hbase_if_get_rows_with_columns_ts (HbaseIf *iface, GPtrArray ** _return, const Text tableName, const GPtrArray * rows, const GPtrArray * columns, const gint64 timestamp, const GHashTable * attributes, IOError ** io, GError **error);
gboolean hbase_if_mutate_row (HbaseIf *iface, const Text tableName, const Text row, const GPtrArray * mutations, const GHashTable * attributes, IOError ** io, IllegalArgument ** ia, GError **error);
gboolean hbase_if_mutate_row_ts (HbaseIf *iface, const Text tableName, const Text row, const GPtrArray * mutations, const gint64 timestamp, const GHashTable * attributes, IOError ** io, IllegalArgument ** ia, GError **error);
gboolean hbase_if_mutate_rows (HbaseIf *iface, const Text tableName, const GPtrArray * rowBatches, const GHashTable * attributes, IOError ** io, IllegalArgument ** ia, GError **error);
gboolean hbase_if_mutate_rows_ts (HbaseIf *iface, const Text tableName, const GPtrArray * rowBatches, const gint64 timestamp, const GHashTable * attributes, IOError ** io, IllegalArgument ** ia, GError **error);
gboolean hbase_if_atomic_increment (HbaseIf *iface, gint64* _return, const Text tableName, const Text row, const Text column, const gint64 value, IOError ** io, IllegalArgument ** ia, GError **error);
gboolean hbase_if_delete_all (HbaseIf *iface, const Text tableName, const Text row, const Text column, const GHashTable * attributes, IOError ** io, GError **error);
gboolean hbase_if_delete_all_ts (HbaseIf *iface, const Text tableName, const Text row, const Text column, const gint64 timestamp, const GHashTable * attributes, IOError ** io, GError **error);
gboolean hbase_if_delete_all_row (HbaseIf *iface, const Text tableName, const Text row, const GHashTable * attributes, IOError ** io, GError **error);
gboolean hbase_if_increment (HbaseIf *iface, const TIncrement * increment, IOError ** io, GError **error);
gboolean hbase_if_increment_rows (HbaseIf *iface, const GPtrArray * increments, IOError ** io, GError **error);
gboolean hbase_if_delete_all_row_ts (HbaseIf *iface, const Text tableName, const Text row, const gint64 timestamp, const GHashTable * attributes, IOError ** io, GError **error);
gboolean hbase_if_scanner_open_with_scan (HbaseIf *iface, ScannerID* _return, const Text tableName, const TScan * scan, const GHashTable * attributes, IOError ** io, GError **error);
gboolean hbase_if_scanner_open (HbaseIf *iface, ScannerID* _return, const Text tableName, const Text startRow, const GPtrArray * columns, const GHashTable * attributes, IOError ** io, GError **error);
gboolean hbase_if_scanner_open_with_stop (HbaseIf *iface, ScannerID* _return, const Text tableName, const Text startRow, const Text stopRow, const GPtrArray * columns, const GHashTable * attributes, IOError ** io, GError **error);
gboolean hbase_if_scanner_open_with_prefix (HbaseIf *iface, ScannerID* _return, const Text tableName, const Text startAndPrefix, const GPtrArray * columns, const GHashTable * attributes, IOError ** io, GError **error);
gboolean hbase_if_scanner_open_ts (HbaseIf *iface, ScannerID* _return, const Text tableName, const Text startRow, const GPtrArray * columns, const gint64 timestamp, const GHashTable * attributes, IOError ** io, GError **error);
gboolean hbase_if_scanner_open_with_stop_ts (HbaseIf *iface, ScannerID* _return, const Text tableName, const Text startRow, const Text stopRow, const GPtrArray * columns, const gint64 timestamp, const GHashTable * attributes, IOError ** io, GError **error);
gboolean hbase_if_scanner_get (HbaseIf *iface, GPtrArray ** _return, const ScannerID id, IOError ** io, IllegalArgument ** ia, GError **error);
gboolean hbase_if_scanner_get_list (HbaseIf *iface, GPtrArray ** _return, const ScannerID id, const gint32 nbRows, IOError ** io, IllegalArgument ** ia, GError **error);
gboolean hbase_if_scanner_close (HbaseIf *iface, const ScannerID id, IOError ** io, IllegalArgument ** ia, GError **error);
gboolean hbase_if_get_row_or_before (HbaseIf *iface, GPtrArray ** _return, const Text tableName, const Text row, const Text family, IOError ** io, GError **error);
gboolean hbase_if_get_region_info (HbaseIf *iface, TRegionInfo ** _return, const Text row, IOError ** io, GError **error);
gboolean hbase_if_append (HbaseIf *iface, GPtrArray ** _return, const TAppend * append, IOError ** io, GError **error);
gboolean hbase_if_check_and_put (HbaseIf *iface, gboolean* _return, const Text tableName, const Text row, const Text column, const Text value, const Mutation * mput, const GHashTable * attributes, IOError ** io, IllegalArgument ** ia, GError **error);

/* Hbase service client */
struct _HbaseClient
{
  GObject parent;

  ThriftProtocol *input_protocol;
  ThriftProtocol *output_protocol;
};
typedef struct _HbaseClient HbaseClient;

struct _HbaseClientClass
{
  GObjectClass parent;
};
typedef struct _HbaseClientClass HbaseClientClass;

GType hbase_client_get_type (void);
#define TYPE_HBASE_CLIENT (hbase_client_get_type())
#define HBASE_CLIENT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_HBASE_CLIENT, HbaseClient))
#define HBASE_CLIENT_CLASS(c) (G_TYPE_CHECK_CLASS_CAST ((c), TYPE_HBASE_CLIENT, HbaseClientClass))
#define HBASE_IS_CLIENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_HBASE_CLIENT))
#define HBASE_IS_CLIENT_CLASS(c) (G_TYPE_CHECK_CLASS_TYPE ((c), TYPE_HBASE_CLIENT))
#define HBASE_CLIENT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_HBASE_CLIENT, HbaseClientClass))

gboolean hbase_client_enable_table (HbaseIf * iface, const Bytes tableName, IOError ** io, GError ** error);
gboolean hbase_client_send_enable_table (HbaseIf * iface, const Bytes tableName, GError ** error);
gboolean hbase_client_recv_enable_table (HbaseIf * iface, IOError ** io, GError ** error);
gboolean hbase_client_disable_table (HbaseIf * iface, const Bytes tableName, IOError ** io, GError ** error);
gboolean hbase_client_send_disable_table (HbaseIf * iface, const Bytes tableName, GError ** error);
gboolean hbase_client_recv_disable_table (HbaseIf * iface, IOError ** io, GError ** error);
gboolean hbase_client_is_table_enabled (HbaseIf * iface, gboolean* _return, const Bytes tableName, IOError ** io, GError ** error);
gboolean hbase_client_send_is_table_enabled (HbaseIf * iface, const Bytes tableName, GError ** error);
gboolean hbase_client_recv_is_table_enabled (HbaseIf * iface, gboolean* _return, IOError ** io, GError ** error);
gboolean hbase_client_compact (HbaseIf * iface, const Bytes tableNameOrRegionName, IOError ** io, GError ** error);
gboolean hbase_client_send_compact (HbaseIf * iface, const Bytes tableNameOrRegionName, GError ** error);
gboolean hbase_client_recv_compact (HbaseIf * iface, IOError ** io, GError ** error);
gboolean hbase_client_major_compact (HbaseIf * iface, const Bytes tableNameOrRegionName, IOError ** io, GError ** error);
gboolean hbase_client_send_major_compact (HbaseIf * iface, const Bytes tableNameOrRegionName, GError ** error);
gboolean hbase_client_recv_major_compact (HbaseIf * iface, IOError ** io, GError ** error);
gboolean hbase_client_get_table_names (HbaseIf * iface, GPtrArray ** _return, IOError ** io, GError ** error);
gboolean hbase_client_send_get_table_names (HbaseIf * iface, GError ** error);
gboolean hbase_client_recv_get_table_names (HbaseIf * iface, GPtrArray ** _return, IOError ** io, GError ** error);
gboolean hbase_client_get_column_descriptors (HbaseIf * iface, GHashTable ** _return, const Text tableName, IOError ** io, GError ** error);
gboolean hbase_client_send_get_column_descriptors (HbaseIf * iface, const Text tableName, GError ** error);
gboolean hbase_client_recv_get_column_descriptors (HbaseIf * iface, GHashTable ** _return, IOError ** io, GError ** error);
gboolean hbase_client_get_table_regions (HbaseIf * iface, GPtrArray ** _return, const Text tableName, IOError ** io, GError ** error);
gboolean hbase_client_send_get_table_regions (HbaseIf * iface, const Text tableName, GError ** error);
gboolean hbase_client_recv_get_table_regions (HbaseIf * iface, GPtrArray ** _return, IOError ** io, GError ** error);
gboolean hbase_client_create_table (HbaseIf * iface, const Text tableName, const GPtrArray * columnFamilies, IOError ** io, IllegalArgument ** ia, AlreadyExists ** exist, GError ** error);
gboolean hbase_client_send_create_table (HbaseIf * iface, const Text tableName, const GPtrArray * columnFamilies, GError ** error);
gboolean hbase_client_recv_create_table (HbaseIf * iface, IOError ** io, IllegalArgument ** ia, AlreadyExists ** exist, GError ** error);
gboolean hbase_client_delete_table (HbaseIf * iface, const Text tableName, IOError ** io, GError ** error);
gboolean hbase_client_send_delete_table (HbaseIf * iface, const Text tableName, GError ** error);
gboolean hbase_client_recv_delete_table (HbaseIf * iface, IOError ** io, GError ** error);
gboolean hbase_client_get (HbaseIf * iface, GPtrArray ** _return, const Text tableName, const Text row, const Text column, const GHashTable * attributes, IOError ** io, GError ** error);
gboolean hbase_client_send_get (HbaseIf * iface, const Text tableName, const Text row, const Text column, const GHashTable * attributes, GError ** error);
gboolean hbase_client_recv_get (HbaseIf * iface, GPtrArray ** _return, IOError ** io, GError ** error);
gboolean hbase_client_get_ver (HbaseIf * iface, GPtrArray ** _return, const Text tableName, const Text row, const Text column, const gint32 numVersions, const GHashTable * attributes, IOError ** io, GError ** error);
gboolean hbase_client_send_get_ver (HbaseIf * iface, const Text tableName, const Text row, const Text column, const gint32 numVersions, const GHashTable * attributes, GError ** error);
gboolean hbase_client_recv_get_ver (HbaseIf * iface, GPtrArray ** _return, IOError ** io, GError ** error);
gboolean hbase_client_get_ver_ts (HbaseIf * iface, GPtrArray ** _return, const Text tableName, const Text row, const Text column, const gint64 timestamp, const gint32 numVersions, const GHashTable * attributes, IOError ** io, GError ** error);
gboolean hbase_client_send_get_ver_ts (HbaseIf * iface, const Text tableName, const Text row, const Text column, const gint64 timestamp, const gint32 numVersions, const GHashTable * attributes, GError ** error);
gboolean hbase_client_recv_get_ver_ts (HbaseIf * iface, GPtrArray ** _return, IOError ** io, GError ** error);
gboolean hbase_client_get_row (HbaseIf * iface, GPtrArray ** _return, const Text tableName, const Text row, const GHashTable * attributes, IOError ** io, GError ** error);
gboolean hbase_client_send_get_row (HbaseIf * iface, const Text tableName, const Text row, const GHashTable * attributes, GError ** error);
gboolean hbase_client_recv_get_row (HbaseIf * iface, GPtrArray ** _return, IOError ** io, GError ** error);
gboolean hbase_client_get_row_with_columns (HbaseIf * iface, GPtrArray ** _return, const Text tableName, const Text row, const GPtrArray * columns, const GHashTable * attributes, IOError ** io, GError ** error);
gboolean hbase_client_send_get_row_with_columns (HbaseIf * iface, const Text tableName, const Text row, const GPtrArray * columns, const GHashTable * attributes, GError ** error);
gboolean hbase_client_recv_get_row_with_columns (HbaseIf * iface, GPtrArray ** _return, IOError ** io, GError ** error);
gboolean hbase_client_get_row_ts (HbaseIf * iface, GPtrArray ** _return, const Text tableName, const Text row, const gint64 timestamp, const GHashTable * attributes, IOError ** io, GError ** error);
gboolean hbase_client_send_get_row_ts (HbaseIf * iface, const Text tableName, const Text row, const gint64 timestamp, const GHashTable * attributes, GError ** error);
gboolean hbase_client_recv_get_row_ts (HbaseIf * iface, GPtrArray ** _return, IOError ** io, GError ** error);
gboolean hbase_client_get_row_with_columns_ts (HbaseIf * iface, GPtrArray ** _return, const Text tableName, const Text row, const GPtrArray * columns, const gint64 timestamp, const GHashTable * attributes, IOError ** io, GError ** error);
gboolean hbase_client_send_get_row_with_columns_ts (HbaseIf * iface, const Text tableName, const Text row, const GPtrArray * columns, const gint64 timestamp, const GHashTable * attributes, GError ** error);
gboolean hbase_client_recv_get_row_with_columns_ts (HbaseIf * iface, GPtrArray ** _return, IOError ** io, GError ** error);
gboolean hbase_client_get_rows (HbaseIf * iface, GPtrArray ** _return, const Text tableName, const GPtrArray * rows, const GHashTable * attributes, IOError ** io, GError ** error);
gboolean hbase_client_send_get_rows (HbaseIf * iface, const Text tableName, const GPtrArray * rows, const GHashTable * attributes, GError ** error);
gboolean hbase_client_recv_get_rows (HbaseIf * iface, GPtrArray ** _return, IOError ** io, GError ** error);
gboolean hbase_client_get_rows_with_columns (HbaseIf * iface, GPtrArray ** _return, const Text tableName, const GPtrArray * rows, const GPtrArray * columns, const GHashTable * attributes, IOError ** io, GError ** error);
gboolean hbase_client_send_get_rows_with_columns (HbaseIf * iface, const Text tableName, const GPtrArray * rows, const GPtrArray * columns, const GHashTable * attributes, GError ** error);
gboolean hbase_client_recv_get_rows_with_columns (HbaseIf * iface, GPtrArray ** _return, IOError ** io, GError ** error);
gboolean hbase_client_get_rows_ts (HbaseIf * iface, GPtrArray ** _return, const Text tableName, const GPtrArray * rows, const gint64 timestamp, const GHashTable * attributes, IOError ** io, GError ** error);
gboolean hbase_client_send_get_rows_ts (HbaseIf * iface, const Text tableName, const GPtrArray * rows, const gint64 timestamp, const GHashTable * attributes, GError ** error);
gboolean hbase_client_recv_get_rows_ts (HbaseIf * iface, GPtrArray ** _return, IOError ** io, GError ** error);
gboolean hbase_client_get_rows_with_columns_ts (HbaseIf * iface, GPtrArray ** _return, const Text tableName, const GPtrArray * rows, const GPtrArray * columns, const gint64 timestamp, const GHashTable * attributes, IOError ** io, GError ** error);
gboolean hbase_client_send_get_rows_with_columns_ts (HbaseIf * iface, const Text tableName, const GPtrArray * rows, const GPtrArray * columns, const gint64 timestamp, const GHashTable * attributes, GError ** error);
gboolean hbase_client_recv_get_rows_with_columns_ts (HbaseIf * iface, GPtrArray ** _return, IOError ** io, GError ** error);
gboolean hbase_client_mutate_row (HbaseIf * iface, const Text tableName, const Text row, const GPtrArray * mutations, const GHashTable * attributes, IOError ** io, IllegalArgument ** ia, GError ** error);
gboolean hbase_client_send_mutate_row (HbaseIf * iface, const Text tableName, const Text row, const GPtrArray * mutations, const GHashTable * attributes, GError ** error);
gboolean hbase_client_recv_mutate_row (HbaseIf * iface, IOError ** io, IllegalArgument ** ia, GError ** error);
gboolean hbase_client_mutate_row_ts (HbaseIf * iface, const Text tableName, const Text row, const GPtrArray * mutations, const gint64 timestamp, const GHashTable * attributes, IOError ** io, IllegalArgument ** ia, GError ** error);
gboolean hbase_client_send_mutate_row_ts (HbaseIf * iface, const Text tableName, const Text row, const GPtrArray * mutations, const gint64 timestamp, const GHashTable * attributes, GError ** error);
gboolean hbase_client_recv_mutate_row_ts (HbaseIf * iface, IOError ** io, IllegalArgument ** ia, GError ** error);
gboolean hbase_client_mutate_rows (HbaseIf * iface, const Text tableName, const GPtrArray * rowBatches, const GHashTable * attributes, IOError ** io, IllegalArgument ** ia, GError ** error);
gboolean hbase_client_send_mutate_rows (HbaseIf * iface, const Text tableName, const GPtrArray * rowBatches, const GHashTable * attributes, GError ** error);
gboolean hbase_client_recv_mutate_rows (HbaseIf * iface, IOError ** io, IllegalArgument ** ia, GError ** error);
gboolean hbase_client_mutate_rows_ts (HbaseIf * iface, const Text tableName, const GPtrArray * rowBatches, const gint64 timestamp, const GHashTable * attributes, IOError ** io, IllegalArgument ** ia, GError ** error);
gboolean hbase_client_send_mutate_rows_ts (HbaseIf * iface, const Text tableName, const GPtrArray * rowBatches, const gint64 timestamp, const GHashTable * attributes, GError ** error);
gboolean hbase_client_recv_mutate_rows_ts (HbaseIf * iface, IOError ** io, IllegalArgument ** ia, GError ** error);
gboolean hbase_client_atomic_increment (HbaseIf * iface, gint64* _return, const Text tableName, const Text row, const Text column, const gint64 value, IOError ** io, IllegalArgument ** ia, GError ** error);
gboolean hbase_client_send_atomic_increment (HbaseIf * iface, const Text tableName, const Text row, const Text column, const gint64 value, GError ** error);
gboolean hbase_client_recv_atomic_increment (HbaseIf * iface, gint64* _return, IOError ** io, IllegalArgument ** ia, GError ** error);
gboolean hbase_client_delete_all (HbaseIf * iface, const Text tableName, const Text row, const Text column, const GHashTable * attributes, IOError ** io, GError ** error);
gboolean hbase_client_send_delete_all (HbaseIf * iface, const Text tableName, const Text row, const Text column, const GHashTable * attributes, GError ** error);
gboolean hbase_client_recv_delete_all (HbaseIf * iface, IOError ** io, GError ** error);
gboolean hbase_client_delete_all_ts (HbaseIf * iface, const Text tableName, const Text row, const Text column, const gint64 timestamp, const GHashTable * attributes, IOError ** io, GError ** error);
gboolean hbase_client_send_delete_all_ts (HbaseIf * iface, const Text tableName, const Text row, const Text column, const gint64 timestamp, const GHashTable * attributes, GError ** error);
gboolean hbase_client_recv_delete_all_ts (HbaseIf * iface, IOError ** io, GError ** error);
gboolean hbase_client_delete_all_row (HbaseIf * iface, const Text tableName, const Text row, const GHashTable * attributes, IOError ** io, GError ** error);
gboolean hbase_client_send_delete_all_row (HbaseIf * iface, const Text tableName, const Text row, const GHashTable * attributes, GError ** error);
gboolean hbase_client_recv_delete_all_row (HbaseIf * iface, IOError ** io, GError ** error);
gboolean hbase_client_increment (HbaseIf * iface, const TIncrement * increment, IOError ** io, GError ** error);
gboolean hbase_client_send_increment (HbaseIf * iface, const TIncrement * increment, GError ** error);
gboolean hbase_client_recv_increment (HbaseIf * iface, IOError ** io, GError ** error);
gboolean hbase_client_increment_rows (HbaseIf * iface, const GPtrArray * increments, IOError ** io, GError ** error);
gboolean hbase_client_send_increment_rows (HbaseIf * iface, const GPtrArray * increments, GError ** error);
gboolean hbase_client_recv_increment_rows (HbaseIf * iface, IOError ** io, GError ** error);
gboolean hbase_client_delete_all_row_ts (HbaseIf * iface, const Text tableName, const Text row, const gint64 timestamp, const GHashTable * attributes, IOError ** io, GError ** error);
gboolean hbase_client_send_delete_all_row_ts (HbaseIf * iface, const Text tableName, const Text row, const gint64 timestamp, const GHashTable * attributes, GError ** error);
gboolean hbase_client_recv_delete_all_row_ts (HbaseIf * iface, IOError ** io, GError ** error);
gboolean hbase_client_scanner_open_with_scan (HbaseIf * iface, ScannerID* _return, const Text tableName, const TScan * scan, const GHashTable * attributes, IOError ** io, GError ** error);
gboolean hbase_client_send_scanner_open_with_scan (HbaseIf * iface, const Text tableName, const TScan * scan, const GHashTable * attributes, GError ** error);
gboolean hbase_client_recv_scanner_open_with_scan (HbaseIf * iface, ScannerID* _return, IOError ** io, GError ** error);
gboolean hbase_client_scanner_open (HbaseIf * iface, ScannerID* _return, const Text tableName, const Text startRow, const GPtrArray * columns, const GHashTable * attributes, IOError ** io, GError ** error);
gboolean hbase_client_send_scanner_open (HbaseIf * iface, const Text tableName, const Text startRow, const GPtrArray * columns, const GHashTable * attributes, GError ** error);
gboolean hbase_client_recv_scanner_open (HbaseIf * iface, ScannerID* _return, IOError ** io, GError ** error);
gboolean hbase_client_scanner_open_with_stop (HbaseIf * iface, ScannerID* _return, const Text tableName, const Text startRow, const Text stopRow, const GPtrArray * columns, const GHashTable * attributes, IOError ** io, GError ** error);
gboolean hbase_client_send_scanner_open_with_stop (HbaseIf * iface, const Text tableName, const Text startRow, const Text stopRow, const GPtrArray * columns, const GHashTable * attributes, GError ** error);
gboolean hbase_client_recv_scanner_open_with_stop (HbaseIf * iface, ScannerID* _return, IOError ** io, GError ** error);
gboolean hbase_client_scanner_open_with_prefix (HbaseIf * iface, ScannerID* _return, const Text tableName, const Text startAndPrefix, const GPtrArray * columns, const GHashTable * attributes, IOError ** io, GError ** error);
gboolean hbase_client_send_scanner_open_with_prefix (HbaseIf * iface, const Text tableName, const Text startAndPrefix, const GPtrArray * columns, const GHashTable * attributes, GError ** error);
gboolean hbase_client_recv_scanner_open_with_prefix (HbaseIf * iface, ScannerID* _return, IOError ** io, GError ** error);
gboolean hbase_client_scanner_open_ts (HbaseIf * iface, ScannerID* _return, const Text tableName, const Text startRow, const GPtrArray * columns, const gint64 timestamp, const GHashTable * attributes, IOError ** io, GError ** error);
gboolean hbase_client_send_scanner_open_ts (HbaseIf * iface, const Text tableName, const Text startRow, const GPtrArray * columns, const gint64 timestamp, const GHashTable * attributes, GError ** error);
gboolean hbase_client_recv_scanner_open_ts (HbaseIf * iface, ScannerID* _return, IOError ** io, GError ** error);
gboolean hbase_client_scanner_open_with_stop_ts (HbaseIf * iface, ScannerID* _return, const Text tableName, const Text startRow, const Text stopRow, const GPtrArray * columns, const gint64 timestamp, const GHashTable * attributes, IOError ** io, GError ** error);
gboolean hbase_client_send_scanner_open_with_stop_ts (HbaseIf * iface, const Text tableName, const Text startRow, const Text stopRow, const GPtrArray * columns, const gint64 timestamp, const GHashTable * attributes, GError ** error);
gboolean hbase_client_recv_scanner_open_with_stop_ts (HbaseIf * iface, ScannerID* _return, IOError ** io, GError ** error);
gboolean hbase_client_scanner_get (HbaseIf * iface, GPtrArray ** _return, const ScannerID id, IOError ** io, IllegalArgument ** ia, GError ** error);
gboolean hbase_client_send_scanner_get (HbaseIf * iface, const ScannerID id, GError ** error);
gboolean hbase_client_recv_scanner_get (HbaseIf * iface, GPtrArray ** _return, IOError ** io, IllegalArgument ** ia, GError ** error);
gboolean hbase_client_scanner_get_list (HbaseIf * iface, GPtrArray ** _return, const ScannerID id, const gint32 nbRows, IOError ** io, IllegalArgument ** ia, GError ** error);
gboolean hbase_client_send_scanner_get_list (HbaseIf * iface, const ScannerID id, const gint32 nbRows, GError ** error);
gboolean hbase_client_recv_scanner_get_list (HbaseIf * iface, GPtrArray ** _return, IOError ** io, IllegalArgument ** ia, GError ** error);
gboolean hbase_client_scanner_close (HbaseIf * iface, const ScannerID id, IOError ** io, IllegalArgument ** ia, GError ** error);
gboolean hbase_client_send_scanner_close (HbaseIf * iface, const ScannerID id, GError ** error);
gboolean hbase_client_recv_scanner_close (HbaseIf * iface, IOError ** io, IllegalArgument ** ia, GError ** error);
gboolean hbase_client_get_row_or_before (HbaseIf * iface, GPtrArray ** _return, const Text tableName, const Text row, const Text family, IOError ** io, GError ** error);
gboolean hbase_client_send_get_row_or_before (HbaseIf * iface, const Text tableName, const Text row, const Text family, GError ** error);
gboolean hbase_client_recv_get_row_or_before (HbaseIf * iface, GPtrArray ** _return, IOError ** io, GError ** error);
gboolean hbase_client_get_region_info (HbaseIf * iface, TRegionInfo ** _return, const Text row, IOError ** io, GError ** error);
gboolean hbase_client_send_get_region_info (HbaseIf * iface, const Text row, GError ** error);
gboolean hbase_client_recv_get_region_info (HbaseIf * iface, TRegionInfo ** _return, IOError ** io, GError ** error);
gboolean hbase_client_append (HbaseIf * iface, GPtrArray ** _return, const TAppend * append, IOError ** io, GError ** error);
gboolean hbase_client_send_append (HbaseIf * iface, const TAppend * append, GError ** error);
gboolean hbase_client_recv_append (HbaseIf * iface, GPtrArray ** _return, IOError ** io, GError ** error);
gboolean hbase_client_check_and_put (HbaseIf * iface, gboolean* _return, const Text tableName, const Text row, const Text column, const Text value, const Mutation * mput, const GHashTable * attributes, IOError ** io, IllegalArgument ** ia, GError ** error);
gboolean hbase_client_send_check_and_put (HbaseIf * iface, const Text tableName, const Text row, const Text column, const Text value, const Mutation * mput, const GHashTable * attributes, GError ** error);
gboolean hbase_client_recv_check_and_put (HbaseIf * iface, gboolean* _return, IOError ** io, IllegalArgument ** ia, GError ** error);
void hbase_client_set_property (GObject *object, guint property_id, const GValue *value, GParamSpec *pspec);
void hbase_client_get_property (GObject *object, guint property_id, GValue *value, GParamSpec *pspec);

/* Hbase handler (abstract base class) */
struct _HbaseHandler
{
  GObject parent;
};
typedef struct _HbaseHandler HbaseHandler;

struct _HbaseHandlerClass
{
  GObjectClass parent;

  gboolean (*enable_table) (HbaseIf *iface, const Bytes tableName, IOError ** io, GError **error);
  gboolean (*disable_table) (HbaseIf *iface, const Bytes tableName, IOError ** io, GError **error);
  gboolean (*is_table_enabled) (HbaseIf *iface, gboolean* _return, const Bytes tableName, IOError ** io, GError **error);
  gboolean (*compact) (HbaseIf *iface, const Bytes tableNameOrRegionName, IOError ** io, GError **error);
  gboolean (*major_compact) (HbaseIf *iface, const Bytes tableNameOrRegionName, IOError ** io, GError **error);
  gboolean (*get_table_names) (HbaseIf *iface, GPtrArray ** _return, IOError ** io, GError **error);
  gboolean (*get_column_descriptors) (HbaseIf *iface, GHashTable ** _return, const Text tableName, IOError ** io, GError **error);
  gboolean (*get_table_regions) (HbaseIf *iface, GPtrArray ** _return, const Text tableName, IOError ** io, GError **error);
  gboolean (*create_table) (HbaseIf *iface, const Text tableName, const GPtrArray * columnFamilies, IOError ** io, IllegalArgument ** ia, AlreadyExists ** exist, GError **error);
  gboolean (*delete_table) (HbaseIf *iface, const Text tableName, IOError ** io, GError **error);
  gboolean (*get) (HbaseIf *iface, GPtrArray ** _return, const Text tableName, const Text row, const Text column, const GHashTable * attributes, IOError ** io, GError **error);
  gboolean (*get_ver) (HbaseIf *iface, GPtrArray ** _return, const Text tableName, const Text row, const Text column, const gint32 numVersions, const GHashTable * attributes, IOError ** io, GError **error);
  gboolean (*get_ver_ts) (HbaseIf *iface, GPtrArray ** _return, const Text tableName, const Text row, const Text column, const gint64 timestamp, const gint32 numVersions, const GHashTable * attributes, IOError ** io, GError **error);
  gboolean (*get_row) (HbaseIf *iface, GPtrArray ** _return, const Text tableName, const Text row, const GHashTable * attributes, IOError ** io, GError **error);
  gboolean (*get_row_with_columns) (HbaseIf *iface, GPtrArray ** _return, const Text tableName, const Text row, const GPtrArray * columns, const GHashTable * attributes, IOError ** io, GError **error);
  gboolean (*get_row_ts) (HbaseIf *iface, GPtrArray ** _return, const Text tableName, const Text row, const gint64 timestamp, const GHashTable * attributes, IOError ** io, GError **error);
  gboolean (*get_row_with_columns_ts) (HbaseIf *iface, GPtrArray ** _return, const Text tableName, const Text row, const GPtrArray * columns, const gint64 timestamp, const GHashTable * attributes, IOError ** io, GError **error);
  gboolean (*get_rows) (HbaseIf *iface, GPtrArray ** _return, const Text tableName, const GPtrArray * rows, const GHashTable * attributes, IOError ** io, GError **error);
  gboolean (*get_rows_with_columns) (HbaseIf *iface, GPtrArray ** _return, const Text tableName, const GPtrArray * rows, const GPtrArray * columns, const GHashTable * attributes, IOError ** io, GError **error);
  gboolean (*get_rows_ts) (HbaseIf *iface, GPtrArray ** _return, const Text tableName, const GPtrArray * rows, const gint64 timestamp, const GHashTable * attributes, IOError ** io, GError **error);
  gboolean (*get_rows_with_columns_ts) (HbaseIf *iface, GPtrArray ** _return, const Text tableName, const GPtrArray * rows, const GPtrArray * columns, const gint64 timestamp, const GHashTable * attributes, IOError ** io, GError **error);
  gboolean (*mutate_row) (HbaseIf *iface, const Text tableName, const Text row, const GPtrArray * mutations, const GHashTable * attributes, IOError ** io, IllegalArgument ** ia, GError **error);
  gboolean (*mutate_row_ts) (HbaseIf *iface, const Text tableName, const Text row, const GPtrArray * mutations, const gint64 timestamp, const GHashTable * attributes, IOError ** io, IllegalArgument ** ia, GError **error);
  gboolean (*mutate_rows) (HbaseIf *iface, const Text tableName, const GPtrArray * rowBatches, const GHashTable * attributes, IOError ** io, IllegalArgument ** ia, GError **error);
  gboolean (*mutate_rows_ts) (HbaseIf *iface, const Text tableName, const GPtrArray * rowBatches, const gint64 timestamp, const GHashTable * attributes, IOError ** io, IllegalArgument ** ia, GError **error);
  gboolean (*atomic_increment) (HbaseIf *iface, gint64* _return, const Text tableName, const Text row, const Text column, const gint64 value, IOError ** io, IllegalArgument ** ia, GError **error);
  gboolean (*delete_all) (HbaseIf *iface, const Text tableName, const Text row, const Text column, const GHashTable * attributes, IOError ** io, GError **error);
  gboolean (*delete_all_ts) (HbaseIf *iface, const Text tableName, const Text row, const Text column, const gint64 timestamp, const GHashTable * attributes, IOError ** io, GError **error);
  gboolean (*delete_all_row) (HbaseIf *iface, const Text tableName, const Text row, const GHashTable * attributes, IOError ** io, GError **error);
  gboolean (*increment) (HbaseIf *iface, const TIncrement * increment, IOError ** io, GError **error);
  gboolean (*increment_rows) (HbaseIf *iface, const GPtrArray * increments, IOError ** io, GError **error);
  gboolean (*delete_all_row_ts) (HbaseIf *iface, const Text tableName, const Text row, const gint64 timestamp, const GHashTable * attributes, IOError ** io, GError **error);
  gboolean (*scanner_open_with_scan) (HbaseIf *iface, ScannerID* _return, const Text tableName, const TScan * scan, const GHashTable * attributes, IOError ** io, GError **error);
  gboolean (*scanner_open) (HbaseIf *iface, ScannerID* _return, const Text tableName, const Text startRow, const GPtrArray * columns, const GHashTable * attributes, IOError ** io, GError **error);
  gboolean (*scanner_open_with_stop) (HbaseIf *iface, ScannerID* _return, const Text tableName, const Text startRow, const Text stopRow, const GPtrArray * columns, const GHashTable * attributes, IOError ** io, GError **error);
  gboolean (*scanner_open_with_prefix) (HbaseIf *iface, ScannerID* _return, const Text tableName, const Text startAndPrefix, const GPtrArray * columns, const GHashTable * attributes, IOError ** io, GError **error);
  gboolean (*scanner_open_ts) (HbaseIf *iface, ScannerID* _return, const Text tableName, const Text startRow, const GPtrArray * columns, const gint64 timestamp, const GHashTable * attributes, IOError ** io, GError **error);
  gboolean (*scanner_open_with_stop_ts) (HbaseIf *iface, ScannerID* _return, const Text tableName, const Text startRow, const Text stopRow, const GPtrArray * columns, const gint64 timestamp, const GHashTable * attributes, IOError ** io, GError **error);
  gboolean (*scanner_get) (HbaseIf *iface, GPtrArray ** _return, const ScannerID id, IOError ** io, IllegalArgument ** ia, GError **error);
  gboolean (*scanner_get_list) (HbaseIf *iface, GPtrArray ** _return, const ScannerID id, const gint32 nbRows, IOError ** io, IllegalArgument ** ia, GError **error);
  gboolean (*scanner_close) (HbaseIf *iface, const ScannerID id, IOError ** io, IllegalArgument ** ia, GError **error);
  gboolean (*get_row_or_before) (HbaseIf *iface, GPtrArray ** _return, const Text tableName, const Text row, const Text family, IOError ** io, GError **error);
  gboolean (*get_region_info) (HbaseIf *iface, TRegionInfo ** _return, const Text row, IOError ** io, GError **error);
  gboolean (*append) (HbaseIf *iface, GPtrArray ** _return, const TAppend * append, IOError ** io, GError **error);
  gboolean (*check_and_put) (HbaseIf *iface, gboolean* _return, const Text tableName, const Text row, const Text column, const Text value, const Mutation * mput, const GHashTable * attributes, IOError ** io, IllegalArgument ** ia, GError **error);
};
typedef struct _HbaseHandlerClass HbaseHandlerClass;

GType hbase_handler_get_type (void);
#define TYPE_HBASE_HANDLER (hbase_handler_get_type())
#define HBASE_HANDLER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_HBASE_HANDLER, HbaseHandler))
#define IS_HBASE_HANDLER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_HBASE_HANDLER))
#define HBASE_HANDLER_CLASS(c) (G_TYPE_CHECK_CLASS_CAST ((c), TYPE_HBASE_HANDLER, HbaseHandlerClass))
#define IS_HBASE_HANDLER_CLASS(c) (G_TYPE_CHECK_CLASS_TYPE ((c), TYPE_HBASE_HANDLER))
#define HBASE_HANDLER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_HBASE_HANDLER, HbaseHandlerClass))

gboolean hbase_handler_enable_table (HbaseIf *iface, const Bytes tableName, IOError ** io, GError **error);
gboolean hbase_handler_disable_table (HbaseIf *iface, const Bytes tableName, IOError ** io, GError **error);
gboolean hbase_handler_is_table_enabled (HbaseIf *iface, gboolean* _return, const Bytes tableName, IOError ** io, GError **error);
gboolean hbase_handler_compact (HbaseIf *iface, const Bytes tableNameOrRegionName, IOError ** io, GError **error);
gboolean hbase_handler_major_compact (HbaseIf *iface, const Bytes tableNameOrRegionName, IOError ** io, GError **error);
gboolean hbase_handler_get_table_names (HbaseIf *iface, GPtrArray ** _return, IOError ** io, GError **error);
gboolean hbase_handler_get_column_descriptors (HbaseIf *iface, GHashTable ** _return, const Text tableName, IOError ** io, GError **error);
gboolean hbase_handler_get_table_regions (HbaseIf *iface, GPtrArray ** _return, const Text tableName, IOError ** io, GError **error);
gboolean hbase_handler_create_table (HbaseIf *iface, const Text tableName, const GPtrArray * columnFamilies, IOError ** io, IllegalArgument ** ia, AlreadyExists ** exist, GError **error);
gboolean hbase_handler_delete_table (HbaseIf *iface, const Text tableName, IOError ** io, GError **error);
gboolean hbase_handler_get (HbaseIf *iface, GPtrArray ** _return, const Text tableName, const Text row, const Text column, const GHashTable * attributes, IOError ** io, GError **error);
gboolean hbase_handler_get_ver (HbaseIf *iface, GPtrArray ** _return, const Text tableName, const Text row, const Text column, const gint32 numVersions, const GHashTable * attributes, IOError ** io, GError **error);
gboolean hbase_handler_get_ver_ts (HbaseIf *iface, GPtrArray ** _return, const Text tableName, const Text row, const Text column, const gint64 timestamp, const gint32 numVersions, const GHashTable * attributes, IOError ** io, GError **error);
gboolean hbase_handler_get_row (HbaseIf *iface, GPtrArray ** _return, const Text tableName, const Text row, const GHashTable * attributes, IOError ** io, GError **error);
gboolean hbase_handler_get_row_with_columns (HbaseIf *iface, GPtrArray ** _return, const Text tableName, const Text row, const GPtrArray * columns, const GHashTable * attributes, IOError ** io, GError **error);
gboolean hbase_handler_get_row_ts (HbaseIf *iface, GPtrArray ** _return, const Text tableName, const Text row, const gint64 timestamp, const GHashTable * attributes, IOError ** io, GError **error);
gboolean hbase_handler_get_row_with_columns_ts (HbaseIf *iface, GPtrArray ** _return, const Text tableName, const Text row, const GPtrArray * columns, const gint64 timestamp, const GHashTable * attributes, IOError ** io, GError **error);
gboolean hbase_handler_get_rows (HbaseIf *iface, GPtrArray ** _return, const Text tableName, const GPtrArray * rows, const GHashTable * attributes, IOError ** io, GError **error);
gboolean hbase_handler_get_rows_with_columns (HbaseIf *iface, GPtrArray ** _return, const Text tableName, const GPtrArray * rows, const GPtrArray * columns, const GHashTable * attributes, IOError ** io, GError **error);
gboolean hbase_handler_get_rows_ts (HbaseIf *iface, GPtrArray ** _return, const Text tableName, const GPtrArray * rows, const gint64 timestamp, const GHashTable * attributes, IOError ** io, GError **error);
gboolean hbase_handler_get_rows_with_columns_ts (HbaseIf *iface, GPtrArray ** _return, const Text tableName, const GPtrArray * rows, const GPtrArray * columns, const gint64 timestamp, const GHashTable * attributes, IOError ** io, GError **error);
gboolean hbase_handler_mutate_row (HbaseIf *iface, const Text tableName, const Text row, const GPtrArray * mutations, const GHashTable * attributes, IOError ** io, IllegalArgument ** ia, GError **error);
gboolean hbase_handler_mutate_row_ts (HbaseIf *iface, const Text tableName, const Text row, const GPtrArray * mutations, const gint64 timestamp, const GHashTable * attributes, IOError ** io, IllegalArgument ** ia, GError **error);
gboolean hbase_handler_mutate_rows (HbaseIf *iface, const Text tableName, const GPtrArray * rowBatches, const GHashTable * attributes, IOError ** io, IllegalArgument ** ia, GError **error);
gboolean hbase_handler_mutate_rows_ts (HbaseIf *iface, const Text tableName, const GPtrArray * rowBatches, const gint64 timestamp, const GHashTable * attributes, IOError ** io, IllegalArgument ** ia, GError **error);
gboolean hbase_handler_atomic_increment (HbaseIf *iface, gint64* _return, const Text tableName, const Text row, const Text column, const gint64 value, IOError ** io, IllegalArgument ** ia, GError **error);
gboolean hbase_handler_delete_all (HbaseIf *iface, const Text tableName, const Text row, const Text column, const GHashTable * attributes, IOError ** io, GError **error);
gboolean hbase_handler_delete_all_ts (HbaseIf *iface, const Text tableName, const Text row, const Text column, const gint64 timestamp, const GHashTable * attributes, IOError ** io, GError **error);
gboolean hbase_handler_delete_all_row (HbaseIf *iface, const Text tableName, const Text row, const GHashTable * attributes, IOError ** io, GError **error);
gboolean hbase_handler_increment (HbaseIf *iface, const TIncrement * increment, IOError ** io, GError **error);
gboolean hbase_handler_increment_rows (HbaseIf *iface, const GPtrArray * increments, IOError ** io, GError **error);
gboolean hbase_handler_delete_all_row_ts (HbaseIf *iface, const Text tableName, const Text row, const gint64 timestamp, const GHashTable * attributes, IOError ** io, GError **error);
gboolean hbase_handler_scanner_open_with_scan (HbaseIf *iface, ScannerID* _return, const Text tableName, const TScan * scan, const GHashTable * attributes, IOError ** io, GError **error);
gboolean hbase_handler_scanner_open (HbaseIf *iface, ScannerID* _return, const Text tableName, const Text startRow, const GPtrArray * columns, const GHashTable * attributes, IOError ** io, GError **error);
gboolean hbase_handler_scanner_open_with_stop (HbaseIf *iface, ScannerID* _return, const Text tableName, const Text startRow, const Text stopRow, const GPtrArray * columns, const GHashTable * attributes, IOError ** io, GError **error);
gboolean hbase_handler_scanner_open_with_prefix (HbaseIf *iface, ScannerID* _return, const Text tableName, const Text startAndPrefix, const GPtrArray * columns, const GHashTable * attributes, IOError ** io, GError **error);
gboolean hbase_handler_scanner_open_ts (HbaseIf *iface, ScannerID* _return, const Text tableName, const Text startRow, const GPtrArray * columns, const gint64 timestamp, const GHashTable * attributes, IOError ** io, GError **error);
gboolean hbase_handler_scanner_open_with_stop_ts (HbaseIf *iface, ScannerID* _return, const Text tableName, const Text startRow, const Text stopRow, const GPtrArray * columns, const gint64 timestamp, const GHashTable * attributes, IOError ** io, GError **error);
gboolean hbase_handler_scanner_get (HbaseIf *iface, GPtrArray ** _return, const ScannerID id, IOError ** io, IllegalArgument ** ia, GError **error);
gboolean hbase_handler_scanner_get_list (HbaseIf *iface, GPtrArray ** _return, const ScannerID id, const gint32 nbRows, IOError ** io, IllegalArgument ** ia, GError **error);
gboolean hbase_handler_scanner_close (HbaseIf *iface, const ScannerID id, IOError ** io, IllegalArgument ** ia, GError **error);
gboolean hbase_handler_get_row_or_before (HbaseIf *iface, GPtrArray ** _return, const Text tableName, const Text row, const Text family, IOError ** io, GError **error);
gboolean hbase_handler_get_region_info (HbaseIf *iface, TRegionInfo ** _return, const Text row, IOError ** io, GError **error);
gboolean hbase_handler_append (HbaseIf *iface, GPtrArray ** _return, const TAppend * append, IOError ** io, GError **error);
gboolean hbase_handler_check_and_put (HbaseIf *iface, gboolean* _return, const Text tableName, const Text row, const Text column, const Text value, const Mutation * mput, const GHashTable * attributes, IOError ** io, IllegalArgument ** ia, GError **error);

/* Hbase processor */
struct _HbaseProcessor
{
  ThriftDispatchProcessor parent;

  /* protected */
  HbaseHandler *handler;
  GHashTable *process_map;
};
typedef struct _HbaseProcessor HbaseProcessor;

struct _HbaseProcessorClass
{
  ThriftDispatchProcessorClass parent;

  /* protected */
  gboolean (*dispatch_call) (ThriftDispatchProcessor *processor,
                             ThriftProtocol *in,
                             ThriftProtocol *out,
                             gchar *fname,
                             gint32 seqid,
                             GError **error);
};
typedef struct _HbaseProcessorClass HbaseProcessorClass;

GType hbase_processor_get_type (void);
#define TYPE_HBASE_PROCESSOR (hbase_processor_get_type())
#define HBASE_PROCESSOR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_HBASE_PROCESSOR, HbaseProcessor))
#define IS_HBASE_PROCESSOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_HBASE_PROCESSOR))
#define HBASE_PROCESSOR_CLASS(c) (G_TYPE_CHECK_CLASS_CAST ((c), TYPE_HBASE_PROCESSOR, HbaseProcessorClass))
#define IS_HBASE_PROCESSOR_CLASS(c) (G_TYPE_CHECK_CLASS_TYPE ((c), TYPE_HBASE_PROCESSOR))
#define HBASE_PROCESSOR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_HBASE_PROCESSOR, HbaseProcessorClass))

#endif /* HBASE_H */
