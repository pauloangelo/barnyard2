/**
 * Autogenerated by Thrift Compiler (0.10.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

#include <math.h>

#include "hbase_types.h"
#include <thrift/c_glib/thrift.h>

enum _TCellProperties
{
  PROP_T_CELL_0,
  PROP_T_CELL_VALUE,
  PROP_T_CELL_TIMESTAMP
};

/* reads a t_cell object */
static gint32
t_cell_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TCell * this_object = T_CELL(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->value != NULL)
          {
            g_free(this_object->value);
            this_object->value = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->value = g_byte_array_new();
          g_byte_array_append (this_object->value, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_value = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->timestamp, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_timestamp = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_cell_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TCell * this_object = T_CELL(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "TCell", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "value", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->value ? ((GByteArray *) this_object->value)->data : NULL, this_object->value ? ((GByteArray *) this_object->value)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "timestamp", T_I64, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->timestamp, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_cell_set_property (GObject *object,
                     guint property_id,
                     const GValue *value,
                     GParamSpec *pspec)
{
  TCell *self = T_CELL (object);

  switch (property_id)
  {
    case PROP_T_CELL_VALUE:
      if (self->value != NULL)
        g_byte_array_unref (self->value);
      self->value = g_value_dup_boxed (value);
      self->__isset_value = TRUE;
      break;

    case PROP_T_CELL_TIMESTAMP:
      self->timestamp = g_value_get_int64 (value);
      self->__isset_timestamp = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_cell_get_property (GObject *object,
                     guint property_id,
                     GValue *value,
                     GParamSpec *pspec)
{
  TCell *self = T_CELL (object);

  switch (property_id)
  {
    case PROP_T_CELL_VALUE:
      g_value_set_boxed (value, self->value);
      break;

    case PROP_T_CELL_TIMESTAMP:
      g_value_set_int64 (value, self->timestamp);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_cell_instance_init (TCell * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->value = NULL;
  object->__isset_value = FALSE;
  object->timestamp = 0;
  object->__isset_timestamp = FALSE;
}

static void 
t_cell_finalize (GObject *object)
{
  TCell *tobject = T_CELL (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->value != NULL)
  {
    thrift_string_free(tobject->value);
    tobject->value = NULL;
  }
}

static void
t_cell_class_init (TCellClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_cell_read;
  struct_class->write = t_cell_write;

  gobject_class->finalize = t_cell_finalize;
  gobject_class->get_property = t_cell_get_property;
  gobject_class->set_property = t_cell_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_CELL_VALUE,
     g_param_spec_boxed ("value",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_CELL_TIMESTAMP,
     g_param_spec_int64 ("timestamp",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));
}

GType
t_cell_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TCellClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_cell_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TCell),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_cell_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TCellType",
                                   &type_info, 0);
  }

  return type;
}

enum _ColumnDescriptorProperties
{
  PROP_COLUMN_DESCRIPTOR_0,
  PROP_COLUMN_DESCRIPTOR_NAME,
  PROP_COLUMN_DESCRIPTOR_MAX_VERSIONS,
  PROP_COLUMN_DESCRIPTOR_COMPRESSION,
  PROP_COLUMN_DESCRIPTOR_IN_MEMORY,
  PROP_COLUMN_DESCRIPTOR_BLOOM_FILTER_TYPE,
  PROP_COLUMN_DESCRIPTOR_BLOOM_FILTER_VECTOR_SIZE,
  PROP_COLUMN_DESCRIPTOR_BLOOM_FILTER_NB_HASHES,
  PROP_COLUMN_DESCRIPTOR_BLOCK_CACHE_ENABLED,
  PROP_COLUMN_DESCRIPTOR_TIME_TO_LIVE
};

/* reads a column_descriptor object */
static gint32
column_descriptor_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ColumnDescriptor * this_object = COLUMN_DESCRIPTOR(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->name != NULL)
          {
            g_free(this_object->name);
            this_object->name = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->name = g_byte_array_new();
          g_byte_array_append (this_object->name, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_name = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->maxVersions, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_maxVersions = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if (this_object->compression != NULL)
          {
            g_free(this_object->compression);
            this_object->compression = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->compression, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_compression = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->inMemory, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_inMemory = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_STRING)
        {
          if (this_object->bloomFilterType != NULL)
          {
            g_free(this_object->bloomFilterType);
            this_object->bloomFilterType = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->bloomFilterType, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_bloomFilterType = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->bloomFilterVectorSize, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_bloomFilterVectorSize = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 7:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->bloomFilterNbHashes, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_bloomFilterNbHashes = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 8:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->blockCacheEnabled, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_blockCacheEnabled = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 9:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->timeToLive, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_timeToLive = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
column_descriptor_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ColumnDescriptor * this_object = COLUMN_DESCRIPTOR(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ColumnDescriptor", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "name", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->name ? ((GByteArray *) this_object->name)->data : NULL, this_object->name ? ((GByteArray *) this_object->name)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "maxVersions", T_I32, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->maxVersions, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "compression", T_STRING, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->compression, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "inMemory", T_BOOL, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_bool (protocol, this_object->inMemory, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "bloomFilterType", T_STRING, 5, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->bloomFilterType, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "bloomFilterVectorSize", T_I32, 6, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->bloomFilterVectorSize, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "bloomFilterNbHashes", T_I32, 7, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->bloomFilterNbHashes, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "blockCacheEnabled", T_BOOL, 8, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_bool (protocol, this_object->blockCacheEnabled, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "timeToLive", T_I32, 9, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->timeToLive, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
column_descriptor_set_property (GObject *object,
                                guint property_id,
                                const GValue *value,
                                GParamSpec *pspec)
{
  ColumnDescriptor *self = COLUMN_DESCRIPTOR (object);

  switch (property_id)
  {
    case PROP_COLUMN_DESCRIPTOR_NAME:
      if (self->name != NULL)
        g_byte_array_unref (self->name);
      self->name = g_value_dup_boxed (value);
      self->__isset_name = TRUE;
      break;

    case PROP_COLUMN_DESCRIPTOR_MAX_VERSIONS:
      self->maxVersions = g_value_get_int (value);
      self->__isset_maxVersions = TRUE;
      break;

    case PROP_COLUMN_DESCRIPTOR_COMPRESSION:
      if (self->compression != NULL)
        g_free (self->compression);
      self->compression = g_value_dup_string (value);
      self->__isset_compression = TRUE;
      break;

    case PROP_COLUMN_DESCRIPTOR_IN_MEMORY:
      self->inMemory = g_value_get_boolean (value);
      self->__isset_inMemory = TRUE;
      break;

    case PROP_COLUMN_DESCRIPTOR_BLOOM_FILTER_TYPE:
      if (self->bloomFilterType != NULL)
        g_free (self->bloomFilterType);
      self->bloomFilterType = g_value_dup_string (value);
      self->__isset_bloomFilterType = TRUE;
      break;

    case PROP_COLUMN_DESCRIPTOR_BLOOM_FILTER_VECTOR_SIZE:
      self->bloomFilterVectorSize = g_value_get_int (value);
      self->__isset_bloomFilterVectorSize = TRUE;
      break;

    case PROP_COLUMN_DESCRIPTOR_BLOOM_FILTER_NB_HASHES:
      self->bloomFilterNbHashes = g_value_get_int (value);
      self->__isset_bloomFilterNbHashes = TRUE;
      break;

    case PROP_COLUMN_DESCRIPTOR_BLOCK_CACHE_ENABLED:
      self->blockCacheEnabled = g_value_get_boolean (value);
      self->__isset_blockCacheEnabled = TRUE;
      break;

    case PROP_COLUMN_DESCRIPTOR_TIME_TO_LIVE:
      self->timeToLive = g_value_get_int (value);
      self->__isset_timeToLive = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
column_descriptor_get_property (GObject *object,
                                guint property_id,
                                GValue *value,
                                GParamSpec *pspec)
{
  ColumnDescriptor *self = COLUMN_DESCRIPTOR (object);

  switch (property_id)
  {
    case PROP_COLUMN_DESCRIPTOR_NAME:
      g_value_set_boxed (value, self->name);
      break;

    case PROP_COLUMN_DESCRIPTOR_MAX_VERSIONS:
      g_value_set_int (value, self->maxVersions);
      break;

    case PROP_COLUMN_DESCRIPTOR_COMPRESSION:
      g_value_set_string (value, self->compression);
      break;

    case PROP_COLUMN_DESCRIPTOR_IN_MEMORY:
      g_value_set_boolean (value, self->inMemory);
      break;

    case PROP_COLUMN_DESCRIPTOR_BLOOM_FILTER_TYPE:
      g_value_set_string (value, self->bloomFilterType);
      break;

    case PROP_COLUMN_DESCRIPTOR_BLOOM_FILTER_VECTOR_SIZE:
      g_value_set_int (value, self->bloomFilterVectorSize);
      break;

    case PROP_COLUMN_DESCRIPTOR_BLOOM_FILTER_NB_HASHES:
      g_value_set_int (value, self->bloomFilterNbHashes);
      break;

    case PROP_COLUMN_DESCRIPTOR_BLOCK_CACHE_ENABLED:
      g_value_set_boolean (value, self->blockCacheEnabled);
      break;

    case PROP_COLUMN_DESCRIPTOR_TIME_TO_LIVE:
      g_value_set_int (value, self->timeToLive);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
column_descriptor_instance_init (ColumnDescriptor * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->name = NULL;
  object->__isset_name = FALSE;
  object->maxVersions = 3;
  object->__isset_maxVersions = FALSE;
  object->compression = g_strdup ("NONE");
  object->__isset_compression = FALSE;
  object->inMemory = 0;
  object->__isset_inMemory = FALSE;
  object->bloomFilterType = g_strdup ("NONE");
  object->__isset_bloomFilterType = FALSE;
  object->bloomFilterVectorSize = 0;
  object->__isset_bloomFilterVectorSize = FALSE;
  object->bloomFilterNbHashes = 0;
  object->__isset_bloomFilterNbHashes = FALSE;
  object->blockCacheEnabled = 0;
  object->__isset_blockCacheEnabled = FALSE;
  object->timeToLive = -1;
  object->__isset_timeToLive = FALSE;
}

static void 
column_descriptor_finalize (GObject *object)
{
  ColumnDescriptor *tobject = COLUMN_DESCRIPTOR (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->name != NULL)
  {
    thrift_string_free(tobject->name);
    tobject->name = NULL;
  }
  if (tobject->compression != NULL)
  {
    g_free(tobject->compression);
    tobject->compression = NULL;
  }
  if (tobject->bloomFilterType != NULL)
  {
    g_free(tobject->bloomFilterType);
    tobject->bloomFilterType = NULL;
  }
}

static void
column_descriptor_class_init (ColumnDescriptorClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = column_descriptor_read;
  struct_class->write = column_descriptor_write;

  gobject_class->finalize = column_descriptor_finalize;
  gobject_class->get_property = column_descriptor_get_property;
  gobject_class->set_property = column_descriptor_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_COLUMN_DESCRIPTOR_NAME,
     g_param_spec_boxed ("name",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_COLUMN_DESCRIPTOR_MAX_VERSIONS,
     g_param_spec_int ("maxVersions",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       3,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_COLUMN_DESCRIPTOR_COMPRESSION,
     g_param_spec_string ("compression",
                          NULL,
                          NULL,
                          "NONE",
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_COLUMN_DESCRIPTOR_IN_MEMORY,
     g_param_spec_boolean ("inMemory",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_COLUMN_DESCRIPTOR_BLOOM_FILTER_TYPE,
     g_param_spec_string ("bloomFilterType",
                          NULL,
                          NULL,
                          "NONE",
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_COLUMN_DESCRIPTOR_BLOOM_FILTER_VECTOR_SIZE,
     g_param_spec_int ("bloomFilterVectorSize",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_COLUMN_DESCRIPTOR_BLOOM_FILTER_NB_HASHES,
     g_param_spec_int ("bloomFilterNbHashes",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_COLUMN_DESCRIPTOR_BLOCK_CACHE_ENABLED,
     g_param_spec_boolean ("blockCacheEnabled",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_COLUMN_DESCRIPTOR_TIME_TO_LIVE,
     g_param_spec_int ("timeToLive",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       -1,
                       G_PARAM_READWRITE));
}

GType
column_descriptor_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ColumnDescriptorClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) column_descriptor_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ColumnDescriptor),
      0, /* n_preallocs */
      (GInstanceInitFunc) column_descriptor_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ColumnDescriptorType",
                                   &type_info, 0);
  }

  return type;
}

enum _TRegionInfoProperties
{
  PROP_T_REGION_INFO_0,
  PROP_T_REGION_INFO_START_KEY,
  PROP_T_REGION_INFO_END_KEY,
  PROP_T_REGION_INFO_ID,
  PROP_T_REGION_INFO_NAME,
  PROP_T_REGION_INFO_VERSION,
  PROP_T_REGION_INFO_SERVER_NAME,
  PROP_T_REGION_INFO_PORT
};

/* reads a t_region_info object */
static gint32
t_region_info_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TRegionInfo * this_object = T_REGION_INFO(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->startKey != NULL)
          {
            g_free(this_object->startKey);
            this_object->startKey = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->startKey = g_byte_array_new();
          g_byte_array_append (this_object->startKey, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_startKey = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->endKey != NULL)
          {
            g_free(this_object->endKey);
            this_object->endKey = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->endKey = g_byte_array_new();
          g_byte_array_append (this_object->endKey, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_endKey = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->id, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_id = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_STRING)
        {
          if (this_object->name != NULL)
          {
            g_free(this_object->name);
            this_object->name = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->name = g_byte_array_new();
          g_byte_array_append (this_object->name, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_name = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_BYTE)
        {
          if ((ret = thrift_protocol_read_byte (protocol, &this_object->version, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_version = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_STRING)
        {
          if (this_object->serverName != NULL)
          {
            g_free(this_object->serverName);
            this_object->serverName = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->serverName = g_byte_array_new();
          g_byte_array_append (this_object->serverName, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_serverName = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 7:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->port, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_port = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_region_info_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TRegionInfo * this_object = T_REGION_INFO(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "TRegionInfo", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "startKey", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->startKey ? ((GByteArray *) this_object->startKey)->data : NULL, this_object->startKey ? ((GByteArray *) this_object->startKey)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "endKey", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->endKey ? ((GByteArray *) this_object->endKey)->data : NULL, this_object->endKey ? ((GByteArray *) this_object->endKey)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "id", T_I64, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->id, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "name", T_STRING, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->name ? ((GByteArray *) this_object->name)->data : NULL, this_object->name ? ((GByteArray *) this_object->name)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "version", T_BYTE, 5, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_byte (protocol, this_object->version, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "serverName", T_STRING, 6, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->serverName ? ((GByteArray *) this_object->serverName)->data : NULL, this_object->serverName ? ((GByteArray *) this_object->serverName)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "port", T_I32, 7, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->port, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_region_info_set_property (GObject *object,
                            guint property_id,
                            const GValue *value,
                            GParamSpec *pspec)
{
  TRegionInfo *self = T_REGION_INFO (object);

  switch (property_id)
  {
    case PROP_T_REGION_INFO_START_KEY:
      if (self->startKey != NULL)
        g_byte_array_unref (self->startKey);
      self->startKey = g_value_dup_boxed (value);
      self->__isset_startKey = TRUE;
      break;

    case PROP_T_REGION_INFO_END_KEY:
      if (self->endKey != NULL)
        g_byte_array_unref (self->endKey);
      self->endKey = g_value_dup_boxed (value);
      self->__isset_endKey = TRUE;
      break;

    case PROP_T_REGION_INFO_ID:
      self->id = g_value_get_int64 (value);
      self->__isset_id = TRUE;
      break;

    case PROP_T_REGION_INFO_NAME:
      if (self->name != NULL)
        g_byte_array_unref (self->name);
      self->name = g_value_dup_boxed (value);
      self->__isset_name = TRUE;
      break;

    case PROP_T_REGION_INFO_VERSION:
      self->version = g_value_get_int (value);
      self->__isset_version = TRUE;
      break;

    case PROP_T_REGION_INFO_SERVER_NAME:
      if (self->serverName != NULL)
        g_byte_array_unref (self->serverName);
      self->serverName = g_value_dup_boxed (value);
      self->__isset_serverName = TRUE;
      break;

    case PROP_T_REGION_INFO_PORT:
      self->port = g_value_get_int (value);
      self->__isset_port = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_region_info_get_property (GObject *object,
                            guint property_id,
                            GValue *value,
                            GParamSpec *pspec)
{
  TRegionInfo *self = T_REGION_INFO (object);

  switch (property_id)
  {
    case PROP_T_REGION_INFO_START_KEY:
      g_value_set_boxed (value, self->startKey);
      break;

    case PROP_T_REGION_INFO_END_KEY:
      g_value_set_boxed (value, self->endKey);
      break;

    case PROP_T_REGION_INFO_ID:
      g_value_set_int64 (value, self->id);
      break;

    case PROP_T_REGION_INFO_NAME:
      g_value_set_boxed (value, self->name);
      break;

    case PROP_T_REGION_INFO_VERSION:
      g_value_set_int (value, self->version);
      break;

    case PROP_T_REGION_INFO_SERVER_NAME:
      g_value_set_boxed (value, self->serverName);
      break;

    case PROP_T_REGION_INFO_PORT:
      g_value_set_int (value, self->port);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_region_info_instance_init (TRegionInfo * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->startKey = NULL;
  object->__isset_startKey = FALSE;
  object->endKey = NULL;
  object->__isset_endKey = FALSE;
  object->id = 0;
  object->__isset_id = FALSE;
  object->name = NULL;
  object->__isset_name = FALSE;
  object->version = 0;
  object->__isset_version = FALSE;
  object->serverName = NULL;
  object->__isset_serverName = FALSE;
  object->port = 0;
  object->__isset_port = FALSE;
}

static void 
t_region_info_finalize (GObject *object)
{
  TRegionInfo *tobject = T_REGION_INFO (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->startKey != NULL)
  {
    thrift_string_free(tobject->startKey);
    tobject->startKey = NULL;
  }
  if (tobject->endKey != NULL)
  {
    thrift_string_free(tobject->endKey);
    tobject->endKey = NULL;
  }
  if (tobject->name != NULL)
  {
    thrift_string_free(tobject->name);
    tobject->name = NULL;
  }
  if (tobject->serverName != NULL)
  {
    thrift_string_free(tobject->serverName);
    tobject->serverName = NULL;
  }
}

static void
t_region_info_class_init (TRegionInfoClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_region_info_read;
  struct_class->write = t_region_info_write;

  gobject_class->finalize = t_region_info_finalize;
  gobject_class->get_property = t_region_info_get_property;
  gobject_class->set_property = t_region_info_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_REGION_INFO_START_KEY,
     g_param_spec_boxed ("startKey",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_REGION_INFO_END_KEY,
     g_param_spec_boxed ("endKey",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_REGION_INFO_ID,
     g_param_spec_int64 ("id",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_REGION_INFO_NAME,
     g_param_spec_boxed ("name",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_REGION_INFO_VERSION,
     g_param_spec_int ("version",
                       NULL,
                       NULL,
                       G_MININT8,
                       G_MAXINT8,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_REGION_INFO_SERVER_NAME,
     g_param_spec_boxed ("serverName",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_REGION_INFO_PORT,
     g_param_spec_int ("port",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
t_region_info_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TRegionInfoClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_region_info_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TRegionInfo),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_region_info_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TRegionInfoType",
                                   &type_info, 0);
  }

  return type;
}

enum _MutationProperties
{
  PROP_MUTATION_0,
  PROP_MUTATION_IS_DELETE,
  PROP_MUTATION_COLUMN,
  PROP_MUTATION_VALUE,
  PROP_MUTATION_WRITE_TO_W_A_L
};

/* reads a mutation object */
static gint32
mutation_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  Mutation * this_object = MUTATION(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->isDelete, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_isDelete = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->column != NULL)
          {
            g_free(this_object->column);
            this_object->column = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->column = g_byte_array_new();
          g_byte_array_append (this_object->column, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_column = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if (this_object->value != NULL)
          {
            g_free(this_object->value);
            this_object->value = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->value = g_byte_array_new();
          g_byte_array_append (this_object->value, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_value = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->writeToWAL, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_writeToWAL = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
mutation_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  Mutation * this_object = MUTATION(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "Mutation", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "isDelete", T_BOOL, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_bool (protocol, this_object->isDelete, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "column", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->column ? ((GByteArray *) this_object->column)->data : NULL, this_object->column ? ((GByteArray *) this_object->column)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "value", T_STRING, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->value ? ((GByteArray *) this_object->value)->data : NULL, this_object->value ? ((GByteArray *) this_object->value)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "writeToWAL", T_BOOL, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_bool (protocol, this_object->writeToWAL, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
mutation_set_property (GObject *object,
                       guint property_id,
                       const GValue *value,
                       GParamSpec *pspec)
{
  Mutation *self = MUTATION (object);

  switch (property_id)
  {
    case PROP_MUTATION_IS_DELETE:
      self->isDelete = g_value_get_boolean (value);
      self->__isset_isDelete = TRUE;
      break;

    case PROP_MUTATION_COLUMN:
      if (self->column != NULL)
        g_byte_array_unref (self->column);
      self->column = g_value_dup_boxed (value);
      self->__isset_column = TRUE;
      break;

    case PROP_MUTATION_VALUE:
      if (self->value != NULL)
        g_byte_array_unref (self->value);
      self->value = g_value_dup_boxed (value);
      self->__isset_value = TRUE;
      break;

    case PROP_MUTATION_WRITE_TO_W_A_L:
      self->writeToWAL = g_value_get_boolean (value);
      self->__isset_writeToWAL = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
mutation_get_property (GObject *object,
                       guint property_id,
                       GValue *value,
                       GParamSpec *pspec)
{
  Mutation *self = MUTATION (object);

  switch (property_id)
  {
    case PROP_MUTATION_IS_DELETE:
      g_value_set_boolean (value, self->isDelete);
      break;

    case PROP_MUTATION_COLUMN:
      g_value_set_boxed (value, self->column);
      break;

    case PROP_MUTATION_VALUE:
      g_value_set_boxed (value, self->value);
      break;

    case PROP_MUTATION_WRITE_TO_W_A_L:
      g_value_set_boolean (value, self->writeToWAL);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
mutation_instance_init (Mutation * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->isDelete = 0;
  object->__isset_isDelete = FALSE;
  object->column = NULL;
  object->__isset_column = FALSE;
  object->value = NULL;
  object->__isset_value = FALSE;
  object->writeToWAL = 1;
  object->__isset_writeToWAL = FALSE;
}

static void 
mutation_finalize (GObject *object)
{
  Mutation *tobject = MUTATION (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->column != NULL)
  {
    thrift_string_free(tobject->column);
    tobject->column = NULL;
  }
  if (tobject->value != NULL)
  {
    thrift_string_free(tobject->value);
    tobject->value = NULL;
  }
}

static void
mutation_class_init (MutationClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = mutation_read;
  struct_class->write = mutation_write;

  gobject_class->finalize = mutation_finalize;
  gobject_class->get_property = mutation_get_property;
  gobject_class->set_property = mutation_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_MUTATION_IS_DELETE,
     g_param_spec_boolean ("isDelete",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_MUTATION_COLUMN,
     g_param_spec_boxed ("column",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_MUTATION_VALUE,
     g_param_spec_boxed ("value",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_MUTATION_WRITE_TO_W_A_L,
     g_param_spec_boolean ("writeToWAL",
                           NULL,
                           NULL,
                           TRUE,
                           G_PARAM_READWRITE));
}

GType
mutation_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (MutationClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) mutation_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (Mutation),
      0, /* n_preallocs */
      (GInstanceInitFunc) mutation_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "MutationType",
                                   &type_info, 0);
  }

  return type;
}

enum _BatchMutationProperties
{
  PROP_BATCH_MUTATION_0,
  PROP_BATCH_MUTATION_ROW,
  PROP_BATCH_MUTATION_MUTATIONS
};

/* reads a batch_mutation object */
static gint32
batch_mutation_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  BatchMutation * this_object = BATCH_MUTATION(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->row != NULL)
          {
            g_free(this_object->row);
            this_object->row = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->row = g_byte_array_new();
          g_byte_array_append (this_object->row, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_row = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              Mutation * _elem0 = NULL;
              if ( _elem0 != NULL)
              {
                g_object_unref (_elem0);
              }
              _elem0 = g_object_new (TYPE_MUTATION, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem0), protocol, error)) < 0)
              {
                g_object_unref (_elem0);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->mutations, _elem0);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_mutations = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
batch_mutation_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  BatchMutation * this_object = BATCH_MUTATION(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "BatchMutation", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "row", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->row ? ((GByteArray *) this_object->row)->data : NULL, this_object->row ? ((GByteArray *) this_object->row)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "mutations", T_LIST, 2, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i1;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->mutations ? this_object->mutations->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i1 = 0; i1 < (this_object->mutations ? this_object->mutations->len : 0); i1++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->mutations, i1))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
batch_mutation_set_property (GObject *object,
                             guint property_id,
                             const GValue *value,
                             GParamSpec *pspec)
{
  BatchMutation *self = BATCH_MUTATION (object);

  switch (property_id)
  {
    case PROP_BATCH_MUTATION_ROW:
      if (self->row != NULL)
        g_byte_array_unref (self->row);
      self->row = g_value_dup_boxed (value);
      self->__isset_row = TRUE;
      break;

    case PROP_BATCH_MUTATION_MUTATIONS:
      if (self->mutations != NULL)
        g_ptr_array_unref (self->mutations);
      self->mutations = g_value_dup_boxed (value);
      self->__isset_mutations = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
batch_mutation_get_property (GObject *object,
                             guint property_id,
                             GValue *value,
                             GParamSpec *pspec)
{
  BatchMutation *self = BATCH_MUTATION (object);

  switch (property_id)
  {
    case PROP_BATCH_MUTATION_ROW:
      g_value_set_boxed (value, self->row);
      break;

    case PROP_BATCH_MUTATION_MUTATIONS:
      g_value_set_boxed (value, self->mutations);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
batch_mutation_instance_init (BatchMutation * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->row = NULL;
  object->__isset_row = FALSE;
  object->mutations = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_mutations = FALSE;
}

static void 
batch_mutation_finalize (GObject *object)
{
  BatchMutation *tobject = BATCH_MUTATION (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->row != NULL)
  {
    thrift_string_free(tobject->row);
    tobject->row = NULL;
  }
  if (tobject->mutations != NULL)
  {
    g_ptr_array_unref (tobject->mutations);
    tobject->mutations = NULL;
  }
}

static void
batch_mutation_class_init (BatchMutationClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = batch_mutation_read;
  struct_class->write = batch_mutation_write;

  gobject_class->finalize = batch_mutation_finalize;
  gobject_class->get_property = batch_mutation_get_property;
  gobject_class->set_property = batch_mutation_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_BATCH_MUTATION_ROW,
     g_param_spec_boxed ("row",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_BATCH_MUTATION_MUTATIONS,
     g_param_spec_boxed ("mutations",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
batch_mutation_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (BatchMutationClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) batch_mutation_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (BatchMutation),
      0, /* n_preallocs */
      (GInstanceInitFunc) batch_mutation_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "BatchMutationType",
                                   &type_info, 0);
  }

  return type;
}

enum _TIncrementProperties
{
  PROP_T_INCREMENT_0,
  PROP_T_INCREMENT_TABLE,
  PROP_T_INCREMENT_ROW,
  PROP_T_INCREMENT_COLUMN,
  PROP_T_INCREMENT_AMMOUNT
};

/* reads a t_increment object */
static gint32
t_increment_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TIncrement * this_object = T_INCREMENT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->table != NULL)
          {
            g_free(this_object->table);
            this_object->table = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->table = g_byte_array_new();
          g_byte_array_append (this_object->table, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_table = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->row != NULL)
          {
            g_free(this_object->row);
            this_object->row = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->row = g_byte_array_new();
          g_byte_array_append (this_object->row, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_row = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if (this_object->column != NULL)
          {
            g_free(this_object->column);
            this_object->column = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->column = g_byte_array_new();
          g_byte_array_append (this_object->column, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_column = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->ammount, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_ammount = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_increment_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TIncrement * this_object = T_INCREMENT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "TIncrement", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "table", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->table ? ((GByteArray *) this_object->table)->data : NULL, this_object->table ? ((GByteArray *) this_object->table)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "row", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->row ? ((GByteArray *) this_object->row)->data : NULL, this_object->row ? ((GByteArray *) this_object->row)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "column", T_STRING, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->column ? ((GByteArray *) this_object->column)->data : NULL, this_object->column ? ((GByteArray *) this_object->column)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "ammount", T_I64, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->ammount, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_increment_set_property (GObject *object,
                          guint property_id,
                          const GValue *value,
                          GParamSpec *pspec)
{
  TIncrement *self = T_INCREMENT (object);

  switch (property_id)
  {
    case PROP_T_INCREMENT_TABLE:
      if (self->table != NULL)
        g_byte_array_unref (self->table);
      self->table = g_value_dup_boxed (value);
      self->__isset_table = TRUE;
      break;

    case PROP_T_INCREMENT_ROW:
      if (self->row != NULL)
        g_byte_array_unref (self->row);
      self->row = g_value_dup_boxed (value);
      self->__isset_row = TRUE;
      break;

    case PROP_T_INCREMENT_COLUMN:
      if (self->column != NULL)
        g_byte_array_unref (self->column);
      self->column = g_value_dup_boxed (value);
      self->__isset_column = TRUE;
      break;

    case PROP_T_INCREMENT_AMMOUNT:
      self->ammount = g_value_get_int64 (value);
      self->__isset_ammount = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_increment_get_property (GObject *object,
                          guint property_id,
                          GValue *value,
                          GParamSpec *pspec)
{
  TIncrement *self = T_INCREMENT (object);

  switch (property_id)
  {
    case PROP_T_INCREMENT_TABLE:
      g_value_set_boxed (value, self->table);
      break;

    case PROP_T_INCREMENT_ROW:
      g_value_set_boxed (value, self->row);
      break;

    case PROP_T_INCREMENT_COLUMN:
      g_value_set_boxed (value, self->column);
      break;

    case PROP_T_INCREMENT_AMMOUNT:
      g_value_set_int64 (value, self->ammount);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_increment_instance_init (TIncrement * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->table = NULL;
  object->__isset_table = FALSE;
  object->row = NULL;
  object->__isset_row = FALSE;
  object->column = NULL;
  object->__isset_column = FALSE;
  object->ammount = 0;
  object->__isset_ammount = FALSE;
}

static void 
t_increment_finalize (GObject *object)
{
  TIncrement *tobject = T_INCREMENT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->table != NULL)
  {
    thrift_string_free(tobject->table);
    tobject->table = NULL;
  }
  if (tobject->row != NULL)
  {
    thrift_string_free(tobject->row);
    tobject->row = NULL;
  }
  if (tobject->column != NULL)
  {
    thrift_string_free(tobject->column);
    tobject->column = NULL;
  }
}

static void
t_increment_class_init (TIncrementClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_increment_read;
  struct_class->write = t_increment_write;

  gobject_class->finalize = t_increment_finalize;
  gobject_class->get_property = t_increment_get_property;
  gobject_class->set_property = t_increment_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_INCREMENT_TABLE,
     g_param_spec_boxed ("table",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_INCREMENT_ROW,
     g_param_spec_boxed ("row",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_INCREMENT_COLUMN,
     g_param_spec_boxed ("column",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_INCREMENT_AMMOUNT,
     g_param_spec_int64 ("ammount",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));
}

GType
t_increment_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TIncrementClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_increment_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TIncrement),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_increment_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TIncrementType",
                                   &type_info, 0);
  }

  return type;
}

enum _TColumnProperties
{
  PROP_T_COLUMN_0,
  PROP_T_COLUMN_COLUMN_NAME,
  PROP_T_COLUMN_CELL
};

/* reads a t_column object */
static gint32
t_column_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TColumn * this_object = T_COLUMN(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->columnName != NULL)
          {
            g_free(this_object->columnName);
            this_object->columnName = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->columnName = g_byte_array_new();
          g_byte_array_append (this_object->columnName, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_columnName = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->cell), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_cell = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_column_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TColumn * this_object = T_COLUMN(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "TColumn", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "columnName", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->columnName ? ((GByteArray *) this_object->columnName)->data : NULL, this_object->columnName ? ((GByteArray *) this_object->columnName)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "cell", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->cell), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_column_set_property (GObject *object,
                       guint property_id,
                       const GValue *value,
                       GParamSpec *pspec)
{
  TColumn *self = T_COLUMN (object);

  switch (property_id)
  {
    case PROP_T_COLUMN_COLUMN_NAME:
      if (self->columnName != NULL)
        g_byte_array_unref (self->columnName);
      self->columnName = g_value_dup_boxed (value);
      self->__isset_columnName = TRUE;
      break;

    case PROP_T_COLUMN_CELL:
      if (self->cell != NULL)
        g_object_unref (self->cell);
      self->cell = g_value_dup_object (value);
      self->__isset_cell = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_column_get_property (GObject *object,
                       guint property_id,
                       GValue *value,
                       GParamSpec *pspec)
{
  TColumn *self = T_COLUMN (object);

  switch (property_id)
  {
    case PROP_T_COLUMN_COLUMN_NAME:
      g_value_set_boxed (value, self->columnName);
      break;

    case PROP_T_COLUMN_CELL:
      g_value_set_object (value, self->cell);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_column_instance_init (TColumn * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->columnName = NULL;
  object->__isset_columnName = FALSE;
  object->cell = g_object_new (TYPE_T_CELL, NULL);
  object->__isset_cell = FALSE;
}

static void 
t_column_finalize (GObject *object)
{
  TColumn *tobject = T_COLUMN (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->columnName != NULL)
  {
    thrift_string_free(tobject->columnName);
    tobject->columnName = NULL;
  }
  if (tobject->cell != NULL)
  {
    g_object_unref(tobject->cell);
    tobject->cell = NULL;
  }
}

static void
t_column_class_init (TColumnClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_column_read;
  struct_class->write = t_column_write;

  gobject_class->finalize = t_column_finalize;
  gobject_class->get_property = t_column_get_property;
  gobject_class->set_property = t_column_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_COLUMN_COLUMN_NAME,
     g_param_spec_boxed ("columnName",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_COLUMN_CELL,
     g_param_spec_object ("cell",
                         NULL,
                         NULL,
                         TYPE_T_CELL,
                         G_PARAM_READWRITE));
}

GType
t_column_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TColumnClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_column_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TColumn),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_column_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TColumnType",
                                   &type_info, 0);
  }

  return type;
}

enum _TRowResultProperties
{
  PROP_T_ROW_RESULT_0,
  PROP_T_ROW_RESULT_ROW,
  PROP_T_ROW_RESULT_COLUMNS,
  PROP_T_ROW_RESULT_SORTED_COLUMNS
};

/* reads a t_row_result object */
static gint32
t_row_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TRowResult * this_object = T_ROW_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->row != NULL)
          {
            g_free(this_object->row);
            this_object->row = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->row = g_byte_array_new();
          g_byte_array_append (this_object->row, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_row = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              Text key2 = NULL;
              TCell * val3 = NULL;
              if (key2 != NULL)
              {
                g_free(key2);
                key2 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              key2 = g_byte_array_new();
              g_byte_array_append (key2, (guint8 *) data, (guint) len);
              g_free (data);
              if ( val3 != NULL)
              {
                g_object_unref (val3);
              }
              val3 = g_object_new (TYPE_T_CELL, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (val3), protocol, error)) < 0)
              {
                g_object_unref (val3);
                return -1;
              }
              xfer += ret;
              if (this_object->columns && key2)
                g_hash_table_insert ((GHashTable *)this_object->columns, (gpointer) key2, (gpointer) val3);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_columns = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              TColumn * _elem4 = NULL;
              if ( _elem4 != NULL)
              {
                g_object_unref (_elem4);
              }
              _elem4 = g_object_new (TYPE_T_COLUMN, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem4), protocol, error)) < 0)
              {
                g_object_unref (_elem4);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->sortedColumns, _elem4);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_sortedColumns = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_row_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TRowResult * this_object = T_ROW_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "TRowResult", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "row", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->row ? ((GByteArray *) this_object->row)->data : NULL, this_object->row ? ((GByteArray *) this_object->row)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_columns == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "columns", T_MAP, 2, error)) < 0)
      return -1;
    xfer += ret;
    {
      Text key5 = NULL;
      TCell * val6 = NULL;
      GList *key_list = NULL, *iter = NULL;
      Text* keys;
      int i = 0, key_count;

      if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRUCT, this_object->columns ? (gint32) g_hash_table_size ((GHashTable *) this_object->columns) : 0, error)) < 0)
        return -1;
      xfer += ret;
      if (this_object->columns)
        g_hash_table_foreach ((GHashTable *) this_object->columns, thrift_hash_table_get_keys, &key_list);
      key_count = g_list_length (key_list);
      keys = g_newa (Text, key_count);
      for (iter = g_list_first (key_list); iter; iter = iter->next)
        keys[i++] = (Text) iter->data;
      g_list_free (key_list);

      for (i = 0; i < key_count; ++i)
      {
        key5 = keys[i];
        val6 = (TCell *) g_hash_table_lookup (((GHashTable *) this_object->columns), (gpointer) key5);

        if ((ret = thrift_protocol_write_binary (protocol,  key5 ? ((GByteArray *)  key5)->data : NULL,  key5 ? ((GByteArray *)  key5)->len : 0, error)) < 0)
          return -1;
        xfer += ret;

        if ((ret = thrift_struct_write (THRIFT_STRUCT ( val6), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_sortedColumns == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "sortedColumns", T_LIST, 3, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i7;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->sortedColumns ? this_object->sortedColumns->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i7 = 0; i7 < (this_object->sortedColumns ? this_object->sortedColumns->len : 0); i7++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->sortedColumns, i7))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_row_result_set_property (GObject *object,
                           guint property_id,
                           const GValue *value,
                           GParamSpec *pspec)
{
  TRowResult *self = T_ROW_RESULT (object);

  switch (property_id)
  {
    case PROP_T_ROW_RESULT_ROW:
      if (self->row != NULL)
        g_byte_array_unref (self->row);
      self->row = g_value_dup_boxed (value);
      self->__isset_row = TRUE;
      break;

    case PROP_T_ROW_RESULT_COLUMNS:
      if (self->columns != NULL)
        g_hash_table_unref (self->columns);
      self->columns = g_value_dup_boxed (value);
      self->__isset_columns = TRUE;
      break;

    case PROP_T_ROW_RESULT_SORTED_COLUMNS:
      if (self->sortedColumns != NULL)
        g_ptr_array_unref (self->sortedColumns);
      self->sortedColumns = g_value_dup_boxed (value);
      self->__isset_sortedColumns = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_row_result_get_property (GObject *object,
                           guint property_id,
                           GValue *value,
                           GParamSpec *pspec)
{
  TRowResult *self = T_ROW_RESULT (object);

  switch (property_id)
  {
    case PROP_T_ROW_RESULT_ROW:
      g_value_set_boxed (value, self->row);
      break;

    case PROP_T_ROW_RESULT_COLUMNS:
      g_value_set_boxed (value, self->columns);
      break;

    case PROP_T_ROW_RESULT_SORTED_COLUMNS:
      g_value_set_boxed (value, self->sortedColumns);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_row_result_instance_init (TRowResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->row = NULL;
  object->__isset_row = FALSE;
  object->columns = g_hash_table_new_full (g_str_hash, g_str_equal, thrift_string_free, g_object_unref);
  object->__isset_columns = FALSE;
  object->sortedColumns = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_sortedColumns = FALSE;
}

static void 
t_row_result_finalize (GObject *object)
{
  TRowResult *tobject = T_ROW_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->row != NULL)
  {
    thrift_string_free(tobject->row);
    tobject->row = NULL;
  }
  if (tobject->columns != NULL)
  {
    g_hash_table_destroy (tobject->columns);
    tobject->columns = NULL;
  }
  if (tobject->sortedColumns != NULL)
  {
    g_ptr_array_unref (tobject->sortedColumns);
    tobject->sortedColumns = NULL;
  }
}

static void
t_row_result_class_init (TRowResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_row_result_read;
  struct_class->write = t_row_result_write;

  gobject_class->finalize = t_row_result_finalize;
  gobject_class->get_property = t_row_result_get_property;
  gobject_class->set_property = t_row_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_ROW_RESULT_ROW,
     g_param_spec_boxed ("row",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_ROW_RESULT_COLUMNS,
     g_param_spec_boxed ("columns",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_ROW_RESULT_SORTED_COLUMNS,
     g_param_spec_boxed ("sortedColumns",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
t_row_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TRowResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_row_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TRowResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_row_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TRowResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _TScanProperties
{
  PROP_T_SCAN_0,
  PROP_T_SCAN_START_ROW,
  PROP_T_SCAN_STOP_ROW,
  PROP_T_SCAN_TIMESTAMP,
  PROP_T_SCAN_COLUMNS,
  PROP_T_SCAN_CACHING,
  PROP_T_SCAN_FILTER_STRING,
  PROP_T_SCAN_BATCH_SIZE,
  PROP_T_SCAN_SORT_COLUMNS,
  PROP_T_SCAN_REVERSED
};

/* reads a t_scan object */
static gint32
t_scan_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TScan * this_object = T_SCAN(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->startRow != NULL)
          {
            g_free(this_object->startRow);
            this_object->startRow = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->startRow = g_byte_array_new();
          g_byte_array_append (this_object->startRow, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_startRow = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->stopRow != NULL)
          {
            g_free(this_object->stopRow);
            this_object->stopRow = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->stopRow = g_byte_array_new();
          g_byte_array_append (this_object->stopRow, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_stopRow = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->timestamp, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_timestamp = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              GByteArray * _elem8 = NULL;
              if (_elem8 != NULL)
              {
                g_free(_elem8);
                _elem8 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              _elem8 = g_byte_array_new();
              g_byte_array_append (_elem8, (guint8 *) data, (guint) len);
              g_free (data);
              g_ptr_array_add (this_object->columns, _elem8);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_columns = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->caching, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_caching = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_STRING)
        {
          if (this_object->filterString != NULL)
          {
            g_free(this_object->filterString);
            this_object->filterString = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->filterString = g_byte_array_new();
          g_byte_array_append (this_object->filterString, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_filterString = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 7:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->batchSize, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_batchSize = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 8:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->sortColumns, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_sortColumns = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 9:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->reversed, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_reversed = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_scan_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TScan * this_object = T_SCAN(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "TScan", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_startRow == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "startRow", T_STRING, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, this_object->startRow ? ((GByteArray *) this_object->startRow)->data : NULL, this_object->startRow ? ((GByteArray *) this_object->startRow)->len : 0, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_stopRow == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "stopRow", T_STRING, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, this_object->stopRow ? ((GByteArray *) this_object->stopRow)->data : NULL, this_object->stopRow ? ((GByteArray *) this_object->stopRow)->len : 0, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_timestamp == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "timestamp", T_I64, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, this_object->timestamp, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_columns == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "columns", T_LIST, 4, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i9;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (this_object->columns ? this_object->columns->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i9 = 0; i9 < (this_object->columns ? this_object->columns->len : 0); i9++)
      {
        if ((ret = thrift_protocol_write_binary (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->columns, i9)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->columns, i9)))->data : NULL, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->columns, i9)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->columns, i9)))->len : 0, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_caching == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "caching", T_I32, 5, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->caching, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_filterString == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "filterString", T_STRING, 6, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, this_object->filterString ? ((GByteArray *) this_object->filterString)->data : NULL, this_object->filterString ? ((GByteArray *) this_object->filterString)->len : 0, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_batchSize == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "batchSize", T_I32, 7, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->batchSize, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_sortColumns == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "sortColumns", T_BOOL, 8, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->sortColumns, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_reversed == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "reversed", T_BOOL, 9, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->reversed, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_scan_set_property (GObject *object,
                     guint property_id,
                     const GValue *value,
                     GParamSpec *pspec)
{
  TScan *self = T_SCAN (object);

  switch (property_id)
  {
    case PROP_T_SCAN_START_ROW:
      if (self->startRow != NULL)
        g_byte_array_unref (self->startRow);
      self->startRow = g_value_dup_boxed (value);
      self->__isset_startRow = TRUE;
      break;

    case PROP_T_SCAN_STOP_ROW:
      if (self->stopRow != NULL)
        g_byte_array_unref (self->stopRow);
      self->stopRow = g_value_dup_boxed (value);
      self->__isset_stopRow = TRUE;
      break;

    case PROP_T_SCAN_TIMESTAMP:
      self->timestamp = g_value_get_int64 (value);
      self->__isset_timestamp = TRUE;
      break;

    case PROP_T_SCAN_COLUMNS:
      if (self->columns != NULL)
        g_ptr_array_unref (self->columns);
      self->columns = g_value_dup_boxed (value);
      self->__isset_columns = TRUE;
      break;

    case PROP_T_SCAN_CACHING:
      self->caching = g_value_get_int (value);
      self->__isset_caching = TRUE;
      break;

    case PROP_T_SCAN_FILTER_STRING:
      if (self->filterString != NULL)
        g_byte_array_unref (self->filterString);
      self->filterString = g_value_dup_boxed (value);
      self->__isset_filterString = TRUE;
      break;

    case PROP_T_SCAN_BATCH_SIZE:
      self->batchSize = g_value_get_int (value);
      self->__isset_batchSize = TRUE;
      break;

    case PROP_T_SCAN_SORT_COLUMNS:
      self->sortColumns = g_value_get_boolean (value);
      self->__isset_sortColumns = TRUE;
      break;

    case PROP_T_SCAN_REVERSED:
      self->reversed = g_value_get_boolean (value);
      self->__isset_reversed = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_scan_get_property (GObject *object,
                     guint property_id,
                     GValue *value,
                     GParamSpec *pspec)
{
  TScan *self = T_SCAN (object);

  switch (property_id)
  {
    case PROP_T_SCAN_START_ROW:
      g_value_set_boxed (value, self->startRow);
      break;

    case PROP_T_SCAN_STOP_ROW:
      g_value_set_boxed (value, self->stopRow);
      break;

    case PROP_T_SCAN_TIMESTAMP:
      g_value_set_int64 (value, self->timestamp);
      break;

    case PROP_T_SCAN_COLUMNS:
      g_value_set_boxed (value, self->columns);
      break;

    case PROP_T_SCAN_CACHING:
      g_value_set_int (value, self->caching);
      break;

    case PROP_T_SCAN_FILTER_STRING:
      g_value_set_boxed (value, self->filterString);
      break;

    case PROP_T_SCAN_BATCH_SIZE:
      g_value_set_int (value, self->batchSize);
      break;

    case PROP_T_SCAN_SORT_COLUMNS:
      g_value_set_boolean (value, self->sortColumns);
      break;

    case PROP_T_SCAN_REVERSED:
      g_value_set_boolean (value, self->reversed);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_scan_instance_init (TScan * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->startRow = NULL;
  object->__isset_startRow = FALSE;
  object->stopRow = NULL;
  object->__isset_stopRow = FALSE;
  object->timestamp = 0;
  object->__isset_timestamp = FALSE;
  object->columns = g_ptr_array_new_with_free_func (thrift_string_free);
  object->__isset_columns = FALSE;
  object->caching = 0;
  object->__isset_caching = FALSE;
  object->filterString = NULL;
  object->__isset_filterString = FALSE;
  object->batchSize = 0;
  object->__isset_batchSize = FALSE;
  object->sortColumns = 0;
  object->__isset_sortColumns = FALSE;
  object->reversed = 0;
  object->__isset_reversed = FALSE;
}

static void 
t_scan_finalize (GObject *object)
{
  TScan *tobject = T_SCAN (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->startRow != NULL)
  {
    thrift_string_free(tobject->startRow);
    tobject->startRow = NULL;
  }
  if (tobject->stopRow != NULL)
  {
    thrift_string_free(tobject->stopRow);
    tobject->stopRow = NULL;
  }
  if (tobject->columns != NULL)
  {
    g_ptr_array_unref (tobject->columns);
    tobject->columns = NULL;
  }
  if (tobject->filterString != NULL)
  {
    thrift_string_free(tobject->filterString);
    tobject->filterString = NULL;
  }
}

static void
t_scan_class_init (TScanClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_scan_read;
  struct_class->write = t_scan_write;

  gobject_class->finalize = t_scan_finalize;
  gobject_class->get_property = t_scan_get_property;
  gobject_class->set_property = t_scan_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_SCAN_START_ROW,
     g_param_spec_boxed ("startRow",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_SCAN_STOP_ROW,
     g_param_spec_boxed ("stopRow",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_SCAN_TIMESTAMP,
     g_param_spec_int64 ("timestamp",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_SCAN_COLUMNS,
     g_param_spec_boxed ("columns",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_SCAN_CACHING,
     g_param_spec_int ("caching",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_SCAN_FILTER_STRING,
     g_param_spec_boxed ("filterString",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_SCAN_BATCH_SIZE,
     g_param_spec_int ("batchSize",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_SCAN_SORT_COLUMNS,
     g_param_spec_boolean ("sortColumns",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_SCAN_REVERSED,
     g_param_spec_boolean ("reversed",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));
}

GType
t_scan_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TScanClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_scan_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TScan),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_scan_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TScanType",
                                   &type_info, 0);
  }

  return type;
}

enum _TAppendProperties
{
  PROP_T_APPEND_0,
  PROP_T_APPEND_TABLE,
  PROP_T_APPEND_ROW,
  PROP_T_APPEND_COLUMNS,
  PROP_T_APPEND_VALUES
};

/* reads a t_append object */
static gint32
t_append_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TAppend * this_object = T_APPEND(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->table != NULL)
          {
            g_free(this_object->table);
            this_object->table = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->table = g_byte_array_new();
          g_byte_array_append (this_object->table, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_table = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->row != NULL)
          {
            g_free(this_object->row);
            this_object->row = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->row = g_byte_array_new();
          g_byte_array_append (this_object->row, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_row = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              GByteArray * _elem10 = NULL;
              if (_elem10 != NULL)
              {
                g_free(_elem10);
                _elem10 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              _elem10 = g_byte_array_new();
              g_byte_array_append (_elem10, (guint8 *) data, (guint) len);
              g_free (data);
              g_ptr_array_add (this_object->columns, _elem10);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_columns = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              GByteArray * _elem11 = NULL;
              if (_elem11 != NULL)
              {
                g_free(_elem11);
                _elem11 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              _elem11 = g_byte_array_new();
              g_byte_array_append (_elem11, (guint8 *) data, (guint) len);
              g_free (data);
              g_ptr_array_add (this_object->values, _elem11);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_values = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
t_append_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TAppend * this_object = T_APPEND(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "TAppend", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "table", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->table ? ((GByteArray *) this_object->table)->data : NULL, this_object->table ? ((GByteArray *) this_object->table)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "row", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->row ? ((GByteArray *) this_object->row)->data : NULL, this_object->row ? ((GByteArray *) this_object->row)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "columns", T_LIST, 3, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i12;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (this_object->columns ? this_object->columns->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i12 = 0; i12 < (this_object->columns ? this_object->columns->len : 0); i12++)
    {
      if ((ret = thrift_protocol_write_binary (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->columns, i12)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->columns, i12)))->data : NULL, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->columns, i12)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->columns, i12)))->len : 0, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "values", T_LIST, 4, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i13;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (this_object->values ? this_object->values->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i13 = 0; i13 < (this_object->values ? this_object->values->len : 0); i13++)
    {
      if ((ret = thrift_protocol_write_binary (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->values, i13)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->values, i13)))->data : NULL, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->values, i13)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->values, i13)))->len : 0, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
t_append_set_property (GObject *object,
                       guint property_id,
                       const GValue *value,
                       GParamSpec *pspec)
{
  TAppend *self = T_APPEND (object);

  switch (property_id)
  {
    case PROP_T_APPEND_TABLE:
      if (self->table != NULL)
        g_byte_array_unref (self->table);
      self->table = g_value_dup_boxed (value);
      self->__isset_table = TRUE;
      break;

    case PROP_T_APPEND_ROW:
      if (self->row != NULL)
        g_byte_array_unref (self->row);
      self->row = g_value_dup_boxed (value);
      self->__isset_row = TRUE;
      break;

    case PROP_T_APPEND_COLUMNS:
      if (self->columns != NULL)
        g_ptr_array_unref (self->columns);
      self->columns = g_value_dup_boxed (value);
      self->__isset_columns = TRUE;
      break;

    case PROP_T_APPEND_VALUES:
      if (self->values != NULL)
        g_ptr_array_unref (self->values);
      self->values = g_value_dup_boxed (value);
      self->__isset_values = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
t_append_get_property (GObject *object,
                       guint property_id,
                       GValue *value,
                       GParamSpec *pspec)
{
  TAppend *self = T_APPEND (object);

  switch (property_id)
  {
    case PROP_T_APPEND_TABLE:
      g_value_set_boxed (value, self->table);
      break;

    case PROP_T_APPEND_ROW:
      g_value_set_boxed (value, self->row);
      break;

    case PROP_T_APPEND_COLUMNS:
      g_value_set_boxed (value, self->columns);
      break;

    case PROP_T_APPEND_VALUES:
      g_value_set_boxed (value, self->values);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
t_append_instance_init (TAppend * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->table = NULL;
  object->__isset_table = FALSE;
  object->row = NULL;
  object->__isset_row = FALSE;
  object->columns = g_ptr_array_new_with_free_func (thrift_string_free);
  object->__isset_columns = FALSE;
  object->values = g_ptr_array_new_with_free_func (thrift_string_free);
  object->__isset_values = FALSE;
}

static void 
t_append_finalize (GObject *object)
{
  TAppend *tobject = T_APPEND (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->table != NULL)
  {
    thrift_string_free(tobject->table);
    tobject->table = NULL;
  }
  if (tobject->row != NULL)
  {
    thrift_string_free(tobject->row);
    tobject->row = NULL;
  }
  if (tobject->columns != NULL)
  {
    g_ptr_array_unref (tobject->columns);
    tobject->columns = NULL;
  }
  if (tobject->values != NULL)
  {
    g_ptr_array_unref (tobject->values);
    tobject->values = NULL;
  }
}

static void
t_append_class_init (TAppendClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = t_append_read;
  struct_class->write = t_append_write;

  gobject_class->finalize = t_append_finalize;
  gobject_class->get_property = t_append_get_property;
  gobject_class->set_property = t_append_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_T_APPEND_TABLE,
     g_param_spec_boxed ("table",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_APPEND_ROW,
     g_param_spec_boxed ("row",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_APPEND_COLUMNS,
     g_param_spec_boxed ("columns",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_T_APPEND_VALUES,
     g_param_spec_boxed ("values",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
t_append_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TAppendClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) t_append_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TAppend),
      0, /* n_preallocs */
      (GInstanceInitFunc) t_append_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TAppendType",
                                   &type_info, 0);
  }

  return type;
}

enum _IOErrorProperties
{
  PROP_I_O_ERROR_0,
  PROP_I_O_ERROR_MESSAGE
};

/* reads a i_o_error object */
static gint32
i_o_error_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IOError * this_object = I_O_ERROR(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->message != NULL)
          {
            g_free(this_object->message);
            this_object->message = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->message, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_message = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_o_error_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IOError * this_object = I_O_ERROR(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IOError", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "message", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->message, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_o_error_set_property (GObject *object,
                        guint property_id,
                        const GValue *value,
                        GParamSpec *pspec)
{
  IOError *self = I_O_ERROR (object);

  switch (property_id)
  {
    case PROP_I_O_ERROR_MESSAGE:
      if (self->message != NULL)
        g_free (self->message);
      self->message = g_value_dup_string (value);
      self->__isset_message = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_o_error_get_property (GObject *object,
                        guint property_id,
                        GValue *value,
                        GParamSpec *pspec)
{
  IOError *self = I_O_ERROR (object);

  switch (property_id)
  {
    case PROP_I_O_ERROR_MESSAGE:
      g_value_set_string (value, self->message);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_o_error_instance_init (IOError * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->message = NULL;
  object->__isset_message = FALSE;
}

static void 
i_o_error_finalize (GObject *object)
{
  IOError *tobject = I_O_ERROR (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->message != NULL)
  {
    g_free(tobject->message);
    tobject->message = NULL;
  }
}

static void
i_o_error_class_init (IOErrorClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_o_error_read;
  struct_class->write = i_o_error_write;

  gobject_class->finalize = i_o_error_finalize;
  gobject_class->get_property = i_o_error_get_property;
  gobject_class->set_property = i_o_error_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_O_ERROR_MESSAGE,
     g_param_spec_string ("message",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
i_o_error_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IOErrorClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_o_error_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IOError),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_o_error_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IOErrorType",
                                   &type_info, 0);
  }

  return type;
}

/* define the GError domain for exceptions */
#define I_O_ERROR_ERROR_DOMAIN "i_o_error_error_quark"
GQuark
i_o_error_error_quark (void)
{
  return g_quark_from_static_string (I_O_ERROR_ERROR_DOMAIN);
}

enum _IllegalArgumentProperties
{
  PROP_ILLEGAL_ARGUMENT_0,
  PROP_ILLEGAL_ARGUMENT_MESSAGE
};

/* reads a illegal_argument object */
static gint32
illegal_argument_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IllegalArgument * this_object = ILLEGAL_ARGUMENT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->message != NULL)
          {
            g_free(this_object->message);
            this_object->message = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->message, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_message = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
illegal_argument_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IllegalArgument * this_object = ILLEGAL_ARGUMENT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IllegalArgument", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "message", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->message, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
illegal_argument_set_property (GObject *object,
                               guint property_id,
                               const GValue *value,
                               GParamSpec *pspec)
{
  IllegalArgument *self = ILLEGAL_ARGUMENT (object);

  switch (property_id)
  {
    case PROP_ILLEGAL_ARGUMENT_MESSAGE:
      if (self->message != NULL)
        g_free (self->message);
      self->message = g_value_dup_string (value);
      self->__isset_message = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
illegal_argument_get_property (GObject *object,
                               guint property_id,
                               GValue *value,
                               GParamSpec *pspec)
{
  IllegalArgument *self = ILLEGAL_ARGUMENT (object);

  switch (property_id)
  {
    case PROP_ILLEGAL_ARGUMENT_MESSAGE:
      g_value_set_string (value, self->message);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
illegal_argument_instance_init (IllegalArgument * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->message = NULL;
  object->__isset_message = FALSE;
}

static void 
illegal_argument_finalize (GObject *object)
{
  IllegalArgument *tobject = ILLEGAL_ARGUMENT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->message != NULL)
  {
    g_free(tobject->message);
    tobject->message = NULL;
  }
}

static void
illegal_argument_class_init (IllegalArgumentClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = illegal_argument_read;
  struct_class->write = illegal_argument_write;

  gobject_class->finalize = illegal_argument_finalize;
  gobject_class->get_property = illegal_argument_get_property;
  gobject_class->set_property = illegal_argument_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_ILLEGAL_ARGUMENT_MESSAGE,
     g_param_spec_string ("message",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
illegal_argument_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IllegalArgumentClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) illegal_argument_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IllegalArgument),
      0, /* n_preallocs */
      (GInstanceInitFunc) illegal_argument_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IllegalArgumentType",
                                   &type_info, 0);
  }

  return type;
}

/* define the GError domain for exceptions */
#define ILLEGAL_ARGUMENT_ERROR_DOMAIN "illegal_argument_error_quark"
GQuark
illegal_argument_error_quark (void)
{
  return g_quark_from_static_string (ILLEGAL_ARGUMENT_ERROR_DOMAIN);
}

enum _AlreadyExistsProperties
{
  PROP_ALREADY_EXISTS_0,
  PROP_ALREADY_EXISTS_MESSAGE
};

/* reads a already_exists object */
static gint32
already_exists_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  AlreadyExists * this_object = ALREADY_EXISTS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->message != NULL)
          {
            g_free(this_object->message);
            this_object->message = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->message, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_message = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
already_exists_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  AlreadyExists * this_object = ALREADY_EXISTS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "AlreadyExists", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "message", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->message, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
already_exists_set_property (GObject *object,
                             guint property_id,
                             const GValue *value,
                             GParamSpec *pspec)
{
  AlreadyExists *self = ALREADY_EXISTS (object);

  switch (property_id)
  {
    case PROP_ALREADY_EXISTS_MESSAGE:
      if (self->message != NULL)
        g_free (self->message);
      self->message = g_value_dup_string (value);
      self->__isset_message = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
already_exists_get_property (GObject *object,
                             guint property_id,
                             GValue *value,
                             GParamSpec *pspec)
{
  AlreadyExists *self = ALREADY_EXISTS (object);

  switch (property_id)
  {
    case PROP_ALREADY_EXISTS_MESSAGE:
      g_value_set_string (value, self->message);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
already_exists_instance_init (AlreadyExists * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->message = NULL;
  object->__isset_message = FALSE;
}

static void 
already_exists_finalize (GObject *object)
{
  AlreadyExists *tobject = ALREADY_EXISTS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->message != NULL)
  {
    g_free(tobject->message);
    tobject->message = NULL;
  }
}

static void
already_exists_class_init (AlreadyExistsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = already_exists_read;
  struct_class->write = already_exists_write;

  gobject_class->finalize = already_exists_finalize;
  gobject_class->get_property = already_exists_get_property;
  gobject_class->set_property = already_exists_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_ALREADY_EXISTS_MESSAGE,
     g_param_spec_string ("message",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
already_exists_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (AlreadyExistsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) already_exists_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (AlreadyExists),
      0, /* n_preallocs */
      (GInstanceInitFunc) already_exists_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "AlreadyExistsType",
                                   &type_info, 0);
  }

  return type;
}

/* define the GError domain for exceptions */
#define ALREADY_EXISTS_ERROR_DOMAIN "already_exists_error_quark"
GQuark
already_exists_error_quark (void)
{
  return g_quark_from_static_string (ALREADY_EXISTS_ERROR_DOMAIN);
}

/* constants */

enum _HbaseEnableTableArgsProperties
{
  PROP_HBASE_ENABLE_TABLE_ARGS_0,
  PROP_HBASE_ENABLE_TABLE_ARGS_TABLE_NAME
};

/* reads a hbase_enable_table_args object */
static gint32
hbase_enable_table_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  HbaseEnableTableArgs * this_object = HBASE_ENABLE_TABLE_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->tableName != NULL)
          {
            g_free(this_object->tableName);
            this_object->tableName = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->tableName = g_byte_array_new();
          g_byte_array_append (this_object->tableName, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_tableName = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
hbase_enable_table_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  HbaseEnableTableArgs * this_object = HBASE_ENABLE_TABLE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "HbaseEnableTableArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "tableName", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->tableName ? ((GByteArray *) this_object->tableName)->data : NULL, this_object->tableName ? ((GByteArray *) this_object->tableName)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
hbase_enable_table_args_set_property (GObject *object,
                                      guint property_id,
                                      const GValue *value,
                                      GParamSpec *pspec)
{
  HbaseEnableTableArgs *self = HBASE_ENABLE_TABLE_ARGS (object);

  switch (property_id)
  {
    case PROP_HBASE_ENABLE_TABLE_ARGS_TABLE_NAME:
      if (self->tableName != NULL)
        g_byte_array_unref (self->tableName);
      self->tableName = g_value_dup_boxed (value);
      self->__isset_tableName = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
hbase_enable_table_args_get_property (GObject *object,
                                      guint property_id,
                                      GValue *value,
                                      GParamSpec *pspec)
{
  HbaseEnableTableArgs *self = HBASE_ENABLE_TABLE_ARGS (object);

  switch (property_id)
  {
    case PROP_HBASE_ENABLE_TABLE_ARGS_TABLE_NAME:
      g_value_set_boxed (value, self->tableName);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
hbase_enable_table_args_instance_init (HbaseEnableTableArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->tableName = NULL;
  object->__isset_tableName = FALSE;
}

static void 
hbase_enable_table_args_finalize (GObject *object)
{
  HbaseEnableTableArgs *tobject = HBASE_ENABLE_TABLE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->tableName != NULL)
  {
    thrift_string_free(tobject->tableName);
    tobject->tableName = NULL;
  }
}

static void
hbase_enable_table_args_class_init (HbaseEnableTableArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = hbase_enable_table_args_read;
  struct_class->write = hbase_enable_table_args_write;

  gobject_class->finalize = hbase_enable_table_args_finalize;
  gobject_class->get_property = hbase_enable_table_args_get_property;
  gobject_class->set_property = hbase_enable_table_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_ENABLE_TABLE_ARGS_TABLE_NAME,
     g_param_spec_boxed ("tableName",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));
}

GType
hbase_enable_table_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (HbaseEnableTableArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) hbase_enable_table_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (HbaseEnableTableArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) hbase_enable_table_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "HbaseEnableTableArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _HbaseEnableTableResultProperties
{
  PROP_HBASE_ENABLE_TABLE_RESULT_0,
  PROP_HBASE_ENABLE_TABLE_RESULT_IO
};

/* reads a hbase_enable_table_result object */
static gint32
hbase_enable_table_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  HbaseEnableTableResult * this_object = HBASE_ENABLE_TABLE_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->io != NULL)
          {
            g_object_unref (this_object->io);
          }
          this_object->io = g_object_new (TYPE_I_O_ERROR, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
          {
            g_object_unref (this_object->io);
            this_object->io = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_io = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
hbase_enable_table_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  HbaseEnableTableResult * this_object = HBASE_ENABLE_TABLE_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "HbaseEnableTableResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_io == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "io", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
hbase_enable_table_result_set_property (GObject *object,
                                        guint property_id,
                                        const GValue *value,
                                        GParamSpec *pspec)
{
  HbaseEnableTableResult *self = HBASE_ENABLE_TABLE_RESULT (object);

  switch (property_id)
  {
    case PROP_HBASE_ENABLE_TABLE_RESULT_IO:
      if (self->io != NULL)
        g_object_unref (self->io);
      self->io = g_value_dup_object (value);
      self->__isset_io = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
hbase_enable_table_result_get_property (GObject *object,
                                        guint property_id,
                                        GValue *value,
                                        GParamSpec *pspec)
{
  HbaseEnableTableResult *self = HBASE_ENABLE_TABLE_RESULT (object);

  switch (property_id)
  {
    case PROP_HBASE_ENABLE_TABLE_RESULT_IO:
      g_value_set_object (value, self->io);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
hbase_enable_table_result_instance_init (HbaseEnableTableResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->io = NULL;
  object->__isset_io = FALSE;
}

static void 
hbase_enable_table_result_finalize (GObject *object)
{
  HbaseEnableTableResult *tobject = HBASE_ENABLE_TABLE_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->io != NULL)
  {
    g_object_unref(tobject->io);
    tobject->io = NULL;
  }
}

static void
hbase_enable_table_result_class_init (HbaseEnableTableResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = hbase_enable_table_result_read;
  struct_class->write = hbase_enable_table_result_write;

  gobject_class->finalize = hbase_enable_table_result_finalize;
  gobject_class->get_property = hbase_enable_table_result_get_property;
  gobject_class->set_property = hbase_enable_table_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_ENABLE_TABLE_RESULT_IO,
     g_param_spec_object ("io",
                         NULL,
                         NULL,
                         TYPE_I_O_ERROR,
                         G_PARAM_READWRITE));
}

GType
hbase_enable_table_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (HbaseEnableTableResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) hbase_enable_table_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (HbaseEnableTableResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) hbase_enable_table_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "HbaseEnableTableResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _HbaseDisableTableArgsProperties
{
  PROP_HBASE_DISABLE_TABLE_ARGS_0,
  PROP_HBASE_DISABLE_TABLE_ARGS_TABLE_NAME
};

/* reads a hbase_disable_table_args object */
static gint32
hbase_disable_table_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  HbaseDisableTableArgs * this_object = HBASE_DISABLE_TABLE_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->tableName != NULL)
          {
            g_free(this_object->tableName);
            this_object->tableName = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->tableName = g_byte_array_new();
          g_byte_array_append (this_object->tableName, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_tableName = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
hbase_disable_table_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  HbaseDisableTableArgs * this_object = HBASE_DISABLE_TABLE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "HbaseDisableTableArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "tableName", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->tableName ? ((GByteArray *) this_object->tableName)->data : NULL, this_object->tableName ? ((GByteArray *) this_object->tableName)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
hbase_disable_table_args_set_property (GObject *object,
                                       guint property_id,
                                       const GValue *value,
                                       GParamSpec *pspec)
{
  HbaseDisableTableArgs *self = HBASE_DISABLE_TABLE_ARGS (object);

  switch (property_id)
  {
    case PROP_HBASE_DISABLE_TABLE_ARGS_TABLE_NAME:
      if (self->tableName != NULL)
        g_byte_array_unref (self->tableName);
      self->tableName = g_value_dup_boxed (value);
      self->__isset_tableName = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
hbase_disable_table_args_get_property (GObject *object,
                                       guint property_id,
                                       GValue *value,
                                       GParamSpec *pspec)
{
  HbaseDisableTableArgs *self = HBASE_DISABLE_TABLE_ARGS (object);

  switch (property_id)
  {
    case PROP_HBASE_DISABLE_TABLE_ARGS_TABLE_NAME:
      g_value_set_boxed (value, self->tableName);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
hbase_disable_table_args_instance_init (HbaseDisableTableArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->tableName = NULL;
  object->__isset_tableName = FALSE;
}

static void 
hbase_disable_table_args_finalize (GObject *object)
{
  HbaseDisableTableArgs *tobject = HBASE_DISABLE_TABLE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->tableName != NULL)
  {
    thrift_string_free(tobject->tableName);
    tobject->tableName = NULL;
  }
}

static void
hbase_disable_table_args_class_init (HbaseDisableTableArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = hbase_disable_table_args_read;
  struct_class->write = hbase_disable_table_args_write;

  gobject_class->finalize = hbase_disable_table_args_finalize;
  gobject_class->get_property = hbase_disable_table_args_get_property;
  gobject_class->set_property = hbase_disable_table_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_DISABLE_TABLE_ARGS_TABLE_NAME,
     g_param_spec_boxed ("tableName",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));
}

GType
hbase_disable_table_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (HbaseDisableTableArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) hbase_disable_table_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (HbaseDisableTableArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) hbase_disable_table_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "HbaseDisableTableArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _HbaseDisableTableResultProperties
{
  PROP_HBASE_DISABLE_TABLE_RESULT_0,
  PROP_HBASE_DISABLE_TABLE_RESULT_IO
};

/* reads a hbase_disable_table_result object */
static gint32
hbase_disable_table_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  HbaseDisableTableResult * this_object = HBASE_DISABLE_TABLE_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->io != NULL)
          {
            g_object_unref (this_object->io);
          }
          this_object->io = g_object_new (TYPE_I_O_ERROR, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
          {
            g_object_unref (this_object->io);
            this_object->io = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_io = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
hbase_disable_table_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  HbaseDisableTableResult * this_object = HBASE_DISABLE_TABLE_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "HbaseDisableTableResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_io == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "io", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
hbase_disable_table_result_set_property (GObject *object,
                                         guint property_id,
                                         const GValue *value,
                                         GParamSpec *pspec)
{
  HbaseDisableTableResult *self = HBASE_DISABLE_TABLE_RESULT (object);

  switch (property_id)
  {
    case PROP_HBASE_DISABLE_TABLE_RESULT_IO:
      if (self->io != NULL)
        g_object_unref (self->io);
      self->io = g_value_dup_object (value);
      self->__isset_io = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
hbase_disable_table_result_get_property (GObject *object,
                                         guint property_id,
                                         GValue *value,
                                         GParamSpec *pspec)
{
  HbaseDisableTableResult *self = HBASE_DISABLE_TABLE_RESULT (object);

  switch (property_id)
  {
    case PROP_HBASE_DISABLE_TABLE_RESULT_IO:
      g_value_set_object (value, self->io);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
hbase_disable_table_result_instance_init (HbaseDisableTableResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->io = NULL;
  object->__isset_io = FALSE;
}

static void 
hbase_disable_table_result_finalize (GObject *object)
{
  HbaseDisableTableResult *tobject = HBASE_DISABLE_TABLE_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->io != NULL)
  {
    g_object_unref(tobject->io);
    tobject->io = NULL;
  }
}

static void
hbase_disable_table_result_class_init (HbaseDisableTableResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = hbase_disable_table_result_read;
  struct_class->write = hbase_disable_table_result_write;

  gobject_class->finalize = hbase_disable_table_result_finalize;
  gobject_class->get_property = hbase_disable_table_result_get_property;
  gobject_class->set_property = hbase_disable_table_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_DISABLE_TABLE_RESULT_IO,
     g_param_spec_object ("io",
                         NULL,
                         NULL,
                         TYPE_I_O_ERROR,
                         G_PARAM_READWRITE));
}

GType
hbase_disable_table_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (HbaseDisableTableResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) hbase_disable_table_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (HbaseDisableTableResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) hbase_disable_table_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "HbaseDisableTableResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _HbaseIsTableEnabledArgsProperties
{
  PROP_HBASE_IS_TABLE_ENABLED_ARGS_0,
  PROP_HBASE_IS_TABLE_ENABLED_ARGS_TABLE_NAME
};

/* reads a hbase_is_table_enabled_args object */
static gint32
hbase_is_table_enabled_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  HbaseIsTableEnabledArgs * this_object = HBASE_IS_TABLE_ENABLED_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->tableName != NULL)
          {
            g_free(this_object->tableName);
            this_object->tableName = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->tableName = g_byte_array_new();
          g_byte_array_append (this_object->tableName, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_tableName = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
hbase_is_table_enabled_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  HbaseIsTableEnabledArgs * this_object = HBASE_IS_TABLE_ENABLED_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "HbaseIsTableEnabledArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "tableName", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->tableName ? ((GByteArray *) this_object->tableName)->data : NULL, this_object->tableName ? ((GByteArray *) this_object->tableName)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
hbase_is_table_enabled_args_set_property (GObject *object,
                                          guint property_id,
                                          const GValue *value,
                                          GParamSpec *pspec)
{
  HbaseIsTableEnabledArgs *self = HBASE_IS_TABLE_ENABLED_ARGS (object);

  switch (property_id)
  {
    case PROP_HBASE_IS_TABLE_ENABLED_ARGS_TABLE_NAME:
      if (self->tableName != NULL)
        g_byte_array_unref (self->tableName);
      self->tableName = g_value_dup_boxed (value);
      self->__isset_tableName = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
hbase_is_table_enabled_args_get_property (GObject *object,
                                          guint property_id,
                                          GValue *value,
                                          GParamSpec *pspec)
{
  HbaseIsTableEnabledArgs *self = HBASE_IS_TABLE_ENABLED_ARGS (object);

  switch (property_id)
  {
    case PROP_HBASE_IS_TABLE_ENABLED_ARGS_TABLE_NAME:
      g_value_set_boxed (value, self->tableName);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
hbase_is_table_enabled_args_instance_init (HbaseIsTableEnabledArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->tableName = NULL;
  object->__isset_tableName = FALSE;
}

static void 
hbase_is_table_enabled_args_finalize (GObject *object)
{
  HbaseIsTableEnabledArgs *tobject = HBASE_IS_TABLE_ENABLED_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->tableName != NULL)
  {
    thrift_string_free(tobject->tableName);
    tobject->tableName = NULL;
  }
}

static void
hbase_is_table_enabled_args_class_init (HbaseIsTableEnabledArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = hbase_is_table_enabled_args_read;
  struct_class->write = hbase_is_table_enabled_args_write;

  gobject_class->finalize = hbase_is_table_enabled_args_finalize;
  gobject_class->get_property = hbase_is_table_enabled_args_get_property;
  gobject_class->set_property = hbase_is_table_enabled_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_IS_TABLE_ENABLED_ARGS_TABLE_NAME,
     g_param_spec_boxed ("tableName",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));
}

GType
hbase_is_table_enabled_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (HbaseIsTableEnabledArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) hbase_is_table_enabled_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (HbaseIsTableEnabledArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) hbase_is_table_enabled_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "HbaseIsTableEnabledArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _HbaseIsTableEnabledResultProperties
{
  PROP_HBASE_IS_TABLE_ENABLED_RESULT_0,
  PROP_HBASE_IS_TABLE_ENABLED_RESULT_SUCCESS,
  PROP_HBASE_IS_TABLE_ENABLED_RESULT_IO
};

/* reads a hbase_is_table_enabled_result object */
static gint32
hbase_is_table_enabled_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  HbaseIsTableEnabledResult * this_object = HBASE_IS_TABLE_ENABLED_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->io != NULL)
          {
            g_object_unref (this_object->io);
          }
          this_object->io = g_object_new (TYPE_I_O_ERROR, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
          {
            g_object_unref (this_object->io);
            this_object->io = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_io = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
hbase_is_table_enabled_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  HbaseIsTableEnabledResult * this_object = HBASE_IS_TABLE_ENABLED_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "HbaseIsTableEnabledResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_BOOL, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->success, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_io == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "io", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
hbase_is_table_enabled_result_set_property (GObject *object,
                                            guint property_id,
                                            const GValue *value,
                                            GParamSpec *pspec)
{
  HbaseIsTableEnabledResult *self = HBASE_IS_TABLE_ENABLED_RESULT (object);

  switch (property_id)
  {
    case PROP_HBASE_IS_TABLE_ENABLED_RESULT_SUCCESS:
      self->success = g_value_get_boolean (value);
      self->__isset_success = TRUE;
      break;

    case PROP_HBASE_IS_TABLE_ENABLED_RESULT_IO:
      if (self->io != NULL)
        g_object_unref (self->io);
      self->io = g_value_dup_object (value);
      self->__isset_io = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
hbase_is_table_enabled_result_get_property (GObject *object,
                                            guint property_id,
                                            GValue *value,
                                            GParamSpec *pspec)
{
  HbaseIsTableEnabledResult *self = HBASE_IS_TABLE_ENABLED_RESULT (object);

  switch (property_id)
  {
    case PROP_HBASE_IS_TABLE_ENABLED_RESULT_SUCCESS:
      g_value_set_boolean (value, self->success);
      break;

    case PROP_HBASE_IS_TABLE_ENABLED_RESULT_IO:
      g_value_set_object (value, self->io);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
hbase_is_table_enabled_result_instance_init (HbaseIsTableEnabledResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
  object->io = NULL;
  object->__isset_io = FALSE;
}

static void 
hbase_is_table_enabled_result_finalize (GObject *object)
{
  HbaseIsTableEnabledResult *tobject = HBASE_IS_TABLE_ENABLED_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->io != NULL)
  {
    g_object_unref(tobject->io);
    tobject->io = NULL;
  }
}

static void
hbase_is_table_enabled_result_class_init (HbaseIsTableEnabledResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = hbase_is_table_enabled_result_read;
  struct_class->write = hbase_is_table_enabled_result_write;

  gobject_class->finalize = hbase_is_table_enabled_result_finalize;
  gobject_class->get_property = hbase_is_table_enabled_result_get_property;
  gobject_class->set_property = hbase_is_table_enabled_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_IS_TABLE_ENABLED_RESULT_SUCCESS,
     g_param_spec_boolean ("success",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_IS_TABLE_ENABLED_RESULT_IO,
     g_param_spec_object ("io",
                         NULL,
                         NULL,
                         TYPE_I_O_ERROR,
                         G_PARAM_READWRITE));
}

GType
hbase_is_table_enabled_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (HbaseIsTableEnabledResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) hbase_is_table_enabled_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (HbaseIsTableEnabledResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) hbase_is_table_enabled_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "HbaseIsTableEnabledResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _HbaseCompactArgsProperties
{
  PROP_HBASE_COMPACT_ARGS_0,
  PROP_HBASE_COMPACT_ARGS_TABLE_NAME_OR_REGION_NAME
};

/* reads a hbase_compact_args object */
static gint32
hbase_compact_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  HbaseCompactArgs * this_object = HBASE_COMPACT_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->tableNameOrRegionName != NULL)
          {
            g_free(this_object->tableNameOrRegionName);
            this_object->tableNameOrRegionName = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->tableNameOrRegionName = g_byte_array_new();
          g_byte_array_append (this_object->tableNameOrRegionName, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_tableNameOrRegionName = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
hbase_compact_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  HbaseCompactArgs * this_object = HBASE_COMPACT_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "HbaseCompactArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "tableNameOrRegionName", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->tableNameOrRegionName ? ((GByteArray *) this_object->tableNameOrRegionName)->data : NULL, this_object->tableNameOrRegionName ? ((GByteArray *) this_object->tableNameOrRegionName)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
hbase_compact_args_set_property (GObject *object,
                                 guint property_id,
                                 const GValue *value,
                                 GParamSpec *pspec)
{
  HbaseCompactArgs *self = HBASE_COMPACT_ARGS (object);

  switch (property_id)
  {
    case PROP_HBASE_COMPACT_ARGS_TABLE_NAME_OR_REGION_NAME:
      if (self->tableNameOrRegionName != NULL)
        g_byte_array_unref (self->tableNameOrRegionName);
      self->tableNameOrRegionName = g_value_dup_boxed (value);
      self->__isset_tableNameOrRegionName = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
hbase_compact_args_get_property (GObject *object,
                                 guint property_id,
                                 GValue *value,
                                 GParamSpec *pspec)
{
  HbaseCompactArgs *self = HBASE_COMPACT_ARGS (object);

  switch (property_id)
  {
    case PROP_HBASE_COMPACT_ARGS_TABLE_NAME_OR_REGION_NAME:
      g_value_set_boxed (value, self->tableNameOrRegionName);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
hbase_compact_args_instance_init (HbaseCompactArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->tableNameOrRegionName = NULL;
  object->__isset_tableNameOrRegionName = FALSE;
}

static void 
hbase_compact_args_finalize (GObject *object)
{
  HbaseCompactArgs *tobject = HBASE_COMPACT_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->tableNameOrRegionName != NULL)
  {
    thrift_string_free(tobject->tableNameOrRegionName);
    tobject->tableNameOrRegionName = NULL;
  }
}

static void
hbase_compact_args_class_init (HbaseCompactArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = hbase_compact_args_read;
  struct_class->write = hbase_compact_args_write;

  gobject_class->finalize = hbase_compact_args_finalize;
  gobject_class->get_property = hbase_compact_args_get_property;
  gobject_class->set_property = hbase_compact_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_COMPACT_ARGS_TABLE_NAME_OR_REGION_NAME,
     g_param_spec_boxed ("tableNameOrRegionName",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));
}

GType
hbase_compact_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (HbaseCompactArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) hbase_compact_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (HbaseCompactArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) hbase_compact_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "HbaseCompactArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _HbaseCompactResultProperties
{
  PROP_HBASE_COMPACT_RESULT_0,
  PROP_HBASE_COMPACT_RESULT_IO
};

/* reads a hbase_compact_result object */
static gint32
hbase_compact_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  HbaseCompactResult * this_object = HBASE_COMPACT_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->io != NULL)
          {
            g_object_unref (this_object->io);
          }
          this_object->io = g_object_new (TYPE_I_O_ERROR, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
          {
            g_object_unref (this_object->io);
            this_object->io = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_io = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
hbase_compact_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  HbaseCompactResult * this_object = HBASE_COMPACT_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "HbaseCompactResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_io == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "io", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
hbase_compact_result_set_property (GObject *object,
                                   guint property_id,
                                   const GValue *value,
                                   GParamSpec *pspec)
{
  HbaseCompactResult *self = HBASE_COMPACT_RESULT (object);

  switch (property_id)
  {
    case PROP_HBASE_COMPACT_RESULT_IO:
      if (self->io != NULL)
        g_object_unref (self->io);
      self->io = g_value_dup_object (value);
      self->__isset_io = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
hbase_compact_result_get_property (GObject *object,
                                   guint property_id,
                                   GValue *value,
                                   GParamSpec *pspec)
{
  HbaseCompactResult *self = HBASE_COMPACT_RESULT (object);

  switch (property_id)
  {
    case PROP_HBASE_COMPACT_RESULT_IO:
      g_value_set_object (value, self->io);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
hbase_compact_result_instance_init (HbaseCompactResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->io = NULL;
  object->__isset_io = FALSE;
}

static void 
hbase_compact_result_finalize (GObject *object)
{
  HbaseCompactResult *tobject = HBASE_COMPACT_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->io != NULL)
  {
    g_object_unref(tobject->io);
    tobject->io = NULL;
  }
}

static void
hbase_compact_result_class_init (HbaseCompactResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = hbase_compact_result_read;
  struct_class->write = hbase_compact_result_write;

  gobject_class->finalize = hbase_compact_result_finalize;
  gobject_class->get_property = hbase_compact_result_get_property;
  gobject_class->set_property = hbase_compact_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_COMPACT_RESULT_IO,
     g_param_spec_object ("io",
                         NULL,
                         NULL,
                         TYPE_I_O_ERROR,
                         G_PARAM_READWRITE));
}

GType
hbase_compact_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (HbaseCompactResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) hbase_compact_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (HbaseCompactResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) hbase_compact_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "HbaseCompactResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _HbaseMajorCompactArgsProperties
{
  PROP_HBASE_MAJOR_COMPACT_ARGS_0,
  PROP_HBASE_MAJOR_COMPACT_ARGS_TABLE_NAME_OR_REGION_NAME
};

/* reads a hbase_major_compact_args object */
static gint32
hbase_major_compact_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  HbaseMajorCompactArgs * this_object = HBASE_MAJOR_COMPACT_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->tableNameOrRegionName != NULL)
          {
            g_free(this_object->tableNameOrRegionName);
            this_object->tableNameOrRegionName = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->tableNameOrRegionName = g_byte_array_new();
          g_byte_array_append (this_object->tableNameOrRegionName, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_tableNameOrRegionName = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
hbase_major_compact_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  HbaseMajorCompactArgs * this_object = HBASE_MAJOR_COMPACT_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "HbaseMajorCompactArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "tableNameOrRegionName", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->tableNameOrRegionName ? ((GByteArray *) this_object->tableNameOrRegionName)->data : NULL, this_object->tableNameOrRegionName ? ((GByteArray *) this_object->tableNameOrRegionName)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
hbase_major_compact_args_set_property (GObject *object,
                                       guint property_id,
                                       const GValue *value,
                                       GParamSpec *pspec)
{
  HbaseMajorCompactArgs *self = HBASE_MAJOR_COMPACT_ARGS (object);

  switch (property_id)
  {
    case PROP_HBASE_MAJOR_COMPACT_ARGS_TABLE_NAME_OR_REGION_NAME:
      if (self->tableNameOrRegionName != NULL)
        g_byte_array_unref (self->tableNameOrRegionName);
      self->tableNameOrRegionName = g_value_dup_boxed (value);
      self->__isset_tableNameOrRegionName = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
hbase_major_compact_args_get_property (GObject *object,
                                       guint property_id,
                                       GValue *value,
                                       GParamSpec *pspec)
{
  HbaseMajorCompactArgs *self = HBASE_MAJOR_COMPACT_ARGS (object);

  switch (property_id)
  {
    case PROP_HBASE_MAJOR_COMPACT_ARGS_TABLE_NAME_OR_REGION_NAME:
      g_value_set_boxed (value, self->tableNameOrRegionName);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
hbase_major_compact_args_instance_init (HbaseMajorCompactArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->tableNameOrRegionName = NULL;
  object->__isset_tableNameOrRegionName = FALSE;
}

static void 
hbase_major_compact_args_finalize (GObject *object)
{
  HbaseMajorCompactArgs *tobject = HBASE_MAJOR_COMPACT_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->tableNameOrRegionName != NULL)
  {
    thrift_string_free(tobject->tableNameOrRegionName);
    tobject->tableNameOrRegionName = NULL;
  }
}

static void
hbase_major_compact_args_class_init (HbaseMajorCompactArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = hbase_major_compact_args_read;
  struct_class->write = hbase_major_compact_args_write;

  gobject_class->finalize = hbase_major_compact_args_finalize;
  gobject_class->get_property = hbase_major_compact_args_get_property;
  gobject_class->set_property = hbase_major_compact_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_MAJOR_COMPACT_ARGS_TABLE_NAME_OR_REGION_NAME,
     g_param_spec_boxed ("tableNameOrRegionName",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));
}

GType
hbase_major_compact_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (HbaseMajorCompactArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) hbase_major_compact_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (HbaseMajorCompactArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) hbase_major_compact_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "HbaseMajorCompactArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _HbaseMajorCompactResultProperties
{
  PROP_HBASE_MAJOR_COMPACT_RESULT_0,
  PROP_HBASE_MAJOR_COMPACT_RESULT_IO
};

/* reads a hbase_major_compact_result object */
static gint32
hbase_major_compact_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  HbaseMajorCompactResult * this_object = HBASE_MAJOR_COMPACT_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->io != NULL)
          {
            g_object_unref (this_object->io);
          }
          this_object->io = g_object_new (TYPE_I_O_ERROR, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
          {
            g_object_unref (this_object->io);
            this_object->io = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_io = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
hbase_major_compact_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  HbaseMajorCompactResult * this_object = HBASE_MAJOR_COMPACT_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "HbaseMajorCompactResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_io == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "io", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
hbase_major_compact_result_set_property (GObject *object,
                                         guint property_id,
                                         const GValue *value,
                                         GParamSpec *pspec)
{
  HbaseMajorCompactResult *self = HBASE_MAJOR_COMPACT_RESULT (object);

  switch (property_id)
  {
    case PROP_HBASE_MAJOR_COMPACT_RESULT_IO:
      if (self->io != NULL)
        g_object_unref (self->io);
      self->io = g_value_dup_object (value);
      self->__isset_io = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
hbase_major_compact_result_get_property (GObject *object,
                                         guint property_id,
                                         GValue *value,
                                         GParamSpec *pspec)
{
  HbaseMajorCompactResult *self = HBASE_MAJOR_COMPACT_RESULT (object);

  switch (property_id)
  {
    case PROP_HBASE_MAJOR_COMPACT_RESULT_IO:
      g_value_set_object (value, self->io);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
hbase_major_compact_result_instance_init (HbaseMajorCompactResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->io = NULL;
  object->__isset_io = FALSE;
}

static void 
hbase_major_compact_result_finalize (GObject *object)
{
  HbaseMajorCompactResult *tobject = HBASE_MAJOR_COMPACT_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->io != NULL)
  {
    g_object_unref(tobject->io);
    tobject->io = NULL;
  }
}

static void
hbase_major_compact_result_class_init (HbaseMajorCompactResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = hbase_major_compact_result_read;
  struct_class->write = hbase_major_compact_result_write;

  gobject_class->finalize = hbase_major_compact_result_finalize;
  gobject_class->get_property = hbase_major_compact_result_get_property;
  gobject_class->set_property = hbase_major_compact_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_MAJOR_COMPACT_RESULT_IO,
     g_param_spec_object ("io",
                         NULL,
                         NULL,
                         TYPE_I_O_ERROR,
                         G_PARAM_READWRITE));
}

GType
hbase_major_compact_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (HbaseMajorCompactResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) hbase_major_compact_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (HbaseMajorCompactResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) hbase_major_compact_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "HbaseMajorCompactResultType",
                                   &type_info, 0);
  }

  return type;
}

/* reads a hbase_get_table_names_args object */
static gint32
hbase_get_table_names_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  HbaseGetTableNamesArgs * this_object = HBASE_GET_TABLE_NAMES_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
hbase_get_table_names_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  HbaseGetTableNamesArgs * this_object = HBASE_GET_TABLE_NAMES_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "HbaseGetTableNamesArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void 
hbase_get_table_names_args_instance_init (HbaseGetTableNamesArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
}

static void 
hbase_get_table_names_args_finalize (GObject *object)
{
  HbaseGetTableNamesArgs *tobject = HBASE_GET_TABLE_NAMES_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
hbase_get_table_names_args_class_init (HbaseGetTableNamesArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = hbase_get_table_names_args_read;
  struct_class->write = hbase_get_table_names_args_write;

  gobject_class->finalize = hbase_get_table_names_args_finalize;
}

GType
hbase_get_table_names_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (HbaseGetTableNamesArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) hbase_get_table_names_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (HbaseGetTableNamesArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) hbase_get_table_names_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "HbaseGetTableNamesArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _HbaseGetTableNamesResultProperties
{
  PROP_HBASE_GET_TABLE_NAMES_RESULT_0,
  PROP_HBASE_GET_TABLE_NAMES_RESULT_SUCCESS,
  PROP_HBASE_GET_TABLE_NAMES_RESULT_IO
};

/* reads a hbase_get_table_names_result object */
static gint32
hbase_get_table_names_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  HbaseGetTableNamesResult * this_object = HBASE_GET_TABLE_NAMES_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              GByteArray * _elem14 = NULL;
              if (_elem14 != NULL)
              {
                g_free(_elem14);
                _elem14 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              _elem14 = g_byte_array_new();
              g_byte_array_append (_elem14, (guint8 *) data, (guint) len);
              g_free (data);
              g_ptr_array_add (this_object->success, _elem14);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->io != NULL)
          {
            g_object_unref (this_object->io);
          }
          this_object->io = g_object_new (TYPE_I_O_ERROR, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
          {
            g_object_unref (this_object->io);
            this_object->io = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_io = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
hbase_get_table_names_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  HbaseGetTableNamesResult * this_object = HBASE_GET_TABLE_NAMES_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "HbaseGetTableNamesResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_LIST, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i15;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (this_object->success ? this_object->success->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i15 = 0; i15 < (this_object->success ? this_object->success->len : 0); i15++)
      {
        if ((ret = thrift_protocol_write_binary (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->success, i15)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->success, i15)))->data : NULL, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->success, i15)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->success, i15)))->len : 0, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_io == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "io", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
hbase_get_table_names_result_set_property (GObject *object,
                                           guint property_id,
                                           const GValue *value,
                                           GParamSpec *pspec)
{
  HbaseGetTableNamesResult *self = HBASE_GET_TABLE_NAMES_RESULT (object);

  switch (property_id)
  {
    case PROP_HBASE_GET_TABLE_NAMES_RESULT_SUCCESS:
      if (self->success != NULL)
        g_ptr_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    case PROP_HBASE_GET_TABLE_NAMES_RESULT_IO:
      if (self->io != NULL)
        g_object_unref (self->io);
      self->io = g_value_dup_object (value);
      self->__isset_io = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
hbase_get_table_names_result_get_property (GObject *object,
                                           guint property_id,
                                           GValue *value,
                                           GParamSpec *pspec)
{
  HbaseGetTableNamesResult *self = HBASE_GET_TABLE_NAMES_RESULT (object);

  switch (property_id)
  {
    case PROP_HBASE_GET_TABLE_NAMES_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    case PROP_HBASE_GET_TABLE_NAMES_RESULT_IO:
      g_value_set_object (value, self->io);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
hbase_get_table_names_result_instance_init (HbaseGetTableNamesResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_ptr_array_new_with_free_func (thrift_string_free);
  object->__isset_success = FALSE;
  object->io = NULL;
  object->__isset_io = FALSE;
}

static void 
hbase_get_table_names_result_finalize (GObject *object)
{
  HbaseGetTableNamesResult *tobject = HBASE_GET_TABLE_NAMES_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_ptr_array_unref (tobject->success);
    tobject->success = NULL;
  }
  if (tobject->io != NULL)
  {
    g_object_unref(tobject->io);
    tobject->io = NULL;
  }
}

static void
hbase_get_table_names_result_class_init (HbaseGetTableNamesResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = hbase_get_table_names_result_read;
  struct_class->write = hbase_get_table_names_result_write;

  gobject_class->finalize = hbase_get_table_names_result_finalize;
  gobject_class->get_property = hbase_get_table_names_result_get_property;
  gobject_class->set_property = hbase_get_table_names_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_GET_TABLE_NAMES_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_GET_TABLE_NAMES_RESULT_IO,
     g_param_spec_object ("io",
                         NULL,
                         NULL,
                         TYPE_I_O_ERROR,
                         G_PARAM_READWRITE));
}

GType
hbase_get_table_names_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (HbaseGetTableNamesResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) hbase_get_table_names_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (HbaseGetTableNamesResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) hbase_get_table_names_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "HbaseGetTableNamesResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _HbaseGetColumnDescriptorsArgsProperties
{
  PROP_HBASE_GET_COLUMN_DESCRIPTORS_ARGS_0,
  PROP_HBASE_GET_COLUMN_DESCRIPTORS_ARGS_TABLE_NAME
};

/* reads a hbase_get_column_descriptors_args object */
static gint32
hbase_get_column_descriptors_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  HbaseGetColumnDescriptorsArgs * this_object = HBASE_GET_COLUMN_DESCRIPTORS_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->tableName != NULL)
          {
            g_free(this_object->tableName);
            this_object->tableName = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->tableName = g_byte_array_new();
          g_byte_array_append (this_object->tableName, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_tableName = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
hbase_get_column_descriptors_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  HbaseGetColumnDescriptorsArgs * this_object = HBASE_GET_COLUMN_DESCRIPTORS_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "HbaseGetColumnDescriptorsArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "tableName", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->tableName ? ((GByteArray *) this_object->tableName)->data : NULL, this_object->tableName ? ((GByteArray *) this_object->tableName)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
hbase_get_column_descriptors_args_set_property (GObject *object,
                                                guint property_id,
                                                const GValue *value,
                                                GParamSpec *pspec)
{
  HbaseGetColumnDescriptorsArgs *self = HBASE_GET_COLUMN_DESCRIPTORS_ARGS (object);

  switch (property_id)
  {
    case PROP_HBASE_GET_COLUMN_DESCRIPTORS_ARGS_TABLE_NAME:
      if (self->tableName != NULL)
        g_byte_array_unref (self->tableName);
      self->tableName = g_value_dup_boxed (value);
      self->__isset_tableName = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
hbase_get_column_descriptors_args_get_property (GObject *object,
                                                guint property_id,
                                                GValue *value,
                                                GParamSpec *pspec)
{
  HbaseGetColumnDescriptorsArgs *self = HBASE_GET_COLUMN_DESCRIPTORS_ARGS (object);

  switch (property_id)
  {
    case PROP_HBASE_GET_COLUMN_DESCRIPTORS_ARGS_TABLE_NAME:
      g_value_set_boxed (value, self->tableName);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
hbase_get_column_descriptors_args_instance_init (HbaseGetColumnDescriptorsArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->tableName = NULL;
  object->__isset_tableName = FALSE;
}

static void 
hbase_get_column_descriptors_args_finalize (GObject *object)
{
  HbaseGetColumnDescriptorsArgs *tobject = HBASE_GET_COLUMN_DESCRIPTORS_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->tableName != NULL)
  {
    thrift_string_free(tobject->tableName);
    tobject->tableName = NULL;
  }
}

static void
hbase_get_column_descriptors_args_class_init (HbaseGetColumnDescriptorsArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = hbase_get_column_descriptors_args_read;
  struct_class->write = hbase_get_column_descriptors_args_write;

  gobject_class->finalize = hbase_get_column_descriptors_args_finalize;
  gobject_class->get_property = hbase_get_column_descriptors_args_get_property;
  gobject_class->set_property = hbase_get_column_descriptors_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_GET_COLUMN_DESCRIPTORS_ARGS_TABLE_NAME,
     g_param_spec_boxed ("tableName",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));
}

GType
hbase_get_column_descriptors_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (HbaseGetColumnDescriptorsArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) hbase_get_column_descriptors_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (HbaseGetColumnDescriptorsArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) hbase_get_column_descriptors_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "HbaseGetColumnDescriptorsArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _HbaseGetColumnDescriptorsResultProperties
{
  PROP_HBASE_GET_COLUMN_DESCRIPTORS_RESULT_0,
  PROP_HBASE_GET_COLUMN_DESCRIPTORS_RESULT_SUCCESS,
  PROP_HBASE_GET_COLUMN_DESCRIPTORS_RESULT_IO
};

/* reads a hbase_get_column_descriptors_result object */
static gint32
hbase_get_column_descriptors_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  HbaseGetColumnDescriptorsResult * this_object = HBASE_GET_COLUMN_DESCRIPTORS_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              Text key16 = NULL;
              ColumnDescriptor * val17 = NULL;
              if (key16 != NULL)
              {
                g_free(key16);
                key16 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              key16 = g_byte_array_new();
              g_byte_array_append (key16, (guint8 *) data, (guint) len);
              g_free (data);
              if ( val17 != NULL)
              {
                g_object_unref (val17);
              }
              val17 = g_object_new (TYPE_COLUMN_DESCRIPTOR, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (val17), protocol, error)) < 0)
              {
                g_object_unref (val17);
                return -1;
              }
              xfer += ret;
              if (this_object->success && key16)
                g_hash_table_insert ((GHashTable *)this_object->success, (gpointer) key16, (gpointer) val17);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->io != NULL)
          {
            g_object_unref (this_object->io);
          }
          this_object->io = g_object_new (TYPE_I_O_ERROR, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
          {
            g_object_unref (this_object->io);
            this_object->io = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_io = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
hbase_get_column_descriptors_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  HbaseGetColumnDescriptorsResult * this_object = HBASE_GET_COLUMN_DESCRIPTORS_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "HbaseGetColumnDescriptorsResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_MAP, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      Text key18 = NULL;
      ColumnDescriptor * val19 = NULL;
      GList *key_list = NULL, *iter = NULL;
      Text* keys;
      int i = 0, key_count;

      if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRUCT, this_object->success ? (gint32) g_hash_table_size ((GHashTable *) this_object->success) : 0, error)) < 0)
        return -1;
      xfer += ret;
      if (this_object->success)
        g_hash_table_foreach ((GHashTable *) this_object->success, thrift_hash_table_get_keys, &key_list);
      key_count = g_list_length (key_list);
      keys = g_newa (Text, key_count);
      for (iter = g_list_first (key_list); iter; iter = iter->next)
        keys[i++] = (Text) iter->data;
      g_list_free (key_list);

      for (i = 0; i < key_count; ++i)
      {
        key18 = keys[i];
        val19 = (ColumnDescriptor *) g_hash_table_lookup (((GHashTable *) this_object->success), (gpointer) key18);

        if ((ret = thrift_protocol_write_binary (protocol,  key18 ? ((GByteArray *)  key18)->data : NULL,  key18 ? ((GByteArray *)  key18)->len : 0, error)) < 0)
          return -1;
        xfer += ret;

        if ((ret = thrift_struct_write (THRIFT_STRUCT ( val19), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_io == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "io", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
hbase_get_column_descriptors_result_set_property (GObject *object,
                                                  guint property_id,
                                                  const GValue *value,
                                                  GParamSpec *pspec)
{
  HbaseGetColumnDescriptorsResult *self = HBASE_GET_COLUMN_DESCRIPTORS_RESULT (object);

  switch (property_id)
  {
    case PROP_HBASE_GET_COLUMN_DESCRIPTORS_RESULT_SUCCESS:
      if (self->success != NULL)
        g_hash_table_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    case PROP_HBASE_GET_COLUMN_DESCRIPTORS_RESULT_IO:
      if (self->io != NULL)
        g_object_unref (self->io);
      self->io = g_value_dup_object (value);
      self->__isset_io = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
hbase_get_column_descriptors_result_get_property (GObject *object,
                                                  guint property_id,
                                                  GValue *value,
                                                  GParamSpec *pspec)
{
  HbaseGetColumnDescriptorsResult *self = HBASE_GET_COLUMN_DESCRIPTORS_RESULT (object);

  switch (property_id)
  {
    case PROP_HBASE_GET_COLUMN_DESCRIPTORS_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    case PROP_HBASE_GET_COLUMN_DESCRIPTORS_RESULT_IO:
      g_value_set_object (value, self->io);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
hbase_get_column_descriptors_result_instance_init (HbaseGetColumnDescriptorsResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_hash_table_new_full (g_str_hash, g_str_equal, thrift_string_free, g_object_unref);
  object->__isset_success = FALSE;
  object->io = NULL;
  object->__isset_io = FALSE;
}

static void 
hbase_get_column_descriptors_result_finalize (GObject *object)
{
  HbaseGetColumnDescriptorsResult *tobject = HBASE_GET_COLUMN_DESCRIPTORS_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_hash_table_destroy (tobject->success);
    tobject->success = NULL;
  }
  if (tobject->io != NULL)
  {
    g_object_unref(tobject->io);
    tobject->io = NULL;
  }
}

static void
hbase_get_column_descriptors_result_class_init (HbaseGetColumnDescriptorsResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = hbase_get_column_descriptors_result_read;
  struct_class->write = hbase_get_column_descriptors_result_write;

  gobject_class->finalize = hbase_get_column_descriptors_result_finalize;
  gobject_class->get_property = hbase_get_column_descriptors_result_get_property;
  gobject_class->set_property = hbase_get_column_descriptors_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_GET_COLUMN_DESCRIPTORS_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_GET_COLUMN_DESCRIPTORS_RESULT_IO,
     g_param_spec_object ("io",
                         NULL,
                         NULL,
                         TYPE_I_O_ERROR,
                         G_PARAM_READWRITE));
}

GType
hbase_get_column_descriptors_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (HbaseGetColumnDescriptorsResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) hbase_get_column_descriptors_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (HbaseGetColumnDescriptorsResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) hbase_get_column_descriptors_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "HbaseGetColumnDescriptorsResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _HbaseGetTableRegionsArgsProperties
{
  PROP_HBASE_GET_TABLE_REGIONS_ARGS_0,
  PROP_HBASE_GET_TABLE_REGIONS_ARGS_TABLE_NAME
};

/* reads a hbase_get_table_regions_args object */
static gint32
hbase_get_table_regions_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  HbaseGetTableRegionsArgs * this_object = HBASE_GET_TABLE_REGIONS_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->tableName != NULL)
          {
            g_free(this_object->tableName);
            this_object->tableName = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->tableName = g_byte_array_new();
          g_byte_array_append (this_object->tableName, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_tableName = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
hbase_get_table_regions_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  HbaseGetTableRegionsArgs * this_object = HBASE_GET_TABLE_REGIONS_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "HbaseGetTableRegionsArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "tableName", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->tableName ? ((GByteArray *) this_object->tableName)->data : NULL, this_object->tableName ? ((GByteArray *) this_object->tableName)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
hbase_get_table_regions_args_set_property (GObject *object,
                                           guint property_id,
                                           const GValue *value,
                                           GParamSpec *pspec)
{
  HbaseGetTableRegionsArgs *self = HBASE_GET_TABLE_REGIONS_ARGS (object);

  switch (property_id)
  {
    case PROP_HBASE_GET_TABLE_REGIONS_ARGS_TABLE_NAME:
      if (self->tableName != NULL)
        g_byte_array_unref (self->tableName);
      self->tableName = g_value_dup_boxed (value);
      self->__isset_tableName = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
hbase_get_table_regions_args_get_property (GObject *object,
                                           guint property_id,
                                           GValue *value,
                                           GParamSpec *pspec)
{
  HbaseGetTableRegionsArgs *self = HBASE_GET_TABLE_REGIONS_ARGS (object);

  switch (property_id)
  {
    case PROP_HBASE_GET_TABLE_REGIONS_ARGS_TABLE_NAME:
      g_value_set_boxed (value, self->tableName);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
hbase_get_table_regions_args_instance_init (HbaseGetTableRegionsArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->tableName = NULL;
  object->__isset_tableName = FALSE;
}

static void 
hbase_get_table_regions_args_finalize (GObject *object)
{
  HbaseGetTableRegionsArgs *tobject = HBASE_GET_TABLE_REGIONS_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->tableName != NULL)
  {
    thrift_string_free(tobject->tableName);
    tobject->tableName = NULL;
  }
}

static void
hbase_get_table_regions_args_class_init (HbaseGetTableRegionsArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = hbase_get_table_regions_args_read;
  struct_class->write = hbase_get_table_regions_args_write;

  gobject_class->finalize = hbase_get_table_regions_args_finalize;
  gobject_class->get_property = hbase_get_table_regions_args_get_property;
  gobject_class->set_property = hbase_get_table_regions_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_GET_TABLE_REGIONS_ARGS_TABLE_NAME,
     g_param_spec_boxed ("tableName",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));
}

GType
hbase_get_table_regions_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (HbaseGetTableRegionsArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) hbase_get_table_regions_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (HbaseGetTableRegionsArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) hbase_get_table_regions_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "HbaseGetTableRegionsArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _HbaseGetTableRegionsResultProperties
{
  PROP_HBASE_GET_TABLE_REGIONS_RESULT_0,
  PROP_HBASE_GET_TABLE_REGIONS_RESULT_SUCCESS,
  PROP_HBASE_GET_TABLE_REGIONS_RESULT_IO
};

/* reads a hbase_get_table_regions_result object */
static gint32
hbase_get_table_regions_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  HbaseGetTableRegionsResult * this_object = HBASE_GET_TABLE_REGIONS_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              TRegionInfo * _elem20 = NULL;
              if ( _elem20 != NULL)
              {
                g_object_unref (_elem20);
              }
              _elem20 = g_object_new (TYPE_T_REGION_INFO, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem20), protocol, error)) < 0)
              {
                g_object_unref (_elem20);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->success, _elem20);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->io != NULL)
          {
            g_object_unref (this_object->io);
          }
          this_object->io = g_object_new (TYPE_I_O_ERROR, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
          {
            g_object_unref (this_object->io);
            this_object->io = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_io = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
hbase_get_table_regions_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  HbaseGetTableRegionsResult * this_object = HBASE_GET_TABLE_REGIONS_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "HbaseGetTableRegionsResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_LIST, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i21;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->success ? this_object->success->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i21 = 0; i21 < (this_object->success ? this_object->success->len : 0); i21++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->success, i21))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_io == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "io", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
hbase_get_table_regions_result_set_property (GObject *object,
                                             guint property_id,
                                             const GValue *value,
                                             GParamSpec *pspec)
{
  HbaseGetTableRegionsResult *self = HBASE_GET_TABLE_REGIONS_RESULT (object);

  switch (property_id)
  {
    case PROP_HBASE_GET_TABLE_REGIONS_RESULT_SUCCESS:
      if (self->success != NULL)
        g_ptr_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    case PROP_HBASE_GET_TABLE_REGIONS_RESULT_IO:
      if (self->io != NULL)
        g_object_unref (self->io);
      self->io = g_value_dup_object (value);
      self->__isset_io = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
hbase_get_table_regions_result_get_property (GObject *object,
                                             guint property_id,
                                             GValue *value,
                                             GParamSpec *pspec)
{
  HbaseGetTableRegionsResult *self = HBASE_GET_TABLE_REGIONS_RESULT (object);

  switch (property_id)
  {
    case PROP_HBASE_GET_TABLE_REGIONS_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    case PROP_HBASE_GET_TABLE_REGIONS_RESULT_IO:
      g_value_set_object (value, self->io);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
hbase_get_table_regions_result_instance_init (HbaseGetTableRegionsResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_success = FALSE;
  object->io = NULL;
  object->__isset_io = FALSE;
}

static void 
hbase_get_table_regions_result_finalize (GObject *object)
{
  HbaseGetTableRegionsResult *tobject = HBASE_GET_TABLE_REGIONS_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_ptr_array_unref (tobject->success);
    tobject->success = NULL;
  }
  if (tobject->io != NULL)
  {
    g_object_unref(tobject->io);
    tobject->io = NULL;
  }
}

static void
hbase_get_table_regions_result_class_init (HbaseGetTableRegionsResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = hbase_get_table_regions_result_read;
  struct_class->write = hbase_get_table_regions_result_write;

  gobject_class->finalize = hbase_get_table_regions_result_finalize;
  gobject_class->get_property = hbase_get_table_regions_result_get_property;
  gobject_class->set_property = hbase_get_table_regions_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_GET_TABLE_REGIONS_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_GET_TABLE_REGIONS_RESULT_IO,
     g_param_spec_object ("io",
                         NULL,
                         NULL,
                         TYPE_I_O_ERROR,
                         G_PARAM_READWRITE));
}

GType
hbase_get_table_regions_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (HbaseGetTableRegionsResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) hbase_get_table_regions_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (HbaseGetTableRegionsResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) hbase_get_table_regions_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "HbaseGetTableRegionsResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _HbaseCreateTableArgsProperties
{
  PROP_HBASE_CREATE_TABLE_ARGS_0,
  PROP_HBASE_CREATE_TABLE_ARGS_TABLE_NAME,
  PROP_HBASE_CREATE_TABLE_ARGS_COLUMN_FAMILIES
};

/* reads a hbase_create_table_args object */
static gint32
hbase_create_table_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  HbaseCreateTableArgs * this_object = HBASE_CREATE_TABLE_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->tableName != NULL)
          {
            g_free(this_object->tableName);
            this_object->tableName = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->tableName = g_byte_array_new();
          g_byte_array_append (this_object->tableName, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_tableName = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              ColumnDescriptor * _elem22 = NULL;
              if ( _elem22 != NULL)
              {
                g_object_unref (_elem22);
              }
              _elem22 = g_object_new (TYPE_COLUMN_DESCRIPTOR, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem22), protocol, error)) < 0)
              {
                g_object_unref (_elem22);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->columnFamilies, _elem22);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_columnFamilies = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
hbase_create_table_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  HbaseCreateTableArgs * this_object = HBASE_CREATE_TABLE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "HbaseCreateTableArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "tableName", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->tableName ? ((GByteArray *) this_object->tableName)->data : NULL, this_object->tableName ? ((GByteArray *) this_object->tableName)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "columnFamilies", T_LIST, 2, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i23;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->columnFamilies ? this_object->columnFamilies->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i23 = 0; i23 < (this_object->columnFamilies ? this_object->columnFamilies->len : 0); i23++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->columnFamilies, i23))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
hbase_create_table_args_set_property (GObject *object,
                                      guint property_id,
                                      const GValue *value,
                                      GParamSpec *pspec)
{
  HbaseCreateTableArgs *self = HBASE_CREATE_TABLE_ARGS (object);

  switch (property_id)
  {
    case PROP_HBASE_CREATE_TABLE_ARGS_TABLE_NAME:
      if (self->tableName != NULL)
        g_byte_array_unref (self->tableName);
      self->tableName = g_value_dup_boxed (value);
      self->__isset_tableName = TRUE;
      break;

    case PROP_HBASE_CREATE_TABLE_ARGS_COLUMN_FAMILIES:
      if (self->columnFamilies != NULL)
        g_ptr_array_unref (self->columnFamilies);
      self->columnFamilies = g_value_dup_boxed (value);
      self->__isset_columnFamilies = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
hbase_create_table_args_get_property (GObject *object,
                                      guint property_id,
                                      GValue *value,
                                      GParamSpec *pspec)
{
  HbaseCreateTableArgs *self = HBASE_CREATE_TABLE_ARGS (object);

  switch (property_id)
  {
    case PROP_HBASE_CREATE_TABLE_ARGS_TABLE_NAME:
      g_value_set_boxed (value, self->tableName);
      break;

    case PROP_HBASE_CREATE_TABLE_ARGS_COLUMN_FAMILIES:
      g_value_set_boxed (value, self->columnFamilies);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
hbase_create_table_args_instance_init (HbaseCreateTableArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->tableName = NULL;
  object->__isset_tableName = FALSE;
  object->columnFamilies = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_columnFamilies = FALSE;
}

static void 
hbase_create_table_args_finalize (GObject *object)
{
  HbaseCreateTableArgs *tobject = HBASE_CREATE_TABLE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->tableName != NULL)
  {
    thrift_string_free(tobject->tableName);
    tobject->tableName = NULL;
  }
  if (tobject->columnFamilies != NULL)
  {
    g_ptr_array_unref (tobject->columnFamilies);
    tobject->columnFamilies = NULL;
  }
}

static void
hbase_create_table_args_class_init (HbaseCreateTableArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = hbase_create_table_args_read;
  struct_class->write = hbase_create_table_args_write;

  gobject_class->finalize = hbase_create_table_args_finalize;
  gobject_class->get_property = hbase_create_table_args_get_property;
  gobject_class->set_property = hbase_create_table_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_CREATE_TABLE_ARGS_TABLE_NAME,
     g_param_spec_boxed ("tableName",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_CREATE_TABLE_ARGS_COLUMN_FAMILIES,
     g_param_spec_boxed ("columnFamilies",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
hbase_create_table_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (HbaseCreateTableArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) hbase_create_table_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (HbaseCreateTableArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) hbase_create_table_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "HbaseCreateTableArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _HbaseCreateTableResultProperties
{
  PROP_HBASE_CREATE_TABLE_RESULT_0,
  PROP_HBASE_CREATE_TABLE_RESULT_IO,
  PROP_HBASE_CREATE_TABLE_RESULT_IA,
  PROP_HBASE_CREATE_TABLE_RESULT_EXIST
};

/* reads a hbase_create_table_result object */
static gint32
hbase_create_table_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  HbaseCreateTableResult * this_object = HBASE_CREATE_TABLE_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->io != NULL)
          {
            g_object_unref (this_object->io);
          }
          this_object->io = g_object_new (TYPE_I_O_ERROR, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
          {
            g_object_unref (this_object->io);
            this_object->io = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_io = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ia != NULL)
          {
            g_object_unref (this_object->ia);
          }
          this_object->ia = g_object_new (TYPE_ILLEGAL_ARGUMENT, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ia), protocol, error)) < 0)
          {
            g_object_unref (this_object->ia);
            this_object->ia = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ia = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->exist != NULL)
          {
            g_object_unref (this_object->exist);
          }
          this_object->exist = g_object_new (TYPE_ALREADY_EXISTS, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->exist), protocol, error)) < 0)
          {
            g_object_unref (this_object->exist);
            this_object->exist = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_exist = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
hbase_create_table_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  HbaseCreateTableResult * this_object = HBASE_CREATE_TABLE_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "HbaseCreateTableResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_io == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "io", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ia == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ia", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ia), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_exist == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "exist", T_STRUCT, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->exist), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
hbase_create_table_result_set_property (GObject *object,
                                        guint property_id,
                                        const GValue *value,
                                        GParamSpec *pspec)
{
  HbaseCreateTableResult *self = HBASE_CREATE_TABLE_RESULT (object);

  switch (property_id)
  {
    case PROP_HBASE_CREATE_TABLE_RESULT_IO:
      if (self->io != NULL)
        g_object_unref (self->io);
      self->io = g_value_dup_object (value);
      self->__isset_io = TRUE;
      break;

    case PROP_HBASE_CREATE_TABLE_RESULT_IA:
      if (self->ia != NULL)
        g_object_unref (self->ia);
      self->ia = g_value_dup_object (value);
      self->__isset_ia = TRUE;
      break;

    case PROP_HBASE_CREATE_TABLE_RESULT_EXIST:
      if (self->exist != NULL)
        g_object_unref (self->exist);
      self->exist = g_value_dup_object (value);
      self->__isset_exist = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
hbase_create_table_result_get_property (GObject *object,
                                        guint property_id,
                                        GValue *value,
                                        GParamSpec *pspec)
{
  HbaseCreateTableResult *self = HBASE_CREATE_TABLE_RESULT (object);

  switch (property_id)
  {
    case PROP_HBASE_CREATE_TABLE_RESULT_IO:
      g_value_set_object (value, self->io);
      break;

    case PROP_HBASE_CREATE_TABLE_RESULT_IA:
      g_value_set_object (value, self->ia);
      break;

    case PROP_HBASE_CREATE_TABLE_RESULT_EXIST:
      g_value_set_object (value, self->exist);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
hbase_create_table_result_instance_init (HbaseCreateTableResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->io = NULL;
  object->__isset_io = FALSE;
  object->ia = NULL;
  object->__isset_ia = FALSE;
  object->exist = NULL;
  object->__isset_exist = FALSE;
}

static void 
hbase_create_table_result_finalize (GObject *object)
{
  HbaseCreateTableResult *tobject = HBASE_CREATE_TABLE_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->io != NULL)
  {
    g_object_unref(tobject->io);
    tobject->io = NULL;
  }
  if (tobject->ia != NULL)
  {
    g_object_unref(tobject->ia);
    tobject->ia = NULL;
  }
  if (tobject->exist != NULL)
  {
    g_object_unref(tobject->exist);
    tobject->exist = NULL;
  }
}

static void
hbase_create_table_result_class_init (HbaseCreateTableResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = hbase_create_table_result_read;
  struct_class->write = hbase_create_table_result_write;

  gobject_class->finalize = hbase_create_table_result_finalize;
  gobject_class->get_property = hbase_create_table_result_get_property;
  gobject_class->set_property = hbase_create_table_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_CREATE_TABLE_RESULT_IO,
     g_param_spec_object ("io",
                         NULL,
                         NULL,
                         TYPE_I_O_ERROR,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_CREATE_TABLE_RESULT_IA,
     g_param_spec_object ("ia",
                         NULL,
                         NULL,
                         TYPE_ILLEGAL_ARGUMENT,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_CREATE_TABLE_RESULT_EXIST,
     g_param_spec_object ("exist",
                         NULL,
                         NULL,
                         TYPE_ALREADY_EXISTS,
                         G_PARAM_READWRITE));
}

GType
hbase_create_table_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (HbaseCreateTableResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) hbase_create_table_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (HbaseCreateTableResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) hbase_create_table_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "HbaseCreateTableResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _HbaseDeleteTableArgsProperties
{
  PROP_HBASE_DELETE_TABLE_ARGS_0,
  PROP_HBASE_DELETE_TABLE_ARGS_TABLE_NAME
};

/* reads a hbase_delete_table_args object */
static gint32
hbase_delete_table_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  HbaseDeleteTableArgs * this_object = HBASE_DELETE_TABLE_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->tableName != NULL)
          {
            g_free(this_object->tableName);
            this_object->tableName = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->tableName = g_byte_array_new();
          g_byte_array_append (this_object->tableName, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_tableName = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
hbase_delete_table_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  HbaseDeleteTableArgs * this_object = HBASE_DELETE_TABLE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "HbaseDeleteTableArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "tableName", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->tableName ? ((GByteArray *) this_object->tableName)->data : NULL, this_object->tableName ? ((GByteArray *) this_object->tableName)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
hbase_delete_table_args_set_property (GObject *object,
                                      guint property_id,
                                      const GValue *value,
                                      GParamSpec *pspec)
{
  HbaseDeleteTableArgs *self = HBASE_DELETE_TABLE_ARGS (object);

  switch (property_id)
  {
    case PROP_HBASE_DELETE_TABLE_ARGS_TABLE_NAME:
      if (self->tableName != NULL)
        g_byte_array_unref (self->tableName);
      self->tableName = g_value_dup_boxed (value);
      self->__isset_tableName = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
hbase_delete_table_args_get_property (GObject *object,
                                      guint property_id,
                                      GValue *value,
                                      GParamSpec *pspec)
{
  HbaseDeleteTableArgs *self = HBASE_DELETE_TABLE_ARGS (object);

  switch (property_id)
  {
    case PROP_HBASE_DELETE_TABLE_ARGS_TABLE_NAME:
      g_value_set_boxed (value, self->tableName);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
hbase_delete_table_args_instance_init (HbaseDeleteTableArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->tableName = NULL;
  object->__isset_tableName = FALSE;
}

static void 
hbase_delete_table_args_finalize (GObject *object)
{
  HbaseDeleteTableArgs *tobject = HBASE_DELETE_TABLE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->tableName != NULL)
  {
    thrift_string_free(tobject->tableName);
    tobject->tableName = NULL;
  }
}

static void
hbase_delete_table_args_class_init (HbaseDeleteTableArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = hbase_delete_table_args_read;
  struct_class->write = hbase_delete_table_args_write;

  gobject_class->finalize = hbase_delete_table_args_finalize;
  gobject_class->get_property = hbase_delete_table_args_get_property;
  gobject_class->set_property = hbase_delete_table_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_DELETE_TABLE_ARGS_TABLE_NAME,
     g_param_spec_boxed ("tableName",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));
}

GType
hbase_delete_table_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (HbaseDeleteTableArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) hbase_delete_table_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (HbaseDeleteTableArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) hbase_delete_table_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "HbaseDeleteTableArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _HbaseDeleteTableResultProperties
{
  PROP_HBASE_DELETE_TABLE_RESULT_0,
  PROP_HBASE_DELETE_TABLE_RESULT_IO
};

/* reads a hbase_delete_table_result object */
static gint32
hbase_delete_table_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  HbaseDeleteTableResult * this_object = HBASE_DELETE_TABLE_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->io != NULL)
          {
            g_object_unref (this_object->io);
          }
          this_object->io = g_object_new (TYPE_I_O_ERROR, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
          {
            g_object_unref (this_object->io);
            this_object->io = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_io = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
hbase_delete_table_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  HbaseDeleteTableResult * this_object = HBASE_DELETE_TABLE_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "HbaseDeleteTableResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_io == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "io", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
hbase_delete_table_result_set_property (GObject *object,
                                        guint property_id,
                                        const GValue *value,
                                        GParamSpec *pspec)
{
  HbaseDeleteTableResult *self = HBASE_DELETE_TABLE_RESULT (object);

  switch (property_id)
  {
    case PROP_HBASE_DELETE_TABLE_RESULT_IO:
      if (self->io != NULL)
        g_object_unref (self->io);
      self->io = g_value_dup_object (value);
      self->__isset_io = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
hbase_delete_table_result_get_property (GObject *object,
                                        guint property_id,
                                        GValue *value,
                                        GParamSpec *pspec)
{
  HbaseDeleteTableResult *self = HBASE_DELETE_TABLE_RESULT (object);

  switch (property_id)
  {
    case PROP_HBASE_DELETE_TABLE_RESULT_IO:
      g_value_set_object (value, self->io);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
hbase_delete_table_result_instance_init (HbaseDeleteTableResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->io = NULL;
  object->__isset_io = FALSE;
}

static void 
hbase_delete_table_result_finalize (GObject *object)
{
  HbaseDeleteTableResult *tobject = HBASE_DELETE_TABLE_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->io != NULL)
  {
    g_object_unref(tobject->io);
    tobject->io = NULL;
  }
}

static void
hbase_delete_table_result_class_init (HbaseDeleteTableResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = hbase_delete_table_result_read;
  struct_class->write = hbase_delete_table_result_write;

  gobject_class->finalize = hbase_delete_table_result_finalize;
  gobject_class->get_property = hbase_delete_table_result_get_property;
  gobject_class->set_property = hbase_delete_table_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_DELETE_TABLE_RESULT_IO,
     g_param_spec_object ("io",
                         NULL,
                         NULL,
                         TYPE_I_O_ERROR,
                         G_PARAM_READWRITE));
}

GType
hbase_delete_table_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (HbaseDeleteTableResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) hbase_delete_table_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (HbaseDeleteTableResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) hbase_delete_table_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "HbaseDeleteTableResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _HbaseGetArgsProperties
{
  PROP_HBASE_GET_ARGS_0,
  PROP_HBASE_GET_ARGS_TABLE_NAME,
  PROP_HBASE_GET_ARGS_ROW,
  PROP_HBASE_GET_ARGS_COLUMN,
  PROP_HBASE_GET_ARGS_ATTRIBUTES
};

/* reads a hbase_get_args object */
static gint32
hbase_get_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  HbaseGetArgs * this_object = HBASE_GET_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->tableName != NULL)
          {
            g_free(this_object->tableName);
            this_object->tableName = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->tableName = g_byte_array_new();
          g_byte_array_append (this_object->tableName, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_tableName = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->row != NULL)
          {
            g_free(this_object->row);
            this_object->row = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->row = g_byte_array_new();
          g_byte_array_append (this_object->row, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_row = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if (this_object->column != NULL)
          {
            g_free(this_object->column);
            this_object->column = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->column = g_byte_array_new();
          g_byte_array_append (this_object->column, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_column = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              Text key24 = NULL;
              Text val25 = NULL;
              if (key24 != NULL)
              {
                g_free(key24);
                key24 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              key24 = g_byte_array_new();
              g_byte_array_append (key24, (guint8 *) data, (guint) len);
              g_free (data);
              if (val25 != NULL)
              {
                g_free(val25);
                val25 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              val25 = g_byte_array_new();
              g_byte_array_append (val25, (guint8 *) data, (guint) len);
              g_free (data);
              if (this_object->attributes && key24)
                g_hash_table_insert ((GHashTable *)this_object->attributes, (gpointer) key24, (gpointer) val25);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_attributes = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
hbase_get_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  HbaseGetArgs * this_object = HBASE_GET_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "HbaseGetArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "tableName", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->tableName ? ((GByteArray *) this_object->tableName)->data : NULL, this_object->tableName ? ((GByteArray *) this_object->tableName)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "row", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->row ? ((GByteArray *) this_object->row)->data : NULL, this_object->row ? ((GByteArray *) this_object->row)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "column", T_STRING, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->column ? ((GByteArray *) this_object->column)->data : NULL, this_object->column ? ((GByteArray *) this_object->column)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "attributes", T_MAP, 4, error)) < 0)
    return -1;
  xfer += ret;
  {
    Text key26 = NULL;
    Text val27 = NULL;
    GList *key_list = NULL, *iter = NULL;
    Text* keys;
    int i = 0, key_count;

    if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRING, this_object->attributes ? (gint32) g_hash_table_size ((GHashTable *) this_object->attributes) : 0, error)) < 0)
      return -1;
    xfer += ret;
    if (this_object->attributes)
      g_hash_table_foreach ((GHashTable *) this_object->attributes, thrift_hash_table_get_keys, &key_list);
    key_count = g_list_length (key_list);
    keys = g_newa (Text, key_count);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
      keys[i++] = (Text) iter->data;
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key26 = keys[i];
      val27 = (Text) g_hash_table_lookup (((GHashTable *) this_object->attributes), (gpointer) key26);

      if ((ret = thrift_protocol_write_binary (protocol,  key26 ? ((GByteArray *)  key26)->data : NULL,  key26 ? ((GByteArray *)  key26)->len : 0, error)) < 0)
        return -1;
      xfer += ret;

      if ((ret = thrift_protocol_write_binary (protocol,  val27 ? ((GByteArray *)  val27)->data : NULL,  val27 ? ((GByteArray *)  val27)->len : 0, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
hbase_get_args_set_property (GObject *object,
                             guint property_id,
                             const GValue *value,
                             GParamSpec *pspec)
{
  HbaseGetArgs *self = HBASE_GET_ARGS (object);

  switch (property_id)
  {
    case PROP_HBASE_GET_ARGS_TABLE_NAME:
      if (self->tableName != NULL)
        g_byte_array_unref (self->tableName);
      self->tableName = g_value_dup_boxed (value);
      self->__isset_tableName = TRUE;
      break;

    case PROP_HBASE_GET_ARGS_ROW:
      if (self->row != NULL)
        g_byte_array_unref (self->row);
      self->row = g_value_dup_boxed (value);
      self->__isset_row = TRUE;
      break;

    case PROP_HBASE_GET_ARGS_COLUMN:
      if (self->column != NULL)
        g_byte_array_unref (self->column);
      self->column = g_value_dup_boxed (value);
      self->__isset_column = TRUE;
      break;

    case PROP_HBASE_GET_ARGS_ATTRIBUTES:
      if (self->attributes != NULL)
        g_hash_table_unref (self->attributes);
      self->attributes = g_value_dup_boxed (value);
      self->__isset_attributes = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
hbase_get_args_get_property (GObject *object,
                             guint property_id,
                             GValue *value,
                             GParamSpec *pspec)
{
  HbaseGetArgs *self = HBASE_GET_ARGS (object);

  switch (property_id)
  {
    case PROP_HBASE_GET_ARGS_TABLE_NAME:
      g_value_set_boxed (value, self->tableName);
      break;

    case PROP_HBASE_GET_ARGS_ROW:
      g_value_set_boxed (value, self->row);
      break;

    case PROP_HBASE_GET_ARGS_COLUMN:
      g_value_set_boxed (value, self->column);
      break;

    case PROP_HBASE_GET_ARGS_ATTRIBUTES:
      g_value_set_boxed (value, self->attributes);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
hbase_get_args_instance_init (HbaseGetArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->tableName = NULL;
  object->__isset_tableName = FALSE;
  object->row = NULL;
  object->__isset_row = FALSE;
  object->column = NULL;
  object->__isset_column = FALSE;
  object->attributes = g_hash_table_new_full (g_str_hash, g_str_equal, thrift_string_free, thrift_string_free);
  object->__isset_attributes = FALSE;
}

static void 
hbase_get_args_finalize (GObject *object)
{
  HbaseGetArgs *tobject = HBASE_GET_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->tableName != NULL)
  {
    thrift_string_free(tobject->tableName);
    tobject->tableName = NULL;
  }
  if (tobject->row != NULL)
  {
    thrift_string_free(tobject->row);
    tobject->row = NULL;
  }
  if (tobject->column != NULL)
  {
    thrift_string_free(tobject->column);
    tobject->column = NULL;
  }
  if (tobject->attributes != NULL)
  {
    g_hash_table_destroy (tobject->attributes);
    tobject->attributes = NULL;
  }
}

static void
hbase_get_args_class_init (HbaseGetArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = hbase_get_args_read;
  struct_class->write = hbase_get_args_write;

  gobject_class->finalize = hbase_get_args_finalize;
  gobject_class->get_property = hbase_get_args_get_property;
  gobject_class->set_property = hbase_get_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_GET_ARGS_TABLE_NAME,
     g_param_spec_boxed ("tableName",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_GET_ARGS_ROW,
     g_param_spec_boxed ("row",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_GET_ARGS_COLUMN,
     g_param_spec_boxed ("column",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_GET_ARGS_ATTRIBUTES,
     g_param_spec_boxed ("attributes",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));
}

GType
hbase_get_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (HbaseGetArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) hbase_get_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (HbaseGetArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) hbase_get_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "HbaseGetArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _HbaseGetResultProperties
{
  PROP_HBASE_GET_RESULT_0,
  PROP_HBASE_GET_RESULT_SUCCESS,
  PROP_HBASE_GET_RESULT_IO
};

/* reads a hbase_get_result object */
static gint32
hbase_get_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  HbaseGetResult * this_object = HBASE_GET_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              TCell * _elem28 = NULL;
              if ( _elem28 != NULL)
              {
                g_object_unref (_elem28);
              }
              _elem28 = g_object_new (TYPE_T_CELL, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem28), protocol, error)) < 0)
              {
                g_object_unref (_elem28);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->success, _elem28);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->io != NULL)
          {
            g_object_unref (this_object->io);
          }
          this_object->io = g_object_new (TYPE_I_O_ERROR, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
          {
            g_object_unref (this_object->io);
            this_object->io = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_io = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
hbase_get_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  HbaseGetResult * this_object = HBASE_GET_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "HbaseGetResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_LIST, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i29;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->success ? this_object->success->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i29 = 0; i29 < (this_object->success ? this_object->success->len : 0); i29++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->success, i29))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_io == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "io", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
hbase_get_result_set_property (GObject *object,
                               guint property_id,
                               const GValue *value,
                               GParamSpec *pspec)
{
  HbaseGetResult *self = HBASE_GET_RESULT (object);

  switch (property_id)
  {
    case PROP_HBASE_GET_RESULT_SUCCESS:
      if (self->success != NULL)
        g_ptr_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    case PROP_HBASE_GET_RESULT_IO:
      if (self->io != NULL)
        g_object_unref (self->io);
      self->io = g_value_dup_object (value);
      self->__isset_io = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
hbase_get_result_get_property (GObject *object,
                               guint property_id,
                               GValue *value,
                               GParamSpec *pspec)
{
  HbaseGetResult *self = HBASE_GET_RESULT (object);

  switch (property_id)
  {
    case PROP_HBASE_GET_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    case PROP_HBASE_GET_RESULT_IO:
      g_value_set_object (value, self->io);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
hbase_get_result_instance_init (HbaseGetResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_success = FALSE;
  object->io = NULL;
  object->__isset_io = FALSE;
}

static void 
hbase_get_result_finalize (GObject *object)
{
  HbaseGetResult *tobject = HBASE_GET_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_ptr_array_unref (tobject->success);
    tobject->success = NULL;
  }
  if (tobject->io != NULL)
  {
    g_object_unref(tobject->io);
    tobject->io = NULL;
  }
}

static void
hbase_get_result_class_init (HbaseGetResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = hbase_get_result_read;
  struct_class->write = hbase_get_result_write;

  gobject_class->finalize = hbase_get_result_finalize;
  gobject_class->get_property = hbase_get_result_get_property;
  gobject_class->set_property = hbase_get_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_GET_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_GET_RESULT_IO,
     g_param_spec_object ("io",
                         NULL,
                         NULL,
                         TYPE_I_O_ERROR,
                         G_PARAM_READWRITE));
}

GType
hbase_get_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (HbaseGetResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) hbase_get_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (HbaseGetResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) hbase_get_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "HbaseGetResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _HbaseGetVerArgsProperties
{
  PROP_HBASE_GET_VER_ARGS_0,
  PROP_HBASE_GET_VER_ARGS_TABLE_NAME,
  PROP_HBASE_GET_VER_ARGS_ROW,
  PROP_HBASE_GET_VER_ARGS_COLUMN,
  PROP_HBASE_GET_VER_ARGS_NUM_VERSIONS,
  PROP_HBASE_GET_VER_ARGS_ATTRIBUTES
};

/* reads a hbase_get_ver_args object */
static gint32
hbase_get_ver_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  HbaseGetVerArgs * this_object = HBASE_GET_VER_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->tableName != NULL)
          {
            g_free(this_object->tableName);
            this_object->tableName = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->tableName = g_byte_array_new();
          g_byte_array_append (this_object->tableName, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_tableName = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->row != NULL)
          {
            g_free(this_object->row);
            this_object->row = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->row = g_byte_array_new();
          g_byte_array_append (this_object->row, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_row = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if (this_object->column != NULL)
          {
            g_free(this_object->column);
            this_object->column = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->column = g_byte_array_new();
          g_byte_array_append (this_object->column, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_column = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->numVersions, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_numVersions = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              Text key30 = NULL;
              Text val31 = NULL;
              if (key30 != NULL)
              {
                g_free(key30);
                key30 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              key30 = g_byte_array_new();
              g_byte_array_append (key30, (guint8 *) data, (guint) len);
              g_free (data);
              if (val31 != NULL)
              {
                g_free(val31);
                val31 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              val31 = g_byte_array_new();
              g_byte_array_append (val31, (guint8 *) data, (guint) len);
              g_free (data);
              if (this_object->attributes && key30)
                g_hash_table_insert ((GHashTable *)this_object->attributes, (gpointer) key30, (gpointer) val31);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_attributes = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
hbase_get_ver_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  HbaseGetVerArgs * this_object = HBASE_GET_VER_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "HbaseGetVerArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "tableName", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->tableName ? ((GByteArray *) this_object->tableName)->data : NULL, this_object->tableName ? ((GByteArray *) this_object->tableName)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "row", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->row ? ((GByteArray *) this_object->row)->data : NULL, this_object->row ? ((GByteArray *) this_object->row)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "column", T_STRING, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->column ? ((GByteArray *) this_object->column)->data : NULL, this_object->column ? ((GByteArray *) this_object->column)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "numVersions", T_I32, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->numVersions, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "attributes", T_MAP, 5, error)) < 0)
    return -1;
  xfer += ret;
  {
    Text key32 = NULL;
    Text val33 = NULL;
    GList *key_list = NULL, *iter = NULL;
    Text* keys;
    int i = 0, key_count;

    if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRING, this_object->attributes ? (gint32) g_hash_table_size ((GHashTable *) this_object->attributes) : 0, error)) < 0)
      return -1;
    xfer += ret;
    if (this_object->attributes)
      g_hash_table_foreach ((GHashTable *) this_object->attributes, thrift_hash_table_get_keys, &key_list);
    key_count = g_list_length (key_list);
    keys = g_newa (Text, key_count);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
      keys[i++] = (Text) iter->data;
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key32 = keys[i];
      val33 = (Text) g_hash_table_lookup (((GHashTable *) this_object->attributes), (gpointer) key32);

      if ((ret = thrift_protocol_write_binary (protocol,  key32 ? ((GByteArray *)  key32)->data : NULL,  key32 ? ((GByteArray *)  key32)->len : 0, error)) < 0)
        return -1;
      xfer += ret;

      if ((ret = thrift_protocol_write_binary (protocol,  val33 ? ((GByteArray *)  val33)->data : NULL,  val33 ? ((GByteArray *)  val33)->len : 0, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
hbase_get_ver_args_set_property (GObject *object,
                                 guint property_id,
                                 const GValue *value,
                                 GParamSpec *pspec)
{
  HbaseGetVerArgs *self = HBASE_GET_VER_ARGS (object);

  switch (property_id)
  {
    case PROP_HBASE_GET_VER_ARGS_TABLE_NAME:
      if (self->tableName != NULL)
        g_byte_array_unref (self->tableName);
      self->tableName = g_value_dup_boxed (value);
      self->__isset_tableName = TRUE;
      break;

    case PROP_HBASE_GET_VER_ARGS_ROW:
      if (self->row != NULL)
        g_byte_array_unref (self->row);
      self->row = g_value_dup_boxed (value);
      self->__isset_row = TRUE;
      break;

    case PROP_HBASE_GET_VER_ARGS_COLUMN:
      if (self->column != NULL)
        g_byte_array_unref (self->column);
      self->column = g_value_dup_boxed (value);
      self->__isset_column = TRUE;
      break;

    case PROP_HBASE_GET_VER_ARGS_NUM_VERSIONS:
      self->numVersions = g_value_get_int (value);
      self->__isset_numVersions = TRUE;
      break;

    case PROP_HBASE_GET_VER_ARGS_ATTRIBUTES:
      if (self->attributes != NULL)
        g_hash_table_unref (self->attributes);
      self->attributes = g_value_dup_boxed (value);
      self->__isset_attributes = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
hbase_get_ver_args_get_property (GObject *object,
                                 guint property_id,
                                 GValue *value,
                                 GParamSpec *pspec)
{
  HbaseGetVerArgs *self = HBASE_GET_VER_ARGS (object);

  switch (property_id)
  {
    case PROP_HBASE_GET_VER_ARGS_TABLE_NAME:
      g_value_set_boxed (value, self->tableName);
      break;

    case PROP_HBASE_GET_VER_ARGS_ROW:
      g_value_set_boxed (value, self->row);
      break;

    case PROP_HBASE_GET_VER_ARGS_COLUMN:
      g_value_set_boxed (value, self->column);
      break;

    case PROP_HBASE_GET_VER_ARGS_NUM_VERSIONS:
      g_value_set_int (value, self->numVersions);
      break;

    case PROP_HBASE_GET_VER_ARGS_ATTRIBUTES:
      g_value_set_boxed (value, self->attributes);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
hbase_get_ver_args_instance_init (HbaseGetVerArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->tableName = NULL;
  object->__isset_tableName = FALSE;
  object->row = NULL;
  object->__isset_row = FALSE;
  object->column = NULL;
  object->__isset_column = FALSE;
  object->numVersions = 0;
  object->__isset_numVersions = FALSE;
  object->attributes = g_hash_table_new_full (g_str_hash, g_str_equal, thrift_string_free, thrift_string_free);
  object->__isset_attributes = FALSE;
}

static void 
hbase_get_ver_args_finalize (GObject *object)
{
  HbaseGetVerArgs *tobject = HBASE_GET_VER_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->tableName != NULL)
  {
    thrift_string_free(tobject->tableName);
    tobject->tableName = NULL;
  }
  if (tobject->row != NULL)
  {
    thrift_string_free(tobject->row);
    tobject->row = NULL;
  }
  if (tobject->column != NULL)
  {
    thrift_string_free(tobject->column);
    tobject->column = NULL;
  }
  if (tobject->attributes != NULL)
  {
    g_hash_table_destroy (tobject->attributes);
    tobject->attributes = NULL;
  }
}

static void
hbase_get_ver_args_class_init (HbaseGetVerArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = hbase_get_ver_args_read;
  struct_class->write = hbase_get_ver_args_write;

  gobject_class->finalize = hbase_get_ver_args_finalize;
  gobject_class->get_property = hbase_get_ver_args_get_property;
  gobject_class->set_property = hbase_get_ver_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_GET_VER_ARGS_TABLE_NAME,
     g_param_spec_boxed ("tableName",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_GET_VER_ARGS_ROW,
     g_param_spec_boxed ("row",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_GET_VER_ARGS_COLUMN,
     g_param_spec_boxed ("column",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_GET_VER_ARGS_NUM_VERSIONS,
     g_param_spec_int ("numVersions",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_GET_VER_ARGS_ATTRIBUTES,
     g_param_spec_boxed ("attributes",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));
}

GType
hbase_get_ver_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (HbaseGetVerArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) hbase_get_ver_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (HbaseGetVerArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) hbase_get_ver_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "HbaseGetVerArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _HbaseGetVerResultProperties
{
  PROP_HBASE_GET_VER_RESULT_0,
  PROP_HBASE_GET_VER_RESULT_SUCCESS,
  PROP_HBASE_GET_VER_RESULT_IO
};

/* reads a hbase_get_ver_result object */
static gint32
hbase_get_ver_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  HbaseGetVerResult * this_object = HBASE_GET_VER_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              TCell * _elem34 = NULL;
              if ( _elem34 != NULL)
              {
                g_object_unref (_elem34);
              }
              _elem34 = g_object_new (TYPE_T_CELL, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem34), protocol, error)) < 0)
              {
                g_object_unref (_elem34);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->success, _elem34);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->io != NULL)
          {
            g_object_unref (this_object->io);
          }
          this_object->io = g_object_new (TYPE_I_O_ERROR, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
          {
            g_object_unref (this_object->io);
            this_object->io = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_io = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
hbase_get_ver_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  HbaseGetVerResult * this_object = HBASE_GET_VER_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "HbaseGetVerResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_LIST, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i35;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->success ? this_object->success->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i35 = 0; i35 < (this_object->success ? this_object->success->len : 0); i35++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->success, i35))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_io == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "io", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
hbase_get_ver_result_set_property (GObject *object,
                                   guint property_id,
                                   const GValue *value,
                                   GParamSpec *pspec)
{
  HbaseGetVerResult *self = HBASE_GET_VER_RESULT (object);

  switch (property_id)
  {
    case PROP_HBASE_GET_VER_RESULT_SUCCESS:
      if (self->success != NULL)
        g_ptr_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    case PROP_HBASE_GET_VER_RESULT_IO:
      if (self->io != NULL)
        g_object_unref (self->io);
      self->io = g_value_dup_object (value);
      self->__isset_io = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
hbase_get_ver_result_get_property (GObject *object,
                                   guint property_id,
                                   GValue *value,
                                   GParamSpec *pspec)
{
  HbaseGetVerResult *self = HBASE_GET_VER_RESULT (object);

  switch (property_id)
  {
    case PROP_HBASE_GET_VER_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    case PROP_HBASE_GET_VER_RESULT_IO:
      g_value_set_object (value, self->io);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
hbase_get_ver_result_instance_init (HbaseGetVerResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_success = FALSE;
  object->io = NULL;
  object->__isset_io = FALSE;
}

static void 
hbase_get_ver_result_finalize (GObject *object)
{
  HbaseGetVerResult *tobject = HBASE_GET_VER_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_ptr_array_unref (tobject->success);
    tobject->success = NULL;
  }
  if (tobject->io != NULL)
  {
    g_object_unref(tobject->io);
    tobject->io = NULL;
  }
}

static void
hbase_get_ver_result_class_init (HbaseGetVerResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = hbase_get_ver_result_read;
  struct_class->write = hbase_get_ver_result_write;

  gobject_class->finalize = hbase_get_ver_result_finalize;
  gobject_class->get_property = hbase_get_ver_result_get_property;
  gobject_class->set_property = hbase_get_ver_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_GET_VER_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_GET_VER_RESULT_IO,
     g_param_spec_object ("io",
                         NULL,
                         NULL,
                         TYPE_I_O_ERROR,
                         G_PARAM_READWRITE));
}

GType
hbase_get_ver_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (HbaseGetVerResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) hbase_get_ver_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (HbaseGetVerResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) hbase_get_ver_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "HbaseGetVerResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _HbaseGetVerTsArgsProperties
{
  PROP_HBASE_GET_VER_TS_ARGS_0,
  PROP_HBASE_GET_VER_TS_ARGS_TABLE_NAME,
  PROP_HBASE_GET_VER_TS_ARGS_ROW,
  PROP_HBASE_GET_VER_TS_ARGS_COLUMN,
  PROP_HBASE_GET_VER_TS_ARGS_TIMESTAMP,
  PROP_HBASE_GET_VER_TS_ARGS_NUM_VERSIONS,
  PROP_HBASE_GET_VER_TS_ARGS_ATTRIBUTES
};

/* reads a hbase_get_ver_ts_args object */
static gint32
hbase_get_ver_ts_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  HbaseGetVerTsArgs * this_object = HBASE_GET_VER_TS_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->tableName != NULL)
          {
            g_free(this_object->tableName);
            this_object->tableName = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->tableName = g_byte_array_new();
          g_byte_array_append (this_object->tableName, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_tableName = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->row != NULL)
          {
            g_free(this_object->row);
            this_object->row = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->row = g_byte_array_new();
          g_byte_array_append (this_object->row, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_row = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if (this_object->column != NULL)
          {
            g_free(this_object->column);
            this_object->column = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->column = g_byte_array_new();
          g_byte_array_append (this_object->column, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_column = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->timestamp, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_timestamp = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->numVersions, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_numVersions = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              Text key36 = NULL;
              Text val37 = NULL;
              if (key36 != NULL)
              {
                g_free(key36);
                key36 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              key36 = g_byte_array_new();
              g_byte_array_append (key36, (guint8 *) data, (guint) len);
              g_free (data);
              if (val37 != NULL)
              {
                g_free(val37);
                val37 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              val37 = g_byte_array_new();
              g_byte_array_append (val37, (guint8 *) data, (guint) len);
              g_free (data);
              if (this_object->attributes && key36)
                g_hash_table_insert ((GHashTable *)this_object->attributes, (gpointer) key36, (gpointer) val37);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_attributes = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
hbase_get_ver_ts_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  HbaseGetVerTsArgs * this_object = HBASE_GET_VER_TS_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "HbaseGetVerTsArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "tableName", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->tableName ? ((GByteArray *) this_object->tableName)->data : NULL, this_object->tableName ? ((GByteArray *) this_object->tableName)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "row", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->row ? ((GByteArray *) this_object->row)->data : NULL, this_object->row ? ((GByteArray *) this_object->row)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "column", T_STRING, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->column ? ((GByteArray *) this_object->column)->data : NULL, this_object->column ? ((GByteArray *) this_object->column)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "timestamp", T_I64, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->timestamp, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "numVersions", T_I32, 5, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->numVersions, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "attributes", T_MAP, 6, error)) < 0)
    return -1;
  xfer += ret;
  {
    Text key38 = NULL;
    Text val39 = NULL;
    GList *key_list = NULL, *iter = NULL;
    Text* keys;
    int i = 0, key_count;

    if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRING, this_object->attributes ? (gint32) g_hash_table_size ((GHashTable *) this_object->attributes) : 0, error)) < 0)
      return -1;
    xfer += ret;
    if (this_object->attributes)
      g_hash_table_foreach ((GHashTable *) this_object->attributes, thrift_hash_table_get_keys, &key_list);
    key_count = g_list_length (key_list);
    keys = g_newa (Text, key_count);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
      keys[i++] = (Text) iter->data;
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key38 = keys[i];
      val39 = (Text) g_hash_table_lookup (((GHashTable *) this_object->attributes), (gpointer) key38);

      if ((ret = thrift_protocol_write_binary (protocol,  key38 ? ((GByteArray *)  key38)->data : NULL,  key38 ? ((GByteArray *)  key38)->len : 0, error)) < 0)
        return -1;
      xfer += ret;

      if ((ret = thrift_protocol_write_binary (protocol,  val39 ? ((GByteArray *)  val39)->data : NULL,  val39 ? ((GByteArray *)  val39)->len : 0, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
hbase_get_ver_ts_args_set_property (GObject *object,
                                    guint property_id,
                                    const GValue *value,
                                    GParamSpec *pspec)
{
  HbaseGetVerTsArgs *self = HBASE_GET_VER_TS_ARGS (object);

  switch (property_id)
  {
    case PROP_HBASE_GET_VER_TS_ARGS_TABLE_NAME:
      if (self->tableName != NULL)
        g_byte_array_unref (self->tableName);
      self->tableName = g_value_dup_boxed (value);
      self->__isset_tableName = TRUE;
      break;

    case PROP_HBASE_GET_VER_TS_ARGS_ROW:
      if (self->row != NULL)
        g_byte_array_unref (self->row);
      self->row = g_value_dup_boxed (value);
      self->__isset_row = TRUE;
      break;

    case PROP_HBASE_GET_VER_TS_ARGS_COLUMN:
      if (self->column != NULL)
        g_byte_array_unref (self->column);
      self->column = g_value_dup_boxed (value);
      self->__isset_column = TRUE;
      break;

    case PROP_HBASE_GET_VER_TS_ARGS_TIMESTAMP:
      self->timestamp = g_value_get_int64 (value);
      self->__isset_timestamp = TRUE;
      break;

    case PROP_HBASE_GET_VER_TS_ARGS_NUM_VERSIONS:
      self->numVersions = g_value_get_int (value);
      self->__isset_numVersions = TRUE;
      break;

    case PROP_HBASE_GET_VER_TS_ARGS_ATTRIBUTES:
      if (self->attributes != NULL)
        g_hash_table_unref (self->attributes);
      self->attributes = g_value_dup_boxed (value);
      self->__isset_attributes = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
hbase_get_ver_ts_args_get_property (GObject *object,
                                    guint property_id,
                                    GValue *value,
                                    GParamSpec *pspec)
{
  HbaseGetVerTsArgs *self = HBASE_GET_VER_TS_ARGS (object);

  switch (property_id)
  {
    case PROP_HBASE_GET_VER_TS_ARGS_TABLE_NAME:
      g_value_set_boxed (value, self->tableName);
      break;

    case PROP_HBASE_GET_VER_TS_ARGS_ROW:
      g_value_set_boxed (value, self->row);
      break;

    case PROP_HBASE_GET_VER_TS_ARGS_COLUMN:
      g_value_set_boxed (value, self->column);
      break;

    case PROP_HBASE_GET_VER_TS_ARGS_TIMESTAMP:
      g_value_set_int64 (value, self->timestamp);
      break;

    case PROP_HBASE_GET_VER_TS_ARGS_NUM_VERSIONS:
      g_value_set_int (value, self->numVersions);
      break;

    case PROP_HBASE_GET_VER_TS_ARGS_ATTRIBUTES:
      g_value_set_boxed (value, self->attributes);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
hbase_get_ver_ts_args_instance_init (HbaseGetVerTsArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->tableName = NULL;
  object->__isset_tableName = FALSE;
  object->row = NULL;
  object->__isset_row = FALSE;
  object->column = NULL;
  object->__isset_column = FALSE;
  object->timestamp = 0;
  object->__isset_timestamp = FALSE;
  object->numVersions = 0;
  object->__isset_numVersions = FALSE;
  object->attributes = g_hash_table_new_full (g_str_hash, g_str_equal, thrift_string_free, thrift_string_free);
  object->__isset_attributes = FALSE;
}

static void 
hbase_get_ver_ts_args_finalize (GObject *object)
{
  HbaseGetVerTsArgs *tobject = HBASE_GET_VER_TS_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->tableName != NULL)
  {
    thrift_string_free(tobject->tableName);
    tobject->tableName = NULL;
  }
  if (tobject->row != NULL)
  {
    thrift_string_free(tobject->row);
    tobject->row = NULL;
  }
  if (tobject->column != NULL)
  {
    thrift_string_free(tobject->column);
    tobject->column = NULL;
  }
  if (tobject->attributes != NULL)
  {
    g_hash_table_destroy (tobject->attributes);
    tobject->attributes = NULL;
  }
}

static void
hbase_get_ver_ts_args_class_init (HbaseGetVerTsArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = hbase_get_ver_ts_args_read;
  struct_class->write = hbase_get_ver_ts_args_write;

  gobject_class->finalize = hbase_get_ver_ts_args_finalize;
  gobject_class->get_property = hbase_get_ver_ts_args_get_property;
  gobject_class->set_property = hbase_get_ver_ts_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_GET_VER_TS_ARGS_TABLE_NAME,
     g_param_spec_boxed ("tableName",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_GET_VER_TS_ARGS_ROW,
     g_param_spec_boxed ("row",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_GET_VER_TS_ARGS_COLUMN,
     g_param_spec_boxed ("column",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_GET_VER_TS_ARGS_TIMESTAMP,
     g_param_spec_int64 ("timestamp",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_GET_VER_TS_ARGS_NUM_VERSIONS,
     g_param_spec_int ("numVersions",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_GET_VER_TS_ARGS_ATTRIBUTES,
     g_param_spec_boxed ("attributes",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));
}

GType
hbase_get_ver_ts_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (HbaseGetVerTsArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) hbase_get_ver_ts_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (HbaseGetVerTsArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) hbase_get_ver_ts_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "HbaseGetVerTsArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _HbaseGetVerTsResultProperties
{
  PROP_HBASE_GET_VER_TS_RESULT_0,
  PROP_HBASE_GET_VER_TS_RESULT_SUCCESS,
  PROP_HBASE_GET_VER_TS_RESULT_IO
};

/* reads a hbase_get_ver_ts_result object */
static gint32
hbase_get_ver_ts_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  HbaseGetVerTsResult * this_object = HBASE_GET_VER_TS_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              TCell * _elem40 = NULL;
              if ( _elem40 != NULL)
              {
                g_object_unref (_elem40);
              }
              _elem40 = g_object_new (TYPE_T_CELL, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem40), protocol, error)) < 0)
              {
                g_object_unref (_elem40);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->success, _elem40);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->io != NULL)
          {
            g_object_unref (this_object->io);
          }
          this_object->io = g_object_new (TYPE_I_O_ERROR, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
          {
            g_object_unref (this_object->io);
            this_object->io = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_io = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
hbase_get_ver_ts_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  HbaseGetVerTsResult * this_object = HBASE_GET_VER_TS_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "HbaseGetVerTsResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_LIST, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i41;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->success ? this_object->success->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i41 = 0; i41 < (this_object->success ? this_object->success->len : 0); i41++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->success, i41))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_io == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "io", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
hbase_get_ver_ts_result_set_property (GObject *object,
                                      guint property_id,
                                      const GValue *value,
                                      GParamSpec *pspec)
{
  HbaseGetVerTsResult *self = HBASE_GET_VER_TS_RESULT (object);

  switch (property_id)
  {
    case PROP_HBASE_GET_VER_TS_RESULT_SUCCESS:
      if (self->success != NULL)
        g_ptr_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    case PROP_HBASE_GET_VER_TS_RESULT_IO:
      if (self->io != NULL)
        g_object_unref (self->io);
      self->io = g_value_dup_object (value);
      self->__isset_io = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
hbase_get_ver_ts_result_get_property (GObject *object,
                                      guint property_id,
                                      GValue *value,
                                      GParamSpec *pspec)
{
  HbaseGetVerTsResult *self = HBASE_GET_VER_TS_RESULT (object);

  switch (property_id)
  {
    case PROP_HBASE_GET_VER_TS_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    case PROP_HBASE_GET_VER_TS_RESULT_IO:
      g_value_set_object (value, self->io);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
hbase_get_ver_ts_result_instance_init (HbaseGetVerTsResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_success = FALSE;
  object->io = NULL;
  object->__isset_io = FALSE;
}

static void 
hbase_get_ver_ts_result_finalize (GObject *object)
{
  HbaseGetVerTsResult *tobject = HBASE_GET_VER_TS_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_ptr_array_unref (tobject->success);
    tobject->success = NULL;
  }
  if (tobject->io != NULL)
  {
    g_object_unref(tobject->io);
    tobject->io = NULL;
  }
}

static void
hbase_get_ver_ts_result_class_init (HbaseGetVerTsResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = hbase_get_ver_ts_result_read;
  struct_class->write = hbase_get_ver_ts_result_write;

  gobject_class->finalize = hbase_get_ver_ts_result_finalize;
  gobject_class->get_property = hbase_get_ver_ts_result_get_property;
  gobject_class->set_property = hbase_get_ver_ts_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_GET_VER_TS_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_GET_VER_TS_RESULT_IO,
     g_param_spec_object ("io",
                         NULL,
                         NULL,
                         TYPE_I_O_ERROR,
                         G_PARAM_READWRITE));
}

GType
hbase_get_ver_ts_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (HbaseGetVerTsResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) hbase_get_ver_ts_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (HbaseGetVerTsResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) hbase_get_ver_ts_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "HbaseGetVerTsResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _HbaseGetRowArgsProperties
{
  PROP_HBASE_GET_ROW_ARGS_0,
  PROP_HBASE_GET_ROW_ARGS_TABLE_NAME,
  PROP_HBASE_GET_ROW_ARGS_ROW,
  PROP_HBASE_GET_ROW_ARGS_ATTRIBUTES
};

/* reads a hbase_get_row_args object */
static gint32
hbase_get_row_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  HbaseGetRowArgs * this_object = HBASE_GET_ROW_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->tableName != NULL)
          {
            g_free(this_object->tableName);
            this_object->tableName = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->tableName = g_byte_array_new();
          g_byte_array_append (this_object->tableName, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_tableName = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->row != NULL)
          {
            g_free(this_object->row);
            this_object->row = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->row = g_byte_array_new();
          g_byte_array_append (this_object->row, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_row = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              Text key42 = NULL;
              Text val43 = NULL;
              if (key42 != NULL)
              {
                g_free(key42);
                key42 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              key42 = g_byte_array_new();
              g_byte_array_append (key42, (guint8 *) data, (guint) len);
              g_free (data);
              if (val43 != NULL)
              {
                g_free(val43);
                val43 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              val43 = g_byte_array_new();
              g_byte_array_append (val43, (guint8 *) data, (guint) len);
              g_free (data);
              if (this_object->attributes && key42)
                g_hash_table_insert ((GHashTable *)this_object->attributes, (gpointer) key42, (gpointer) val43);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_attributes = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
hbase_get_row_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  HbaseGetRowArgs * this_object = HBASE_GET_ROW_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "HbaseGetRowArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "tableName", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->tableName ? ((GByteArray *) this_object->tableName)->data : NULL, this_object->tableName ? ((GByteArray *) this_object->tableName)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "row", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->row ? ((GByteArray *) this_object->row)->data : NULL, this_object->row ? ((GByteArray *) this_object->row)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "attributes", T_MAP, 3, error)) < 0)
    return -1;
  xfer += ret;
  {
    Text key44 = NULL;
    Text val45 = NULL;
    GList *key_list = NULL, *iter = NULL;
    Text* keys;
    int i = 0, key_count;

    if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRING, this_object->attributes ? (gint32) g_hash_table_size ((GHashTable *) this_object->attributes) : 0, error)) < 0)
      return -1;
    xfer += ret;
    if (this_object->attributes)
      g_hash_table_foreach ((GHashTable *) this_object->attributes, thrift_hash_table_get_keys, &key_list);
    key_count = g_list_length (key_list);
    keys = g_newa (Text, key_count);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
      keys[i++] = (Text) iter->data;
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key44 = keys[i];
      val45 = (Text) g_hash_table_lookup (((GHashTable *) this_object->attributes), (gpointer) key44);

      if ((ret = thrift_protocol_write_binary (protocol,  key44 ? ((GByteArray *)  key44)->data : NULL,  key44 ? ((GByteArray *)  key44)->len : 0, error)) < 0)
        return -1;
      xfer += ret;

      if ((ret = thrift_protocol_write_binary (protocol,  val45 ? ((GByteArray *)  val45)->data : NULL,  val45 ? ((GByteArray *)  val45)->len : 0, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
hbase_get_row_args_set_property (GObject *object,
                                 guint property_id,
                                 const GValue *value,
                                 GParamSpec *pspec)
{
  HbaseGetRowArgs *self = HBASE_GET_ROW_ARGS (object);

  switch (property_id)
  {
    case PROP_HBASE_GET_ROW_ARGS_TABLE_NAME:
      if (self->tableName != NULL)
        g_byte_array_unref (self->tableName);
      self->tableName = g_value_dup_boxed (value);
      self->__isset_tableName = TRUE;
      break;

    case PROP_HBASE_GET_ROW_ARGS_ROW:
      if (self->row != NULL)
        g_byte_array_unref (self->row);
      self->row = g_value_dup_boxed (value);
      self->__isset_row = TRUE;
      break;

    case PROP_HBASE_GET_ROW_ARGS_ATTRIBUTES:
      if (self->attributes != NULL)
        g_hash_table_unref (self->attributes);
      self->attributes = g_value_dup_boxed (value);
      self->__isset_attributes = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
hbase_get_row_args_get_property (GObject *object,
                                 guint property_id,
                                 GValue *value,
                                 GParamSpec *pspec)
{
  HbaseGetRowArgs *self = HBASE_GET_ROW_ARGS (object);

  switch (property_id)
  {
    case PROP_HBASE_GET_ROW_ARGS_TABLE_NAME:
      g_value_set_boxed (value, self->tableName);
      break;

    case PROP_HBASE_GET_ROW_ARGS_ROW:
      g_value_set_boxed (value, self->row);
      break;

    case PROP_HBASE_GET_ROW_ARGS_ATTRIBUTES:
      g_value_set_boxed (value, self->attributes);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
hbase_get_row_args_instance_init (HbaseGetRowArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->tableName = NULL;
  object->__isset_tableName = FALSE;
  object->row = NULL;
  object->__isset_row = FALSE;
  object->attributes = g_hash_table_new_full (g_str_hash, g_str_equal, thrift_string_free, thrift_string_free);
  object->__isset_attributes = FALSE;
}

static void 
hbase_get_row_args_finalize (GObject *object)
{
  HbaseGetRowArgs *tobject = HBASE_GET_ROW_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->tableName != NULL)
  {
    thrift_string_free(tobject->tableName);
    tobject->tableName = NULL;
  }
  if (tobject->row != NULL)
  {
    thrift_string_free(tobject->row);
    tobject->row = NULL;
  }
  if (tobject->attributes != NULL)
  {
    g_hash_table_destroy (tobject->attributes);
    tobject->attributes = NULL;
  }
}

static void
hbase_get_row_args_class_init (HbaseGetRowArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = hbase_get_row_args_read;
  struct_class->write = hbase_get_row_args_write;

  gobject_class->finalize = hbase_get_row_args_finalize;
  gobject_class->get_property = hbase_get_row_args_get_property;
  gobject_class->set_property = hbase_get_row_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_GET_ROW_ARGS_TABLE_NAME,
     g_param_spec_boxed ("tableName",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_GET_ROW_ARGS_ROW,
     g_param_spec_boxed ("row",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_GET_ROW_ARGS_ATTRIBUTES,
     g_param_spec_boxed ("attributes",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));
}

GType
hbase_get_row_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (HbaseGetRowArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) hbase_get_row_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (HbaseGetRowArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) hbase_get_row_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "HbaseGetRowArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _HbaseGetRowResultProperties
{
  PROP_HBASE_GET_ROW_RESULT_0,
  PROP_HBASE_GET_ROW_RESULT_SUCCESS,
  PROP_HBASE_GET_ROW_RESULT_IO
};

/* reads a hbase_get_row_result object */
static gint32
hbase_get_row_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  HbaseGetRowResult * this_object = HBASE_GET_ROW_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              TRowResult * _elem46 = NULL;
              if ( _elem46 != NULL)
              {
                g_object_unref (_elem46);
              }
              _elem46 = g_object_new (TYPE_T_ROW_RESULT, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem46), protocol, error)) < 0)
              {
                g_object_unref (_elem46);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->success, _elem46);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->io != NULL)
          {
            g_object_unref (this_object->io);
          }
          this_object->io = g_object_new (TYPE_I_O_ERROR, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
          {
            g_object_unref (this_object->io);
            this_object->io = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_io = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
hbase_get_row_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  HbaseGetRowResult * this_object = HBASE_GET_ROW_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "HbaseGetRowResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_LIST, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i47;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->success ? this_object->success->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i47 = 0; i47 < (this_object->success ? this_object->success->len : 0); i47++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->success, i47))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_io == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "io", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
hbase_get_row_result_set_property (GObject *object,
                                   guint property_id,
                                   const GValue *value,
                                   GParamSpec *pspec)
{
  HbaseGetRowResult *self = HBASE_GET_ROW_RESULT (object);

  switch (property_id)
  {
    case PROP_HBASE_GET_ROW_RESULT_SUCCESS:
      if (self->success != NULL)
        g_ptr_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    case PROP_HBASE_GET_ROW_RESULT_IO:
      if (self->io != NULL)
        g_object_unref (self->io);
      self->io = g_value_dup_object (value);
      self->__isset_io = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
hbase_get_row_result_get_property (GObject *object,
                                   guint property_id,
                                   GValue *value,
                                   GParamSpec *pspec)
{
  HbaseGetRowResult *self = HBASE_GET_ROW_RESULT (object);

  switch (property_id)
  {
    case PROP_HBASE_GET_ROW_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    case PROP_HBASE_GET_ROW_RESULT_IO:
      g_value_set_object (value, self->io);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
hbase_get_row_result_instance_init (HbaseGetRowResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_success = FALSE;
  object->io = NULL;
  object->__isset_io = FALSE;
}

static void 
hbase_get_row_result_finalize (GObject *object)
{
  HbaseGetRowResult *tobject = HBASE_GET_ROW_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_ptr_array_unref (tobject->success);
    tobject->success = NULL;
  }
  if (tobject->io != NULL)
  {
    g_object_unref(tobject->io);
    tobject->io = NULL;
  }
}

static void
hbase_get_row_result_class_init (HbaseGetRowResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = hbase_get_row_result_read;
  struct_class->write = hbase_get_row_result_write;

  gobject_class->finalize = hbase_get_row_result_finalize;
  gobject_class->get_property = hbase_get_row_result_get_property;
  gobject_class->set_property = hbase_get_row_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_GET_ROW_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_GET_ROW_RESULT_IO,
     g_param_spec_object ("io",
                         NULL,
                         NULL,
                         TYPE_I_O_ERROR,
                         G_PARAM_READWRITE));
}

GType
hbase_get_row_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (HbaseGetRowResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) hbase_get_row_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (HbaseGetRowResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) hbase_get_row_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "HbaseGetRowResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _HbaseGetRowWithColumnsArgsProperties
{
  PROP_HBASE_GET_ROW_WITH_COLUMNS_ARGS_0,
  PROP_HBASE_GET_ROW_WITH_COLUMNS_ARGS_TABLE_NAME,
  PROP_HBASE_GET_ROW_WITH_COLUMNS_ARGS_ROW,
  PROP_HBASE_GET_ROW_WITH_COLUMNS_ARGS_COLUMNS,
  PROP_HBASE_GET_ROW_WITH_COLUMNS_ARGS_ATTRIBUTES
};

/* reads a hbase_get_row_with_columns_args object */
static gint32
hbase_get_row_with_columns_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  HbaseGetRowWithColumnsArgs * this_object = HBASE_GET_ROW_WITH_COLUMNS_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->tableName != NULL)
          {
            g_free(this_object->tableName);
            this_object->tableName = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->tableName = g_byte_array_new();
          g_byte_array_append (this_object->tableName, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_tableName = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->row != NULL)
          {
            g_free(this_object->row);
            this_object->row = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->row = g_byte_array_new();
          g_byte_array_append (this_object->row, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_row = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              GByteArray * _elem48 = NULL;
              if (_elem48 != NULL)
              {
                g_free(_elem48);
                _elem48 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              _elem48 = g_byte_array_new();
              g_byte_array_append (_elem48, (guint8 *) data, (guint) len);
              g_free (data);
              g_ptr_array_add (this_object->columns, _elem48);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_columns = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              Text key49 = NULL;
              Text val50 = NULL;
              if (key49 != NULL)
              {
                g_free(key49);
                key49 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              key49 = g_byte_array_new();
              g_byte_array_append (key49, (guint8 *) data, (guint) len);
              g_free (data);
              if (val50 != NULL)
              {
                g_free(val50);
                val50 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              val50 = g_byte_array_new();
              g_byte_array_append (val50, (guint8 *) data, (guint) len);
              g_free (data);
              if (this_object->attributes && key49)
                g_hash_table_insert ((GHashTable *)this_object->attributes, (gpointer) key49, (gpointer) val50);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_attributes = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
hbase_get_row_with_columns_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  HbaseGetRowWithColumnsArgs * this_object = HBASE_GET_ROW_WITH_COLUMNS_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "HbaseGetRowWithColumnsArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "tableName", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->tableName ? ((GByteArray *) this_object->tableName)->data : NULL, this_object->tableName ? ((GByteArray *) this_object->tableName)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "row", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->row ? ((GByteArray *) this_object->row)->data : NULL, this_object->row ? ((GByteArray *) this_object->row)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "columns", T_LIST, 3, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i51;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (this_object->columns ? this_object->columns->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i51 = 0; i51 < (this_object->columns ? this_object->columns->len : 0); i51++)
    {
      if ((ret = thrift_protocol_write_binary (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->columns, i51)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->columns, i51)))->data : NULL, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->columns, i51)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->columns, i51)))->len : 0, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "attributes", T_MAP, 4, error)) < 0)
    return -1;
  xfer += ret;
  {
    Text key52 = NULL;
    Text val53 = NULL;
    GList *key_list = NULL, *iter = NULL;
    Text* keys;
    int i = 0, key_count;

    if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRING, this_object->attributes ? (gint32) g_hash_table_size ((GHashTable *) this_object->attributes) : 0, error)) < 0)
      return -1;
    xfer += ret;
    if (this_object->attributes)
      g_hash_table_foreach ((GHashTable *) this_object->attributes, thrift_hash_table_get_keys, &key_list);
    key_count = g_list_length (key_list);
    keys = g_newa (Text, key_count);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
      keys[i++] = (Text) iter->data;
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key52 = keys[i];
      val53 = (Text) g_hash_table_lookup (((GHashTable *) this_object->attributes), (gpointer) key52);

      if ((ret = thrift_protocol_write_binary (protocol,  key52 ? ((GByteArray *)  key52)->data : NULL,  key52 ? ((GByteArray *)  key52)->len : 0, error)) < 0)
        return -1;
      xfer += ret;

      if ((ret = thrift_protocol_write_binary (protocol,  val53 ? ((GByteArray *)  val53)->data : NULL,  val53 ? ((GByteArray *)  val53)->len : 0, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
hbase_get_row_with_columns_args_set_property (GObject *object,
                                              guint property_id,
                                              const GValue *value,
                                              GParamSpec *pspec)
{
  HbaseGetRowWithColumnsArgs *self = HBASE_GET_ROW_WITH_COLUMNS_ARGS (object);

  switch (property_id)
  {
    case PROP_HBASE_GET_ROW_WITH_COLUMNS_ARGS_TABLE_NAME:
      if (self->tableName != NULL)
        g_byte_array_unref (self->tableName);
      self->tableName = g_value_dup_boxed (value);
      self->__isset_tableName = TRUE;
      break;

    case PROP_HBASE_GET_ROW_WITH_COLUMNS_ARGS_ROW:
      if (self->row != NULL)
        g_byte_array_unref (self->row);
      self->row = g_value_dup_boxed (value);
      self->__isset_row = TRUE;
      break;

    case PROP_HBASE_GET_ROW_WITH_COLUMNS_ARGS_COLUMNS:
      if (self->columns != NULL)
        g_ptr_array_unref (self->columns);
      self->columns = g_value_dup_boxed (value);
      self->__isset_columns = TRUE;
      break;

    case PROP_HBASE_GET_ROW_WITH_COLUMNS_ARGS_ATTRIBUTES:
      if (self->attributes != NULL)
        g_hash_table_unref (self->attributes);
      self->attributes = g_value_dup_boxed (value);
      self->__isset_attributes = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
hbase_get_row_with_columns_args_get_property (GObject *object,
                                              guint property_id,
                                              GValue *value,
                                              GParamSpec *pspec)
{
  HbaseGetRowWithColumnsArgs *self = HBASE_GET_ROW_WITH_COLUMNS_ARGS (object);

  switch (property_id)
  {
    case PROP_HBASE_GET_ROW_WITH_COLUMNS_ARGS_TABLE_NAME:
      g_value_set_boxed (value, self->tableName);
      break;

    case PROP_HBASE_GET_ROW_WITH_COLUMNS_ARGS_ROW:
      g_value_set_boxed (value, self->row);
      break;

    case PROP_HBASE_GET_ROW_WITH_COLUMNS_ARGS_COLUMNS:
      g_value_set_boxed (value, self->columns);
      break;

    case PROP_HBASE_GET_ROW_WITH_COLUMNS_ARGS_ATTRIBUTES:
      g_value_set_boxed (value, self->attributes);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
hbase_get_row_with_columns_args_instance_init (HbaseGetRowWithColumnsArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->tableName = NULL;
  object->__isset_tableName = FALSE;
  object->row = NULL;
  object->__isset_row = FALSE;
  object->columns = g_ptr_array_new_with_free_func (thrift_string_free);
  object->__isset_columns = FALSE;
  object->attributes = g_hash_table_new_full (g_str_hash, g_str_equal, thrift_string_free, thrift_string_free);
  object->__isset_attributes = FALSE;
}

static void 
hbase_get_row_with_columns_args_finalize (GObject *object)
{
  HbaseGetRowWithColumnsArgs *tobject = HBASE_GET_ROW_WITH_COLUMNS_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->tableName != NULL)
  {
    thrift_string_free(tobject->tableName);
    tobject->tableName = NULL;
  }
  if (tobject->row != NULL)
  {
    thrift_string_free(tobject->row);
    tobject->row = NULL;
  }
  if (tobject->columns != NULL)
  {
    g_ptr_array_unref (tobject->columns);
    tobject->columns = NULL;
  }
  if (tobject->attributes != NULL)
  {
    g_hash_table_destroy (tobject->attributes);
    tobject->attributes = NULL;
  }
}

static void
hbase_get_row_with_columns_args_class_init (HbaseGetRowWithColumnsArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = hbase_get_row_with_columns_args_read;
  struct_class->write = hbase_get_row_with_columns_args_write;

  gobject_class->finalize = hbase_get_row_with_columns_args_finalize;
  gobject_class->get_property = hbase_get_row_with_columns_args_get_property;
  gobject_class->set_property = hbase_get_row_with_columns_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_GET_ROW_WITH_COLUMNS_ARGS_TABLE_NAME,
     g_param_spec_boxed ("tableName",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_GET_ROW_WITH_COLUMNS_ARGS_ROW,
     g_param_spec_boxed ("row",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_GET_ROW_WITH_COLUMNS_ARGS_COLUMNS,
     g_param_spec_boxed ("columns",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_GET_ROW_WITH_COLUMNS_ARGS_ATTRIBUTES,
     g_param_spec_boxed ("attributes",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));
}

GType
hbase_get_row_with_columns_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (HbaseGetRowWithColumnsArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) hbase_get_row_with_columns_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (HbaseGetRowWithColumnsArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) hbase_get_row_with_columns_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "HbaseGetRowWithColumnsArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _HbaseGetRowWithColumnsResultProperties
{
  PROP_HBASE_GET_ROW_WITH_COLUMNS_RESULT_0,
  PROP_HBASE_GET_ROW_WITH_COLUMNS_RESULT_SUCCESS,
  PROP_HBASE_GET_ROW_WITH_COLUMNS_RESULT_IO
};

/* reads a hbase_get_row_with_columns_result object */
static gint32
hbase_get_row_with_columns_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  HbaseGetRowWithColumnsResult * this_object = HBASE_GET_ROW_WITH_COLUMNS_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              TRowResult * _elem54 = NULL;
              if ( _elem54 != NULL)
              {
                g_object_unref (_elem54);
              }
              _elem54 = g_object_new (TYPE_T_ROW_RESULT, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem54), protocol, error)) < 0)
              {
                g_object_unref (_elem54);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->success, _elem54);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->io != NULL)
          {
            g_object_unref (this_object->io);
          }
          this_object->io = g_object_new (TYPE_I_O_ERROR, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
          {
            g_object_unref (this_object->io);
            this_object->io = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_io = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
hbase_get_row_with_columns_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  HbaseGetRowWithColumnsResult * this_object = HBASE_GET_ROW_WITH_COLUMNS_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "HbaseGetRowWithColumnsResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_LIST, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i55;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->success ? this_object->success->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i55 = 0; i55 < (this_object->success ? this_object->success->len : 0); i55++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->success, i55))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_io == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "io", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
hbase_get_row_with_columns_result_set_property (GObject *object,
                                                guint property_id,
                                                const GValue *value,
                                                GParamSpec *pspec)
{
  HbaseGetRowWithColumnsResult *self = HBASE_GET_ROW_WITH_COLUMNS_RESULT (object);

  switch (property_id)
  {
    case PROP_HBASE_GET_ROW_WITH_COLUMNS_RESULT_SUCCESS:
      if (self->success != NULL)
        g_ptr_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    case PROP_HBASE_GET_ROW_WITH_COLUMNS_RESULT_IO:
      if (self->io != NULL)
        g_object_unref (self->io);
      self->io = g_value_dup_object (value);
      self->__isset_io = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
hbase_get_row_with_columns_result_get_property (GObject *object,
                                                guint property_id,
                                                GValue *value,
                                                GParamSpec *pspec)
{
  HbaseGetRowWithColumnsResult *self = HBASE_GET_ROW_WITH_COLUMNS_RESULT (object);

  switch (property_id)
  {
    case PROP_HBASE_GET_ROW_WITH_COLUMNS_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    case PROP_HBASE_GET_ROW_WITH_COLUMNS_RESULT_IO:
      g_value_set_object (value, self->io);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
hbase_get_row_with_columns_result_instance_init (HbaseGetRowWithColumnsResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_success = FALSE;
  object->io = NULL;
  object->__isset_io = FALSE;
}

static void 
hbase_get_row_with_columns_result_finalize (GObject *object)
{
  HbaseGetRowWithColumnsResult *tobject = HBASE_GET_ROW_WITH_COLUMNS_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_ptr_array_unref (tobject->success);
    tobject->success = NULL;
  }
  if (tobject->io != NULL)
  {
    g_object_unref(tobject->io);
    tobject->io = NULL;
  }
}

static void
hbase_get_row_with_columns_result_class_init (HbaseGetRowWithColumnsResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = hbase_get_row_with_columns_result_read;
  struct_class->write = hbase_get_row_with_columns_result_write;

  gobject_class->finalize = hbase_get_row_with_columns_result_finalize;
  gobject_class->get_property = hbase_get_row_with_columns_result_get_property;
  gobject_class->set_property = hbase_get_row_with_columns_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_GET_ROW_WITH_COLUMNS_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_GET_ROW_WITH_COLUMNS_RESULT_IO,
     g_param_spec_object ("io",
                         NULL,
                         NULL,
                         TYPE_I_O_ERROR,
                         G_PARAM_READWRITE));
}

GType
hbase_get_row_with_columns_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (HbaseGetRowWithColumnsResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) hbase_get_row_with_columns_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (HbaseGetRowWithColumnsResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) hbase_get_row_with_columns_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "HbaseGetRowWithColumnsResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _HbaseGetRowTsArgsProperties
{
  PROP_HBASE_GET_ROW_TS_ARGS_0,
  PROP_HBASE_GET_ROW_TS_ARGS_TABLE_NAME,
  PROP_HBASE_GET_ROW_TS_ARGS_ROW,
  PROP_HBASE_GET_ROW_TS_ARGS_TIMESTAMP,
  PROP_HBASE_GET_ROW_TS_ARGS_ATTRIBUTES
};

/* reads a hbase_get_row_ts_args object */
static gint32
hbase_get_row_ts_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  HbaseGetRowTsArgs * this_object = HBASE_GET_ROW_TS_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->tableName != NULL)
          {
            g_free(this_object->tableName);
            this_object->tableName = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->tableName = g_byte_array_new();
          g_byte_array_append (this_object->tableName, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_tableName = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->row != NULL)
          {
            g_free(this_object->row);
            this_object->row = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->row = g_byte_array_new();
          g_byte_array_append (this_object->row, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_row = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->timestamp, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_timestamp = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              Text key56 = NULL;
              Text val57 = NULL;
              if (key56 != NULL)
              {
                g_free(key56);
                key56 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              key56 = g_byte_array_new();
              g_byte_array_append (key56, (guint8 *) data, (guint) len);
              g_free (data);
              if (val57 != NULL)
              {
                g_free(val57);
                val57 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              val57 = g_byte_array_new();
              g_byte_array_append (val57, (guint8 *) data, (guint) len);
              g_free (data);
              if (this_object->attributes && key56)
                g_hash_table_insert ((GHashTable *)this_object->attributes, (gpointer) key56, (gpointer) val57);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_attributes = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
hbase_get_row_ts_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  HbaseGetRowTsArgs * this_object = HBASE_GET_ROW_TS_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "HbaseGetRowTsArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "tableName", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->tableName ? ((GByteArray *) this_object->tableName)->data : NULL, this_object->tableName ? ((GByteArray *) this_object->tableName)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "row", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->row ? ((GByteArray *) this_object->row)->data : NULL, this_object->row ? ((GByteArray *) this_object->row)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "timestamp", T_I64, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->timestamp, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "attributes", T_MAP, 4, error)) < 0)
    return -1;
  xfer += ret;
  {
    Text key58 = NULL;
    Text val59 = NULL;
    GList *key_list = NULL, *iter = NULL;
    Text* keys;
    int i = 0, key_count;

    if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRING, this_object->attributes ? (gint32) g_hash_table_size ((GHashTable *) this_object->attributes) : 0, error)) < 0)
      return -1;
    xfer += ret;
    if (this_object->attributes)
      g_hash_table_foreach ((GHashTable *) this_object->attributes, thrift_hash_table_get_keys, &key_list);
    key_count = g_list_length (key_list);
    keys = g_newa (Text, key_count);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
      keys[i++] = (Text) iter->data;
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key58 = keys[i];
      val59 = (Text) g_hash_table_lookup (((GHashTable *) this_object->attributes), (gpointer) key58);

      if ((ret = thrift_protocol_write_binary (protocol,  key58 ? ((GByteArray *)  key58)->data : NULL,  key58 ? ((GByteArray *)  key58)->len : 0, error)) < 0)
        return -1;
      xfer += ret;

      if ((ret = thrift_protocol_write_binary (protocol,  val59 ? ((GByteArray *)  val59)->data : NULL,  val59 ? ((GByteArray *)  val59)->len : 0, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
hbase_get_row_ts_args_set_property (GObject *object,
                                    guint property_id,
                                    const GValue *value,
                                    GParamSpec *pspec)
{
  HbaseGetRowTsArgs *self = HBASE_GET_ROW_TS_ARGS (object);

  switch (property_id)
  {
    case PROP_HBASE_GET_ROW_TS_ARGS_TABLE_NAME:
      if (self->tableName != NULL)
        g_byte_array_unref (self->tableName);
      self->tableName = g_value_dup_boxed (value);
      self->__isset_tableName = TRUE;
      break;

    case PROP_HBASE_GET_ROW_TS_ARGS_ROW:
      if (self->row != NULL)
        g_byte_array_unref (self->row);
      self->row = g_value_dup_boxed (value);
      self->__isset_row = TRUE;
      break;

    case PROP_HBASE_GET_ROW_TS_ARGS_TIMESTAMP:
      self->timestamp = g_value_get_int64 (value);
      self->__isset_timestamp = TRUE;
      break;

    case PROP_HBASE_GET_ROW_TS_ARGS_ATTRIBUTES:
      if (self->attributes != NULL)
        g_hash_table_unref (self->attributes);
      self->attributes = g_value_dup_boxed (value);
      self->__isset_attributes = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
hbase_get_row_ts_args_get_property (GObject *object,
                                    guint property_id,
                                    GValue *value,
                                    GParamSpec *pspec)
{
  HbaseGetRowTsArgs *self = HBASE_GET_ROW_TS_ARGS (object);

  switch (property_id)
  {
    case PROP_HBASE_GET_ROW_TS_ARGS_TABLE_NAME:
      g_value_set_boxed (value, self->tableName);
      break;

    case PROP_HBASE_GET_ROW_TS_ARGS_ROW:
      g_value_set_boxed (value, self->row);
      break;

    case PROP_HBASE_GET_ROW_TS_ARGS_TIMESTAMP:
      g_value_set_int64 (value, self->timestamp);
      break;

    case PROP_HBASE_GET_ROW_TS_ARGS_ATTRIBUTES:
      g_value_set_boxed (value, self->attributes);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
hbase_get_row_ts_args_instance_init (HbaseGetRowTsArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->tableName = NULL;
  object->__isset_tableName = FALSE;
  object->row = NULL;
  object->__isset_row = FALSE;
  object->timestamp = 0;
  object->__isset_timestamp = FALSE;
  object->attributes = g_hash_table_new_full (g_str_hash, g_str_equal, thrift_string_free, thrift_string_free);
  object->__isset_attributes = FALSE;
}

static void 
hbase_get_row_ts_args_finalize (GObject *object)
{
  HbaseGetRowTsArgs *tobject = HBASE_GET_ROW_TS_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->tableName != NULL)
  {
    thrift_string_free(tobject->tableName);
    tobject->tableName = NULL;
  }
  if (tobject->row != NULL)
  {
    thrift_string_free(tobject->row);
    tobject->row = NULL;
  }
  if (tobject->attributes != NULL)
  {
    g_hash_table_destroy (tobject->attributes);
    tobject->attributes = NULL;
  }
}

static void
hbase_get_row_ts_args_class_init (HbaseGetRowTsArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = hbase_get_row_ts_args_read;
  struct_class->write = hbase_get_row_ts_args_write;

  gobject_class->finalize = hbase_get_row_ts_args_finalize;
  gobject_class->get_property = hbase_get_row_ts_args_get_property;
  gobject_class->set_property = hbase_get_row_ts_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_GET_ROW_TS_ARGS_TABLE_NAME,
     g_param_spec_boxed ("tableName",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_GET_ROW_TS_ARGS_ROW,
     g_param_spec_boxed ("row",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_GET_ROW_TS_ARGS_TIMESTAMP,
     g_param_spec_int64 ("timestamp",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_GET_ROW_TS_ARGS_ATTRIBUTES,
     g_param_spec_boxed ("attributes",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));
}

GType
hbase_get_row_ts_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (HbaseGetRowTsArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) hbase_get_row_ts_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (HbaseGetRowTsArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) hbase_get_row_ts_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "HbaseGetRowTsArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _HbaseGetRowTsResultProperties
{
  PROP_HBASE_GET_ROW_TS_RESULT_0,
  PROP_HBASE_GET_ROW_TS_RESULT_SUCCESS,
  PROP_HBASE_GET_ROW_TS_RESULT_IO
};

/* reads a hbase_get_row_ts_result object */
static gint32
hbase_get_row_ts_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  HbaseGetRowTsResult * this_object = HBASE_GET_ROW_TS_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              TRowResult * _elem60 = NULL;
              if ( _elem60 != NULL)
              {
                g_object_unref (_elem60);
              }
              _elem60 = g_object_new (TYPE_T_ROW_RESULT, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem60), protocol, error)) < 0)
              {
                g_object_unref (_elem60);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->success, _elem60);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->io != NULL)
          {
            g_object_unref (this_object->io);
          }
          this_object->io = g_object_new (TYPE_I_O_ERROR, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
          {
            g_object_unref (this_object->io);
            this_object->io = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_io = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
hbase_get_row_ts_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  HbaseGetRowTsResult * this_object = HBASE_GET_ROW_TS_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "HbaseGetRowTsResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_LIST, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i61;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->success ? this_object->success->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i61 = 0; i61 < (this_object->success ? this_object->success->len : 0); i61++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->success, i61))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_io == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "io", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
hbase_get_row_ts_result_set_property (GObject *object,
                                      guint property_id,
                                      const GValue *value,
                                      GParamSpec *pspec)
{
  HbaseGetRowTsResult *self = HBASE_GET_ROW_TS_RESULT (object);

  switch (property_id)
  {
    case PROP_HBASE_GET_ROW_TS_RESULT_SUCCESS:
      if (self->success != NULL)
        g_ptr_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    case PROP_HBASE_GET_ROW_TS_RESULT_IO:
      if (self->io != NULL)
        g_object_unref (self->io);
      self->io = g_value_dup_object (value);
      self->__isset_io = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
hbase_get_row_ts_result_get_property (GObject *object,
                                      guint property_id,
                                      GValue *value,
                                      GParamSpec *pspec)
{
  HbaseGetRowTsResult *self = HBASE_GET_ROW_TS_RESULT (object);

  switch (property_id)
  {
    case PROP_HBASE_GET_ROW_TS_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    case PROP_HBASE_GET_ROW_TS_RESULT_IO:
      g_value_set_object (value, self->io);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
hbase_get_row_ts_result_instance_init (HbaseGetRowTsResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_success = FALSE;
  object->io = NULL;
  object->__isset_io = FALSE;
}

static void 
hbase_get_row_ts_result_finalize (GObject *object)
{
  HbaseGetRowTsResult *tobject = HBASE_GET_ROW_TS_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_ptr_array_unref (tobject->success);
    tobject->success = NULL;
  }
  if (tobject->io != NULL)
  {
    g_object_unref(tobject->io);
    tobject->io = NULL;
  }
}

static void
hbase_get_row_ts_result_class_init (HbaseGetRowTsResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = hbase_get_row_ts_result_read;
  struct_class->write = hbase_get_row_ts_result_write;

  gobject_class->finalize = hbase_get_row_ts_result_finalize;
  gobject_class->get_property = hbase_get_row_ts_result_get_property;
  gobject_class->set_property = hbase_get_row_ts_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_GET_ROW_TS_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_GET_ROW_TS_RESULT_IO,
     g_param_spec_object ("io",
                         NULL,
                         NULL,
                         TYPE_I_O_ERROR,
                         G_PARAM_READWRITE));
}

GType
hbase_get_row_ts_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (HbaseGetRowTsResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) hbase_get_row_ts_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (HbaseGetRowTsResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) hbase_get_row_ts_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "HbaseGetRowTsResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _HbaseGetRowWithColumnsTsArgsProperties
{
  PROP_HBASE_GET_ROW_WITH_COLUMNS_TS_ARGS_0,
  PROP_HBASE_GET_ROW_WITH_COLUMNS_TS_ARGS_TABLE_NAME,
  PROP_HBASE_GET_ROW_WITH_COLUMNS_TS_ARGS_ROW,
  PROP_HBASE_GET_ROW_WITH_COLUMNS_TS_ARGS_COLUMNS,
  PROP_HBASE_GET_ROW_WITH_COLUMNS_TS_ARGS_TIMESTAMP,
  PROP_HBASE_GET_ROW_WITH_COLUMNS_TS_ARGS_ATTRIBUTES
};

/* reads a hbase_get_row_with_columns_ts_args object */
static gint32
hbase_get_row_with_columns_ts_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  HbaseGetRowWithColumnsTsArgs * this_object = HBASE_GET_ROW_WITH_COLUMNS_TS_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->tableName != NULL)
          {
            g_free(this_object->tableName);
            this_object->tableName = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->tableName = g_byte_array_new();
          g_byte_array_append (this_object->tableName, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_tableName = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->row != NULL)
          {
            g_free(this_object->row);
            this_object->row = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->row = g_byte_array_new();
          g_byte_array_append (this_object->row, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_row = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              GByteArray * _elem62 = NULL;
              if (_elem62 != NULL)
              {
                g_free(_elem62);
                _elem62 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              _elem62 = g_byte_array_new();
              g_byte_array_append (_elem62, (guint8 *) data, (guint) len);
              g_free (data);
              g_ptr_array_add (this_object->columns, _elem62);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_columns = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->timestamp, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_timestamp = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              Text key63 = NULL;
              Text val64 = NULL;
              if (key63 != NULL)
              {
                g_free(key63);
                key63 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              key63 = g_byte_array_new();
              g_byte_array_append (key63, (guint8 *) data, (guint) len);
              g_free (data);
              if (val64 != NULL)
              {
                g_free(val64);
                val64 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              val64 = g_byte_array_new();
              g_byte_array_append (val64, (guint8 *) data, (guint) len);
              g_free (data);
              if (this_object->attributes && key63)
                g_hash_table_insert ((GHashTable *)this_object->attributes, (gpointer) key63, (gpointer) val64);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_attributes = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
hbase_get_row_with_columns_ts_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  HbaseGetRowWithColumnsTsArgs * this_object = HBASE_GET_ROW_WITH_COLUMNS_TS_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "HbaseGetRowWithColumnsTsArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "tableName", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->tableName ? ((GByteArray *) this_object->tableName)->data : NULL, this_object->tableName ? ((GByteArray *) this_object->tableName)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "row", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->row ? ((GByteArray *) this_object->row)->data : NULL, this_object->row ? ((GByteArray *) this_object->row)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "columns", T_LIST, 3, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i65;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (this_object->columns ? this_object->columns->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i65 = 0; i65 < (this_object->columns ? this_object->columns->len : 0); i65++)
    {
      if ((ret = thrift_protocol_write_binary (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->columns, i65)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->columns, i65)))->data : NULL, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->columns, i65)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->columns, i65)))->len : 0, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "timestamp", T_I64, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->timestamp, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "attributes", T_MAP, 5, error)) < 0)
    return -1;
  xfer += ret;
  {
    Text key66 = NULL;
    Text val67 = NULL;
    GList *key_list = NULL, *iter = NULL;
    Text* keys;
    int i = 0, key_count;

    if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRING, this_object->attributes ? (gint32) g_hash_table_size ((GHashTable *) this_object->attributes) : 0, error)) < 0)
      return -1;
    xfer += ret;
    if (this_object->attributes)
      g_hash_table_foreach ((GHashTable *) this_object->attributes, thrift_hash_table_get_keys, &key_list);
    key_count = g_list_length (key_list);
    keys = g_newa (Text, key_count);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
      keys[i++] = (Text) iter->data;
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key66 = keys[i];
      val67 = (Text) g_hash_table_lookup (((GHashTable *) this_object->attributes), (gpointer) key66);

      if ((ret = thrift_protocol_write_binary (protocol,  key66 ? ((GByteArray *)  key66)->data : NULL,  key66 ? ((GByteArray *)  key66)->len : 0, error)) < 0)
        return -1;
      xfer += ret;

      if ((ret = thrift_protocol_write_binary (protocol,  val67 ? ((GByteArray *)  val67)->data : NULL,  val67 ? ((GByteArray *)  val67)->len : 0, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
hbase_get_row_with_columns_ts_args_set_property (GObject *object,
                                                 guint property_id,
                                                 const GValue *value,
                                                 GParamSpec *pspec)
{
  HbaseGetRowWithColumnsTsArgs *self = HBASE_GET_ROW_WITH_COLUMNS_TS_ARGS (object);

  switch (property_id)
  {
    case PROP_HBASE_GET_ROW_WITH_COLUMNS_TS_ARGS_TABLE_NAME:
      if (self->tableName != NULL)
        g_byte_array_unref (self->tableName);
      self->tableName = g_value_dup_boxed (value);
      self->__isset_tableName = TRUE;
      break;

    case PROP_HBASE_GET_ROW_WITH_COLUMNS_TS_ARGS_ROW:
      if (self->row != NULL)
        g_byte_array_unref (self->row);
      self->row = g_value_dup_boxed (value);
      self->__isset_row = TRUE;
      break;

    case PROP_HBASE_GET_ROW_WITH_COLUMNS_TS_ARGS_COLUMNS:
      if (self->columns != NULL)
        g_ptr_array_unref (self->columns);
      self->columns = g_value_dup_boxed (value);
      self->__isset_columns = TRUE;
      break;

    case PROP_HBASE_GET_ROW_WITH_COLUMNS_TS_ARGS_TIMESTAMP:
      self->timestamp = g_value_get_int64 (value);
      self->__isset_timestamp = TRUE;
      break;

    case PROP_HBASE_GET_ROW_WITH_COLUMNS_TS_ARGS_ATTRIBUTES:
      if (self->attributes != NULL)
        g_hash_table_unref (self->attributes);
      self->attributes = g_value_dup_boxed (value);
      self->__isset_attributes = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
hbase_get_row_with_columns_ts_args_get_property (GObject *object,
                                                 guint property_id,
                                                 GValue *value,
                                                 GParamSpec *pspec)
{
  HbaseGetRowWithColumnsTsArgs *self = HBASE_GET_ROW_WITH_COLUMNS_TS_ARGS (object);

  switch (property_id)
  {
    case PROP_HBASE_GET_ROW_WITH_COLUMNS_TS_ARGS_TABLE_NAME:
      g_value_set_boxed (value, self->tableName);
      break;

    case PROP_HBASE_GET_ROW_WITH_COLUMNS_TS_ARGS_ROW:
      g_value_set_boxed (value, self->row);
      break;

    case PROP_HBASE_GET_ROW_WITH_COLUMNS_TS_ARGS_COLUMNS:
      g_value_set_boxed (value, self->columns);
      break;

    case PROP_HBASE_GET_ROW_WITH_COLUMNS_TS_ARGS_TIMESTAMP:
      g_value_set_int64 (value, self->timestamp);
      break;

    case PROP_HBASE_GET_ROW_WITH_COLUMNS_TS_ARGS_ATTRIBUTES:
      g_value_set_boxed (value, self->attributes);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
hbase_get_row_with_columns_ts_args_instance_init (HbaseGetRowWithColumnsTsArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->tableName = NULL;
  object->__isset_tableName = FALSE;
  object->row = NULL;
  object->__isset_row = FALSE;
  object->columns = g_ptr_array_new_with_free_func (thrift_string_free);
  object->__isset_columns = FALSE;
  object->timestamp = 0;
  object->__isset_timestamp = FALSE;
  object->attributes = g_hash_table_new_full (g_str_hash, g_str_equal, thrift_string_free, thrift_string_free);
  object->__isset_attributes = FALSE;
}

static void 
hbase_get_row_with_columns_ts_args_finalize (GObject *object)
{
  HbaseGetRowWithColumnsTsArgs *tobject = HBASE_GET_ROW_WITH_COLUMNS_TS_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->tableName != NULL)
  {
    thrift_string_free(tobject->tableName);
    tobject->tableName = NULL;
  }
  if (tobject->row != NULL)
  {
    thrift_string_free(tobject->row);
    tobject->row = NULL;
  }
  if (tobject->columns != NULL)
  {
    g_ptr_array_unref (tobject->columns);
    tobject->columns = NULL;
  }
  if (tobject->attributes != NULL)
  {
    g_hash_table_destroy (tobject->attributes);
    tobject->attributes = NULL;
  }
}

static void
hbase_get_row_with_columns_ts_args_class_init (HbaseGetRowWithColumnsTsArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = hbase_get_row_with_columns_ts_args_read;
  struct_class->write = hbase_get_row_with_columns_ts_args_write;

  gobject_class->finalize = hbase_get_row_with_columns_ts_args_finalize;
  gobject_class->get_property = hbase_get_row_with_columns_ts_args_get_property;
  gobject_class->set_property = hbase_get_row_with_columns_ts_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_GET_ROW_WITH_COLUMNS_TS_ARGS_TABLE_NAME,
     g_param_spec_boxed ("tableName",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_GET_ROW_WITH_COLUMNS_TS_ARGS_ROW,
     g_param_spec_boxed ("row",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_GET_ROW_WITH_COLUMNS_TS_ARGS_COLUMNS,
     g_param_spec_boxed ("columns",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_GET_ROW_WITH_COLUMNS_TS_ARGS_TIMESTAMP,
     g_param_spec_int64 ("timestamp",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_GET_ROW_WITH_COLUMNS_TS_ARGS_ATTRIBUTES,
     g_param_spec_boxed ("attributes",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));
}

GType
hbase_get_row_with_columns_ts_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (HbaseGetRowWithColumnsTsArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) hbase_get_row_with_columns_ts_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (HbaseGetRowWithColumnsTsArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) hbase_get_row_with_columns_ts_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "HbaseGetRowWithColumnsTsArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _HbaseGetRowWithColumnsTsResultProperties
{
  PROP_HBASE_GET_ROW_WITH_COLUMNS_TS_RESULT_0,
  PROP_HBASE_GET_ROW_WITH_COLUMNS_TS_RESULT_SUCCESS,
  PROP_HBASE_GET_ROW_WITH_COLUMNS_TS_RESULT_IO
};

/* reads a hbase_get_row_with_columns_ts_result object */
static gint32
hbase_get_row_with_columns_ts_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  HbaseGetRowWithColumnsTsResult * this_object = HBASE_GET_ROW_WITH_COLUMNS_TS_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              TRowResult * _elem68 = NULL;
              if ( _elem68 != NULL)
              {
                g_object_unref (_elem68);
              }
              _elem68 = g_object_new (TYPE_T_ROW_RESULT, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem68), protocol, error)) < 0)
              {
                g_object_unref (_elem68);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->success, _elem68);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->io != NULL)
          {
            g_object_unref (this_object->io);
          }
          this_object->io = g_object_new (TYPE_I_O_ERROR, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
          {
            g_object_unref (this_object->io);
            this_object->io = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_io = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
hbase_get_row_with_columns_ts_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  HbaseGetRowWithColumnsTsResult * this_object = HBASE_GET_ROW_WITH_COLUMNS_TS_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "HbaseGetRowWithColumnsTsResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_LIST, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i69;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->success ? this_object->success->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i69 = 0; i69 < (this_object->success ? this_object->success->len : 0); i69++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->success, i69))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_io == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "io", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
hbase_get_row_with_columns_ts_result_set_property (GObject *object,
                                                   guint property_id,
                                                   const GValue *value,
                                                   GParamSpec *pspec)
{
  HbaseGetRowWithColumnsTsResult *self = HBASE_GET_ROW_WITH_COLUMNS_TS_RESULT (object);

  switch (property_id)
  {
    case PROP_HBASE_GET_ROW_WITH_COLUMNS_TS_RESULT_SUCCESS:
      if (self->success != NULL)
        g_ptr_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    case PROP_HBASE_GET_ROW_WITH_COLUMNS_TS_RESULT_IO:
      if (self->io != NULL)
        g_object_unref (self->io);
      self->io = g_value_dup_object (value);
      self->__isset_io = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
hbase_get_row_with_columns_ts_result_get_property (GObject *object,
                                                   guint property_id,
                                                   GValue *value,
                                                   GParamSpec *pspec)
{
  HbaseGetRowWithColumnsTsResult *self = HBASE_GET_ROW_WITH_COLUMNS_TS_RESULT (object);

  switch (property_id)
  {
    case PROP_HBASE_GET_ROW_WITH_COLUMNS_TS_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    case PROP_HBASE_GET_ROW_WITH_COLUMNS_TS_RESULT_IO:
      g_value_set_object (value, self->io);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
hbase_get_row_with_columns_ts_result_instance_init (HbaseGetRowWithColumnsTsResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_success = FALSE;
  object->io = NULL;
  object->__isset_io = FALSE;
}

static void 
hbase_get_row_with_columns_ts_result_finalize (GObject *object)
{
  HbaseGetRowWithColumnsTsResult *tobject = HBASE_GET_ROW_WITH_COLUMNS_TS_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_ptr_array_unref (tobject->success);
    tobject->success = NULL;
  }
  if (tobject->io != NULL)
  {
    g_object_unref(tobject->io);
    tobject->io = NULL;
  }
}

static void
hbase_get_row_with_columns_ts_result_class_init (HbaseGetRowWithColumnsTsResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = hbase_get_row_with_columns_ts_result_read;
  struct_class->write = hbase_get_row_with_columns_ts_result_write;

  gobject_class->finalize = hbase_get_row_with_columns_ts_result_finalize;
  gobject_class->get_property = hbase_get_row_with_columns_ts_result_get_property;
  gobject_class->set_property = hbase_get_row_with_columns_ts_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_GET_ROW_WITH_COLUMNS_TS_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_GET_ROW_WITH_COLUMNS_TS_RESULT_IO,
     g_param_spec_object ("io",
                         NULL,
                         NULL,
                         TYPE_I_O_ERROR,
                         G_PARAM_READWRITE));
}

GType
hbase_get_row_with_columns_ts_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (HbaseGetRowWithColumnsTsResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) hbase_get_row_with_columns_ts_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (HbaseGetRowWithColumnsTsResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) hbase_get_row_with_columns_ts_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "HbaseGetRowWithColumnsTsResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _HbaseGetRowsArgsProperties
{
  PROP_HBASE_GET_ROWS_ARGS_0,
  PROP_HBASE_GET_ROWS_ARGS_TABLE_NAME,
  PROP_HBASE_GET_ROWS_ARGS_ROWS,
  PROP_HBASE_GET_ROWS_ARGS_ATTRIBUTES
};

/* reads a hbase_get_rows_args object */
static gint32
hbase_get_rows_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  HbaseGetRowsArgs * this_object = HBASE_GET_ROWS_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->tableName != NULL)
          {
            g_free(this_object->tableName);
            this_object->tableName = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->tableName = g_byte_array_new();
          g_byte_array_append (this_object->tableName, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_tableName = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              GByteArray * _elem70 = NULL;
              if (_elem70 != NULL)
              {
                g_free(_elem70);
                _elem70 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              _elem70 = g_byte_array_new();
              g_byte_array_append (_elem70, (guint8 *) data, (guint) len);
              g_free (data);
              g_ptr_array_add (this_object->rows, _elem70);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_rows = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              Text key71 = NULL;
              Text val72 = NULL;
              if (key71 != NULL)
              {
                g_free(key71);
                key71 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              key71 = g_byte_array_new();
              g_byte_array_append (key71, (guint8 *) data, (guint) len);
              g_free (data);
              if (val72 != NULL)
              {
                g_free(val72);
                val72 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              val72 = g_byte_array_new();
              g_byte_array_append (val72, (guint8 *) data, (guint) len);
              g_free (data);
              if (this_object->attributes && key71)
                g_hash_table_insert ((GHashTable *)this_object->attributes, (gpointer) key71, (gpointer) val72);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_attributes = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
hbase_get_rows_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  HbaseGetRowsArgs * this_object = HBASE_GET_ROWS_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "HbaseGetRowsArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "tableName", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->tableName ? ((GByteArray *) this_object->tableName)->data : NULL, this_object->tableName ? ((GByteArray *) this_object->tableName)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "rows", T_LIST, 2, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i73;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (this_object->rows ? this_object->rows->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i73 = 0; i73 < (this_object->rows ? this_object->rows->len : 0); i73++)
    {
      if ((ret = thrift_protocol_write_binary (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->rows, i73)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->rows, i73)))->data : NULL, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->rows, i73)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->rows, i73)))->len : 0, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "attributes", T_MAP, 3, error)) < 0)
    return -1;
  xfer += ret;
  {
    Text key74 = NULL;
    Text val75 = NULL;
    GList *key_list = NULL, *iter = NULL;
    Text* keys;
    int i = 0, key_count;

    if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRING, this_object->attributes ? (gint32) g_hash_table_size ((GHashTable *) this_object->attributes) : 0, error)) < 0)
      return -1;
    xfer += ret;
    if (this_object->attributes)
      g_hash_table_foreach ((GHashTable *) this_object->attributes, thrift_hash_table_get_keys, &key_list);
    key_count = g_list_length (key_list);
    keys = g_newa (Text, key_count);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
      keys[i++] = (Text) iter->data;
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key74 = keys[i];
      val75 = (Text) g_hash_table_lookup (((GHashTable *) this_object->attributes), (gpointer) key74);

      if ((ret = thrift_protocol_write_binary (protocol,  key74 ? ((GByteArray *)  key74)->data : NULL,  key74 ? ((GByteArray *)  key74)->len : 0, error)) < 0)
        return -1;
      xfer += ret;

      if ((ret = thrift_protocol_write_binary (protocol,  val75 ? ((GByteArray *)  val75)->data : NULL,  val75 ? ((GByteArray *)  val75)->len : 0, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
hbase_get_rows_args_set_property (GObject *object,
                                  guint property_id,
                                  const GValue *value,
                                  GParamSpec *pspec)
{
  HbaseGetRowsArgs *self = HBASE_GET_ROWS_ARGS (object);

  switch (property_id)
  {
    case PROP_HBASE_GET_ROWS_ARGS_TABLE_NAME:
      if (self->tableName != NULL)
        g_byte_array_unref (self->tableName);
      self->tableName = g_value_dup_boxed (value);
      self->__isset_tableName = TRUE;
      break;

    case PROP_HBASE_GET_ROWS_ARGS_ROWS:
      if (self->rows != NULL)
        g_ptr_array_unref (self->rows);
      self->rows = g_value_dup_boxed (value);
      self->__isset_rows = TRUE;
      break;

    case PROP_HBASE_GET_ROWS_ARGS_ATTRIBUTES:
      if (self->attributes != NULL)
        g_hash_table_unref (self->attributes);
      self->attributes = g_value_dup_boxed (value);
      self->__isset_attributes = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
hbase_get_rows_args_get_property (GObject *object,
                                  guint property_id,
                                  GValue *value,
                                  GParamSpec *pspec)
{
  HbaseGetRowsArgs *self = HBASE_GET_ROWS_ARGS (object);

  switch (property_id)
  {
    case PROP_HBASE_GET_ROWS_ARGS_TABLE_NAME:
      g_value_set_boxed (value, self->tableName);
      break;

    case PROP_HBASE_GET_ROWS_ARGS_ROWS:
      g_value_set_boxed (value, self->rows);
      break;

    case PROP_HBASE_GET_ROWS_ARGS_ATTRIBUTES:
      g_value_set_boxed (value, self->attributes);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
hbase_get_rows_args_instance_init (HbaseGetRowsArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->tableName = NULL;
  object->__isset_tableName = FALSE;
  object->rows = g_ptr_array_new_with_free_func (thrift_string_free);
  object->__isset_rows = FALSE;
  object->attributes = g_hash_table_new_full (g_str_hash, g_str_equal, thrift_string_free, thrift_string_free);
  object->__isset_attributes = FALSE;
}

static void 
hbase_get_rows_args_finalize (GObject *object)
{
  HbaseGetRowsArgs *tobject = HBASE_GET_ROWS_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->tableName != NULL)
  {
    thrift_string_free(tobject->tableName);
    tobject->tableName = NULL;
  }
  if (tobject->rows != NULL)
  {
    g_ptr_array_unref (tobject->rows);
    tobject->rows = NULL;
  }
  if (tobject->attributes != NULL)
  {
    g_hash_table_destroy (tobject->attributes);
    tobject->attributes = NULL;
  }
}

static void
hbase_get_rows_args_class_init (HbaseGetRowsArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = hbase_get_rows_args_read;
  struct_class->write = hbase_get_rows_args_write;

  gobject_class->finalize = hbase_get_rows_args_finalize;
  gobject_class->get_property = hbase_get_rows_args_get_property;
  gobject_class->set_property = hbase_get_rows_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_GET_ROWS_ARGS_TABLE_NAME,
     g_param_spec_boxed ("tableName",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_GET_ROWS_ARGS_ROWS,
     g_param_spec_boxed ("rows",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_GET_ROWS_ARGS_ATTRIBUTES,
     g_param_spec_boxed ("attributes",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));
}

GType
hbase_get_rows_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (HbaseGetRowsArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) hbase_get_rows_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (HbaseGetRowsArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) hbase_get_rows_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "HbaseGetRowsArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _HbaseGetRowsResultProperties
{
  PROP_HBASE_GET_ROWS_RESULT_0,
  PROP_HBASE_GET_ROWS_RESULT_SUCCESS,
  PROP_HBASE_GET_ROWS_RESULT_IO
};

/* reads a hbase_get_rows_result object */
static gint32
hbase_get_rows_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  HbaseGetRowsResult * this_object = HBASE_GET_ROWS_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              TRowResult * _elem76 = NULL;
              if ( _elem76 != NULL)
              {
                g_object_unref (_elem76);
              }
              _elem76 = g_object_new (TYPE_T_ROW_RESULT, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem76), protocol, error)) < 0)
              {
                g_object_unref (_elem76);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->success, _elem76);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->io != NULL)
          {
            g_object_unref (this_object->io);
          }
          this_object->io = g_object_new (TYPE_I_O_ERROR, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
          {
            g_object_unref (this_object->io);
            this_object->io = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_io = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
hbase_get_rows_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  HbaseGetRowsResult * this_object = HBASE_GET_ROWS_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "HbaseGetRowsResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_LIST, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i77;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->success ? this_object->success->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i77 = 0; i77 < (this_object->success ? this_object->success->len : 0); i77++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->success, i77))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_io == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "io", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
hbase_get_rows_result_set_property (GObject *object,
                                    guint property_id,
                                    const GValue *value,
                                    GParamSpec *pspec)
{
  HbaseGetRowsResult *self = HBASE_GET_ROWS_RESULT (object);

  switch (property_id)
  {
    case PROP_HBASE_GET_ROWS_RESULT_SUCCESS:
      if (self->success != NULL)
        g_ptr_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    case PROP_HBASE_GET_ROWS_RESULT_IO:
      if (self->io != NULL)
        g_object_unref (self->io);
      self->io = g_value_dup_object (value);
      self->__isset_io = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
hbase_get_rows_result_get_property (GObject *object,
                                    guint property_id,
                                    GValue *value,
                                    GParamSpec *pspec)
{
  HbaseGetRowsResult *self = HBASE_GET_ROWS_RESULT (object);

  switch (property_id)
  {
    case PROP_HBASE_GET_ROWS_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    case PROP_HBASE_GET_ROWS_RESULT_IO:
      g_value_set_object (value, self->io);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
hbase_get_rows_result_instance_init (HbaseGetRowsResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_success = FALSE;
  object->io = NULL;
  object->__isset_io = FALSE;
}

static void 
hbase_get_rows_result_finalize (GObject *object)
{
  HbaseGetRowsResult *tobject = HBASE_GET_ROWS_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_ptr_array_unref (tobject->success);
    tobject->success = NULL;
  }
  if (tobject->io != NULL)
  {
    g_object_unref(tobject->io);
    tobject->io = NULL;
  }
}

static void
hbase_get_rows_result_class_init (HbaseGetRowsResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = hbase_get_rows_result_read;
  struct_class->write = hbase_get_rows_result_write;

  gobject_class->finalize = hbase_get_rows_result_finalize;
  gobject_class->get_property = hbase_get_rows_result_get_property;
  gobject_class->set_property = hbase_get_rows_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_GET_ROWS_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_GET_ROWS_RESULT_IO,
     g_param_spec_object ("io",
                         NULL,
                         NULL,
                         TYPE_I_O_ERROR,
                         G_PARAM_READWRITE));
}

GType
hbase_get_rows_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (HbaseGetRowsResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) hbase_get_rows_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (HbaseGetRowsResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) hbase_get_rows_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "HbaseGetRowsResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _HbaseGetRowsWithColumnsArgsProperties
{
  PROP_HBASE_GET_ROWS_WITH_COLUMNS_ARGS_0,
  PROP_HBASE_GET_ROWS_WITH_COLUMNS_ARGS_TABLE_NAME,
  PROP_HBASE_GET_ROWS_WITH_COLUMNS_ARGS_ROWS,
  PROP_HBASE_GET_ROWS_WITH_COLUMNS_ARGS_COLUMNS,
  PROP_HBASE_GET_ROWS_WITH_COLUMNS_ARGS_ATTRIBUTES
};

/* reads a hbase_get_rows_with_columns_args object */
static gint32
hbase_get_rows_with_columns_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  HbaseGetRowsWithColumnsArgs * this_object = HBASE_GET_ROWS_WITH_COLUMNS_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->tableName != NULL)
          {
            g_free(this_object->tableName);
            this_object->tableName = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->tableName = g_byte_array_new();
          g_byte_array_append (this_object->tableName, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_tableName = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              GByteArray * _elem78 = NULL;
              if (_elem78 != NULL)
              {
                g_free(_elem78);
                _elem78 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              _elem78 = g_byte_array_new();
              g_byte_array_append (_elem78, (guint8 *) data, (guint) len);
              g_free (data);
              g_ptr_array_add (this_object->rows, _elem78);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_rows = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              GByteArray * _elem79 = NULL;
              if (_elem79 != NULL)
              {
                g_free(_elem79);
                _elem79 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              _elem79 = g_byte_array_new();
              g_byte_array_append (_elem79, (guint8 *) data, (guint) len);
              g_free (data);
              g_ptr_array_add (this_object->columns, _elem79);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_columns = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              Text key80 = NULL;
              Text val81 = NULL;
              if (key80 != NULL)
              {
                g_free(key80);
                key80 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              key80 = g_byte_array_new();
              g_byte_array_append (key80, (guint8 *) data, (guint) len);
              g_free (data);
              if (val81 != NULL)
              {
                g_free(val81);
                val81 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              val81 = g_byte_array_new();
              g_byte_array_append (val81, (guint8 *) data, (guint) len);
              g_free (data);
              if (this_object->attributes && key80)
                g_hash_table_insert ((GHashTable *)this_object->attributes, (gpointer) key80, (gpointer) val81);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_attributes = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
hbase_get_rows_with_columns_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  HbaseGetRowsWithColumnsArgs * this_object = HBASE_GET_ROWS_WITH_COLUMNS_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "HbaseGetRowsWithColumnsArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "tableName", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->tableName ? ((GByteArray *) this_object->tableName)->data : NULL, this_object->tableName ? ((GByteArray *) this_object->tableName)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "rows", T_LIST, 2, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i82;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (this_object->rows ? this_object->rows->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i82 = 0; i82 < (this_object->rows ? this_object->rows->len : 0); i82++)
    {
      if ((ret = thrift_protocol_write_binary (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->rows, i82)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->rows, i82)))->data : NULL, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->rows, i82)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->rows, i82)))->len : 0, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "columns", T_LIST, 3, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i83;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (this_object->columns ? this_object->columns->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i83 = 0; i83 < (this_object->columns ? this_object->columns->len : 0); i83++)
    {
      if ((ret = thrift_protocol_write_binary (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->columns, i83)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->columns, i83)))->data : NULL, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->columns, i83)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->columns, i83)))->len : 0, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "attributes", T_MAP, 4, error)) < 0)
    return -1;
  xfer += ret;
  {
    Text key84 = NULL;
    Text val85 = NULL;
    GList *key_list = NULL, *iter = NULL;
    Text* keys;
    int i = 0, key_count;

    if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRING, this_object->attributes ? (gint32) g_hash_table_size ((GHashTable *) this_object->attributes) : 0, error)) < 0)
      return -1;
    xfer += ret;
    if (this_object->attributes)
      g_hash_table_foreach ((GHashTable *) this_object->attributes, thrift_hash_table_get_keys, &key_list);
    key_count = g_list_length (key_list);
    keys = g_newa (Text, key_count);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
      keys[i++] = (Text) iter->data;
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key84 = keys[i];
      val85 = (Text) g_hash_table_lookup (((GHashTable *) this_object->attributes), (gpointer) key84);

      if ((ret = thrift_protocol_write_binary (protocol,  key84 ? ((GByteArray *)  key84)->data : NULL,  key84 ? ((GByteArray *)  key84)->len : 0, error)) < 0)
        return -1;
      xfer += ret;

      if ((ret = thrift_protocol_write_binary (protocol,  val85 ? ((GByteArray *)  val85)->data : NULL,  val85 ? ((GByteArray *)  val85)->len : 0, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
hbase_get_rows_with_columns_args_set_property (GObject *object,
                                               guint property_id,
                                               const GValue *value,
                                               GParamSpec *pspec)
{
  HbaseGetRowsWithColumnsArgs *self = HBASE_GET_ROWS_WITH_COLUMNS_ARGS (object);

  switch (property_id)
  {
    case PROP_HBASE_GET_ROWS_WITH_COLUMNS_ARGS_TABLE_NAME:
      if (self->tableName != NULL)
        g_byte_array_unref (self->tableName);
      self->tableName = g_value_dup_boxed (value);
      self->__isset_tableName = TRUE;
      break;

    case PROP_HBASE_GET_ROWS_WITH_COLUMNS_ARGS_ROWS:
      if (self->rows != NULL)
        g_ptr_array_unref (self->rows);
      self->rows = g_value_dup_boxed (value);
      self->__isset_rows = TRUE;
      break;

    case PROP_HBASE_GET_ROWS_WITH_COLUMNS_ARGS_COLUMNS:
      if (self->columns != NULL)
        g_ptr_array_unref (self->columns);
      self->columns = g_value_dup_boxed (value);
      self->__isset_columns = TRUE;
      break;

    case PROP_HBASE_GET_ROWS_WITH_COLUMNS_ARGS_ATTRIBUTES:
      if (self->attributes != NULL)
        g_hash_table_unref (self->attributes);
      self->attributes = g_value_dup_boxed (value);
      self->__isset_attributes = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
hbase_get_rows_with_columns_args_get_property (GObject *object,
                                               guint property_id,
                                               GValue *value,
                                               GParamSpec *pspec)
{
  HbaseGetRowsWithColumnsArgs *self = HBASE_GET_ROWS_WITH_COLUMNS_ARGS (object);

  switch (property_id)
  {
    case PROP_HBASE_GET_ROWS_WITH_COLUMNS_ARGS_TABLE_NAME:
      g_value_set_boxed (value, self->tableName);
      break;

    case PROP_HBASE_GET_ROWS_WITH_COLUMNS_ARGS_ROWS:
      g_value_set_boxed (value, self->rows);
      break;

    case PROP_HBASE_GET_ROWS_WITH_COLUMNS_ARGS_COLUMNS:
      g_value_set_boxed (value, self->columns);
      break;

    case PROP_HBASE_GET_ROWS_WITH_COLUMNS_ARGS_ATTRIBUTES:
      g_value_set_boxed (value, self->attributes);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
hbase_get_rows_with_columns_args_instance_init (HbaseGetRowsWithColumnsArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->tableName = NULL;
  object->__isset_tableName = FALSE;
  object->rows = g_ptr_array_new_with_free_func (thrift_string_free);
  object->__isset_rows = FALSE;
  object->columns = g_ptr_array_new_with_free_func (thrift_string_free);
  object->__isset_columns = FALSE;
  object->attributes = g_hash_table_new_full (g_str_hash, g_str_equal, thrift_string_free, thrift_string_free);
  object->__isset_attributes = FALSE;
}

static void 
hbase_get_rows_with_columns_args_finalize (GObject *object)
{
  HbaseGetRowsWithColumnsArgs *tobject = HBASE_GET_ROWS_WITH_COLUMNS_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->tableName != NULL)
  {
    thrift_string_free(tobject->tableName);
    tobject->tableName = NULL;
  }
  if (tobject->rows != NULL)
  {
    g_ptr_array_unref (tobject->rows);
    tobject->rows = NULL;
  }
  if (tobject->columns != NULL)
  {
    g_ptr_array_unref (tobject->columns);
    tobject->columns = NULL;
  }
  if (tobject->attributes != NULL)
  {
    g_hash_table_destroy (tobject->attributes);
    tobject->attributes = NULL;
  }
}

static void
hbase_get_rows_with_columns_args_class_init (HbaseGetRowsWithColumnsArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = hbase_get_rows_with_columns_args_read;
  struct_class->write = hbase_get_rows_with_columns_args_write;

  gobject_class->finalize = hbase_get_rows_with_columns_args_finalize;
  gobject_class->get_property = hbase_get_rows_with_columns_args_get_property;
  gobject_class->set_property = hbase_get_rows_with_columns_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_GET_ROWS_WITH_COLUMNS_ARGS_TABLE_NAME,
     g_param_spec_boxed ("tableName",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_GET_ROWS_WITH_COLUMNS_ARGS_ROWS,
     g_param_spec_boxed ("rows",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_GET_ROWS_WITH_COLUMNS_ARGS_COLUMNS,
     g_param_spec_boxed ("columns",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_GET_ROWS_WITH_COLUMNS_ARGS_ATTRIBUTES,
     g_param_spec_boxed ("attributes",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));
}

GType
hbase_get_rows_with_columns_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (HbaseGetRowsWithColumnsArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) hbase_get_rows_with_columns_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (HbaseGetRowsWithColumnsArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) hbase_get_rows_with_columns_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "HbaseGetRowsWithColumnsArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _HbaseGetRowsWithColumnsResultProperties
{
  PROP_HBASE_GET_ROWS_WITH_COLUMNS_RESULT_0,
  PROP_HBASE_GET_ROWS_WITH_COLUMNS_RESULT_SUCCESS,
  PROP_HBASE_GET_ROWS_WITH_COLUMNS_RESULT_IO
};

/* reads a hbase_get_rows_with_columns_result object */
static gint32
hbase_get_rows_with_columns_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  HbaseGetRowsWithColumnsResult * this_object = HBASE_GET_ROWS_WITH_COLUMNS_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              TRowResult * _elem86 = NULL;
              if ( _elem86 != NULL)
              {
                g_object_unref (_elem86);
              }
              _elem86 = g_object_new (TYPE_T_ROW_RESULT, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem86), protocol, error)) < 0)
              {
                g_object_unref (_elem86);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->success, _elem86);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->io != NULL)
          {
            g_object_unref (this_object->io);
          }
          this_object->io = g_object_new (TYPE_I_O_ERROR, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
          {
            g_object_unref (this_object->io);
            this_object->io = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_io = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
hbase_get_rows_with_columns_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  HbaseGetRowsWithColumnsResult * this_object = HBASE_GET_ROWS_WITH_COLUMNS_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "HbaseGetRowsWithColumnsResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_LIST, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i87;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->success ? this_object->success->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i87 = 0; i87 < (this_object->success ? this_object->success->len : 0); i87++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->success, i87))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_io == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "io", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
hbase_get_rows_with_columns_result_set_property (GObject *object,
                                                 guint property_id,
                                                 const GValue *value,
                                                 GParamSpec *pspec)
{
  HbaseGetRowsWithColumnsResult *self = HBASE_GET_ROWS_WITH_COLUMNS_RESULT (object);

  switch (property_id)
  {
    case PROP_HBASE_GET_ROWS_WITH_COLUMNS_RESULT_SUCCESS:
      if (self->success != NULL)
        g_ptr_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    case PROP_HBASE_GET_ROWS_WITH_COLUMNS_RESULT_IO:
      if (self->io != NULL)
        g_object_unref (self->io);
      self->io = g_value_dup_object (value);
      self->__isset_io = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
hbase_get_rows_with_columns_result_get_property (GObject *object,
                                                 guint property_id,
                                                 GValue *value,
                                                 GParamSpec *pspec)
{
  HbaseGetRowsWithColumnsResult *self = HBASE_GET_ROWS_WITH_COLUMNS_RESULT (object);

  switch (property_id)
  {
    case PROP_HBASE_GET_ROWS_WITH_COLUMNS_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    case PROP_HBASE_GET_ROWS_WITH_COLUMNS_RESULT_IO:
      g_value_set_object (value, self->io);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
hbase_get_rows_with_columns_result_instance_init (HbaseGetRowsWithColumnsResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_success = FALSE;
  object->io = NULL;
  object->__isset_io = FALSE;
}

static void 
hbase_get_rows_with_columns_result_finalize (GObject *object)
{
  HbaseGetRowsWithColumnsResult *tobject = HBASE_GET_ROWS_WITH_COLUMNS_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_ptr_array_unref (tobject->success);
    tobject->success = NULL;
  }
  if (tobject->io != NULL)
  {
    g_object_unref(tobject->io);
    tobject->io = NULL;
  }
}

static void
hbase_get_rows_with_columns_result_class_init (HbaseGetRowsWithColumnsResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = hbase_get_rows_with_columns_result_read;
  struct_class->write = hbase_get_rows_with_columns_result_write;

  gobject_class->finalize = hbase_get_rows_with_columns_result_finalize;
  gobject_class->get_property = hbase_get_rows_with_columns_result_get_property;
  gobject_class->set_property = hbase_get_rows_with_columns_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_GET_ROWS_WITH_COLUMNS_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_GET_ROWS_WITH_COLUMNS_RESULT_IO,
     g_param_spec_object ("io",
                         NULL,
                         NULL,
                         TYPE_I_O_ERROR,
                         G_PARAM_READWRITE));
}

GType
hbase_get_rows_with_columns_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (HbaseGetRowsWithColumnsResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) hbase_get_rows_with_columns_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (HbaseGetRowsWithColumnsResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) hbase_get_rows_with_columns_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "HbaseGetRowsWithColumnsResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _HbaseGetRowsTsArgsProperties
{
  PROP_HBASE_GET_ROWS_TS_ARGS_0,
  PROP_HBASE_GET_ROWS_TS_ARGS_TABLE_NAME,
  PROP_HBASE_GET_ROWS_TS_ARGS_ROWS,
  PROP_HBASE_GET_ROWS_TS_ARGS_TIMESTAMP,
  PROP_HBASE_GET_ROWS_TS_ARGS_ATTRIBUTES
};

/* reads a hbase_get_rows_ts_args object */
static gint32
hbase_get_rows_ts_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  HbaseGetRowsTsArgs * this_object = HBASE_GET_ROWS_TS_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->tableName != NULL)
          {
            g_free(this_object->tableName);
            this_object->tableName = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->tableName = g_byte_array_new();
          g_byte_array_append (this_object->tableName, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_tableName = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              GByteArray * _elem88 = NULL;
              if (_elem88 != NULL)
              {
                g_free(_elem88);
                _elem88 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              _elem88 = g_byte_array_new();
              g_byte_array_append (_elem88, (guint8 *) data, (guint) len);
              g_free (data);
              g_ptr_array_add (this_object->rows, _elem88);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_rows = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->timestamp, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_timestamp = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              Text key89 = NULL;
              Text val90 = NULL;
              if (key89 != NULL)
              {
                g_free(key89);
                key89 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              key89 = g_byte_array_new();
              g_byte_array_append (key89, (guint8 *) data, (guint) len);
              g_free (data);
              if (val90 != NULL)
              {
                g_free(val90);
                val90 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              val90 = g_byte_array_new();
              g_byte_array_append (val90, (guint8 *) data, (guint) len);
              g_free (data);
              if (this_object->attributes && key89)
                g_hash_table_insert ((GHashTable *)this_object->attributes, (gpointer) key89, (gpointer) val90);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_attributes = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
hbase_get_rows_ts_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  HbaseGetRowsTsArgs * this_object = HBASE_GET_ROWS_TS_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "HbaseGetRowsTsArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "tableName", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->tableName ? ((GByteArray *) this_object->tableName)->data : NULL, this_object->tableName ? ((GByteArray *) this_object->tableName)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "rows", T_LIST, 2, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i91;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (this_object->rows ? this_object->rows->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i91 = 0; i91 < (this_object->rows ? this_object->rows->len : 0); i91++)
    {
      if ((ret = thrift_protocol_write_binary (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->rows, i91)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->rows, i91)))->data : NULL, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->rows, i91)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->rows, i91)))->len : 0, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "timestamp", T_I64, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->timestamp, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "attributes", T_MAP, 4, error)) < 0)
    return -1;
  xfer += ret;
  {
    Text key92 = NULL;
    Text val93 = NULL;
    GList *key_list = NULL, *iter = NULL;
    Text* keys;
    int i = 0, key_count;

    if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRING, this_object->attributes ? (gint32) g_hash_table_size ((GHashTable *) this_object->attributes) : 0, error)) < 0)
      return -1;
    xfer += ret;
    if (this_object->attributes)
      g_hash_table_foreach ((GHashTable *) this_object->attributes, thrift_hash_table_get_keys, &key_list);
    key_count = g_list_length (key_list);
    keys = g_newa (Text, key_count);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
      keys[i++] = (Text) iter->data;
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key92 = keys[i];
      val93 = (Text) g_hash_table_lookup (((GHashTable *) this_object->attributes), (gpointer) key92);

      if ((ret = thrift_protocol_write_binary (protocol,  key92 ? ((GByteArray *)  key92)->data : NULL,  key92 ? ((GByteArray *)  key92)->len : 0, error)) < 0)
        return -1;
      xfer += ret;

      if ((ret = thrift_protocol_write_binary (protocol,  val93 ? ((GByteArray *)  val93)->data : NULL,  val93 ? ((GByteArray *)  val93)->len : 0, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
hbase_get_rows_ts_args_set_property (GObject *object,
                                     guint property_id,
                                     const GValue *value,
                                     GParamSpec *pspec)
{
  HbaseGetRowsTsArgs *self = HBASE_GET_ROWS_TS_ARGS (object);

  switch (property_id)
  {
    case PROP_HBASE_GET_ROWS_TS_ARGS_TABLE_NAME:
      if (self->tableName != NULL)
        g_byte_array_unref (self->tableName);
      self->tableName = g_value_dup_boxed (value);
      self->__isset_tableName = TRUE;
      break;

    case PROP_HBASE_GET_ROWS_TS_ARGS_ROWS:
      if (self->rows != NULL)
        g_ptr_array_unref (self->rows);
      self->rows = g_value_dup_boxed (value);
      self->__isset_rows = TRUE;
      break;

    case PROP_HBASE_GET_ROWS_TS_ARGS_TIMESTAMP:
      self->timestamp = g_value_get_int64 (value);
      self->__isset_timestamp = TRUE;
      break;

    case PROP_HBASE_GET_ROWS_TS_ARGS_ATTRIBUTES:
      if (self->attributes != NULL)
        g_hash_table_unref (self->attributes);
      self->attributes = g_value_dup_boxed (value);
      self->__isset_attributes = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
hbase_get_rows_ts_args_get_property (GObject *object,
                                     guint property_id,
                                     GValue *value,
                                     GParamSpec *pspec)
{
  HbaseGetRowsTsArgs *self = HBASE_GET_ROWS_TS_ARGS (object);

  switch (property_id)
  {
    case PROP_HBASE_GET_ROWS_TS_ARGS_TABLE_NAME:
      g_value_set_boxed (value, self->tableName);
      break;

    case PROP_HBASE_GET_ROWS_TS_ARGS_ROWS:
      g_value_set_boxed (value, self->rows);
      break;

    case PROP_HBASE_GET_ROWS_TS_ARGS_TIMESTAMP:
      g_value_set_int64 (value, self->timestamp);
      break;

    case PROP_HBASE_GET_ROWS_TS_ARGS_ATTRIBUTES:
      g_value_set_boxed (value, self->attributes);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
hbase_get_rows_ts_args_instance_init (HbaseGetRowsTsArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->tableName = NULL;
  object->__isset_tableName = FALSE;
  object->rows = g_ptr_array_new_with_free_func (thrift_string_free);
  object->__isset_rows = FALSE;
  object->timestamp = 0;
  object->__isset_timestamp = FALSE;
  object->attributes = g_hash_table_new_full (g_str_hash, g_str_equal, thrift_string_free, thrift_string_free);
  object->__isset_attributes = FALSE;
}

static void 
hbase_get_rows_ts_args_finalize (GObject *object)
{
  HbaseGetRowsTsArgs *tobject = HBASE_GET_ROWS_TS_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->tableName != NULL)
  {
    thrift_string_free(tobject->tableName);
    tobject->tableName = NULL;
  }
  if (tobject->rows != NULL)
  {
    g_ptr_array_unref (tobject->rows);
    tobject->rows = NULL;
  }
  if (tobject->attributes != NULL)
  {
    g_hash_table_destroy (tobject->attributes);
    tobject->attributes = NULL;
  }
}

static void
hbase_get_rows_ts_args_class_init (HbaseGetRowsTsArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = hbase_get_rows_ts_args_read;
  struct_class->write = hbase_get_rows_ts_args_write;

  gobject_class->finalize = hbase_get_rows_ts_args_finalize;
  gobject_class->get_property = hbase_get_rows_ts_args_get_property;
  gobject_class->set_property = hbase_get_rows_ts_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_GET_ROWS_TS_ARGS_TABLE_NAME,
     g_param_spec_boxed ("tableName",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_GET_ROWS_TS_ARGS_ROWS,
     g_param_spec_boxed ("rows",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_GET_ROWS_TS_ARGS_TIMESTAMP,
     g_param_spec_int64 ("timestamp",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_GET_ROWS_TS_ARGS_ATTRIBUTES,
     g_param_spec_boxed ("attributes",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));
}

GType
hbase_get_rows_ts_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (HbaseGetRowsTsArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) hbase_get_rows_ts_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (HbaseGetRowsTsArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) hbase_get_rows_ts_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "HbaseGetRowsTsArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _HbaseGetRowsTsResultProperties
{
  PROP_HBASE_GET_ROWS_TS_RESULT_0,
  PROP_HBASE_GET_ROWS_TS_RESULT_SUCCESS,
  PROP_HBASE_GET_ROWS_TS_RESULT_IO
};

/* reads a hbase_get_rows_ts_result object */
static gint32
hbase_get_rows_ts_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  HbaseGetRowsTsResult * this_object = HBASE_GET_ROWS_TS_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              TRowResult * _elem94 = NULL;
              if ( _elem94 != NULL)
              {
                g_object_unref (_elem94);
              }
              _elem94 = g_object_new (TYPE_T_ROW_RESULT, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem94), protocol, error)) < 0)
              {
                g_object_unref (_elem94);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->success, _elem94);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->io != NULL)
          {
            g_object_unref (this_object->io);
          }
          this_object->io = g_object_new (TYPE_I_O_ERROR, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
          {
            g_object_unref (this_object->io);
            this_object->io = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_io = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
hbase_get_rows_ts_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  HbaseGetRowsTsResult * this_object = HBASE_GET_ROWS_TS_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "HbaseGetRowsTsResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_LIST, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i95;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->success ? this_object->success->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i95 = 0; i95 < (this_object->success ? this_object->success->len : 0); i95++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->success, i95))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_io == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "io", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
hbase_get_rows_ts_result_set_property (GObject *object,
                                       guint property_id,
                                       const GValue *value,
                                       GParamSpec *pspec)
{
  HbaseGetRowsTsResult *self = HBASE_GET_ROWS_TS_RESULT (object);

  switch (property_id)
  {
    case PROP_HBASE_GET_ROWS_TS_RESULT_SUCCESS:
      if (self->success != NULL)
        g_ptr_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    case PROP_HBASE_GET_ROWS_TS_RESULT_IO:
      if (self->io != NULL)
        g_object_unref (self->io);
      self->io = g_value_dup_object (value);
      self->__isset_io = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
hbase_get_rows_ts_result_get_property (GObject *object,
                                       guint property_id,
                                       GValue *value,
                                       GParamSpec *pspec)
{
  HbaseGetRowsTsResult *self = HBASE_GET_ROWS_TS_RESULT (object);

  switch (property_id)
  {
    case PROP_HBASE_GET_ROWS_TS_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    case PROP_HBASE_GET_ROWS_TS_RESULT_IO:
      g_value_set_object (value, self->io);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
hbase_get_rows_ts_result_instance_init (HbaseGetRowsTsResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_success = FALSE;
  object->io = NULL;
  object->__isset_io = FALSE;
}

static void 
hbase_get_rows_ts_result_finalize (GObject *object)
{
  HbaseGetRowsTsResult *tobject = HBASE_GET_ROWS_TS_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_ptr_array_unref (tobject->success);
    tobject->success = NULL;
  }
  if (tobject->io != NULL)
  {
    g_object_unref(tobject->io);
    tobject->io = NULL;
  }
}

static void
hbase_get_rows_ts_result_class_init (HbaseGetRowsTsResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = hbase_get_rows_ts_result_read;
  struct_class->write = hbase_get_rows_ts_result_write;

  gobject_class->finalize = hbase_get_rows_ts_result_finalize;
  gobject_class->get_property = hbase_get_rows_ts_result_get_property;
  gobject_class->set_property = hbase_get_rows_ts_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_GET_ROWS_TS_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_GET_ROWS_TS_RESULT_IO,
     g_param_spec_object ("io",
                         NULL,
                         NULL,
                         TYPE_I_O_ERROR,
                         G_PARAM_READWRITE));
}

GType
hbase_get_rows_ts_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (HbaseGetRowsTsResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) hbase_get_rows_ts_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (HbaseGetRowsTsResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) hbase_get_rows_ts_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "HbaseGetRowsTsResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _HbaseGetRowsWithColumnsTsArgsProperties
{
  PROP_HBASE_GET_ROWS_WITH_COLUMNS_TS_ARGS_0,
  PROP_HBASE_GET_ROWS_WITH_COLUMNS_TS_ARGS_TABLE_NAME,
  PROP_HBASE_GET_ROWS_WITH_COLUMNS_TS_ARGS_ROWS,
  PROP_HBASE_GET_ROWS_WITH_COLUMNS_TS_ARGS_COLUMNS,
  PROP_HBASE_GET_ROWS_WITH_COLUMNS_TS_ARGS_TIMESTAMP,
  PROP_HBASE_GET_ROWS_WITH_COLUMNS_TS_ARGS_ATTRIBUTES
};

/* reads a hbase_get_rows_with_columns_ts_args object */
static gint32
hbase_get_rows_with_columns_ts_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  HbaseGetRowsWithColumnsTsArgs * this_object = HBASE_GET_ROWS_WITH_COLUMNS_TS_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->tableName != NULL)
          {
            g_free(this_object->tableName);
            this_object->tableName = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->tableName = g_byte_array_new();
          g_byte_array_append (this_object->tableName, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_tableName = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              GByteArray * _elem96 = NULL;
              if (_elem96 != NULL)
              {
                g_free(_elem96);
                _elem96 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              _elem96 = g_byte_array_new();
              g_byte_array_append (_elem96, (guint8 *) data, (guint) len);
              g_free (data);
              g_ptr_array_add (this_object->rows, _elem96);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_rows = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              GByteArray * _elem97 = NULL;
              if (_elem97 != NULL)
              {
                g_free(_elem97);
                _elem97 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              _elem97 = g_byte_array_new();
              g_byte_array_append (_elem97, (guint8 *) data, (guint) len);
              g_free (data);
              g_ptr_array_add (this_object->columns, _elem97);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_columns = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->timestamp, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_timestamp = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              Text key98 = NULL;
              Text val99 = NULL;
              if (key98 != NULL)
              {
                g_free(key98);
                key98 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              key98 = g_byte_array_new();
              g_byte_array_append (key98, (guint8 *) data, (guint) len);
              g_free (data);
              if (val99 != NULL)
              {
                g_free(val99);
                val99 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              val99 = g_byte_array_new();
              g_byte_array_append (val99, (guint8 *) data, (guint) len);
              g_free (data);
              if (this_object->attributes && key98)
                g_hash_table_insert ((GHashTable *)this_object->attributes, (gpointer) key98, (gpointer) val99);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_attributes = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
hbase_get_rows_with_columns_ts_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  HbaseGetRowsWithColumnsTsArgs * this_object = HBASE_GET_ROWS_WITH_COLUMNS_TS_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "HbaseGetRowsWithColumnsTsArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "tableName", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->tableName ? ((GByteArray *) this_object->tableName)->data : NULL, this_object->tableName ? ((GByteArray *) this_object->tableName)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "rows", T_LIST, 2, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i100;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (this_object->rows ? this_object->rows->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i100 = 0; i100 < (this_object->rows ? this_object->rows->len : 0); i100++)
    {
      if ((ret = thrift_protocol_write_binary (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->rows, i100)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->rows, i100)))->data : NULL, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->rows, i100)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->rows, i100)))->len : 0, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "columns", T_LIST, 3, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i101;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (this_object->columns ? this_object->columns->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i101 = 0; i101 < (this_object->columns ? this_object->columns->len : 0); i101++)
    {
      if ((ret = thrift_protocol_write_binary (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->columns, i101)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->columns, i101)))->data : NULL, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->columns, i101)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->columns, i101)))->len : 0, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "timestamp", T_I64, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->timestamp, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "attributes", T_MAP, 5, error)) < 0)
    return -1;
  xfer += ret;
  {
    Text key102 = NULL;
    Text val103 = NULL;
    GList *key_list = NULL, *iter = NULL;
    Text* keys;
    int i = 0, key_count;

    if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRING, this_object->attributes ? (gint32) g_hash_table_size ((GHashTable *) this_object->attributes) : 0, error)) < 0)
      return -1;
    xfer += ret;
    if (this_object->attributes)
      g_hash_table_foreach ((GHashTable *) this_object->attributes, thrift_hash_table_get_keys, &key_list);
    key_count = g_list_length (key_list);
    keys = g_newa (Text, key_count);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
      keys[i++] = (Text) iter->data;
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key102 = keys[i];
      val103 = (Text) g_hash_table_lookup (((GHashTable *) this_object->attributes), (gpointer) key102);

      if ((ret = thrift_protocol_write_binary (protocol,  key102 ? ((GByteArray *)  key102)->data : NULL,  key102 ? ((GByteArray *)  key102)->len : 0, error)) < 0)
        return -1;
      xfer += ret;

      if ((ret = thrift_protocol_write_binary (protocol,  val103 ? ((GByteArray *)  val103)->data : NULL,  val103 ? ((GByteArray *)  val103)->len : 0, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
hbase_get_rows_with_columns_ts_args_set_property (GObject *object,
                                                  guint property_id,
                                                  const GValue *value,
                                                  GParamSpec *pspec)
{
  HbaseGetRowsWithColumnsTsArgs *self = HBASE_GET_ROWS_WITH_COLUMNS_TS_ARGS (object);

  switch (property_id)
  {
    case PROP_HBASE_GET_ROWS_WITH_COLUMNS_TS_ARGS_TABLE_NAME:
      if (self->tableName != NULL)
        g_byte_array_unref (self->tableName);
      self->tableName = g_value_dup_boxed (value);
      self->__isset_tableName = TRUE;
      break;

    case PROP_HBASE_GET_ROWS_WITH_COLUMNS_TS_ARGS_ROWS:
      if (self->rows != NULL)
        g_ptr_array_unref (self->rows);
      self->rows = g_value_dup_boxed (value);
      self->__isset_rows = TRUE;
      break;

    case PROP_HBASE_GET_ROWS_WITH_COLUMNS_TS_ARGS_COLUMNS:
      if (self->columns != NULL)
        g_ptr_array_unref (self->columns);
      self->columns = g_value_dup_boxed (value);
      self->__isset_columns = TRUE;
      break;

    case PROP_HBASE_GET_ROWS_WITH_COLUMNS_TS_ARGS_TIMESTAMP:
      self->timestamp = g_value_get_int64 (value);
      self->__isset_timestamp = TRUE;
      break;

    case PROP_HBASE_GET_ROWS_WITH_COLUMNS_TS_ARGS_ATTRIBUTES:
      if (self->attributes != NULL)
        g_hash_table_unref (self->attributes);
      self->attributes = g_value_dup_boxed (value);
      self->__isset_attributes = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
hbase_get_rows_with_columns_ts_args_get_property (GObject *object,
                                                  guint property_id,
                                                  GValue *value,
                                                  GParamSpec *pspec)
{
  HbaseGetRowsWithColumnsTsArgs *self = HBASE_GET_ROWS_WITH_COLUMNS_TS_ARGS (object);

  switch (property_id)
  {
    case PROP_HBASE_GET_ROWS_WITH_COLUMNS_TS_ARGS_TABLE_NAME:
      g_value_set_boxed (value, self->tableName);
      break;

    case PROP_HBASE_GET_ROWS_WITH_COLUMNS_TS_ARGS_ROWS:
      g_value_set_boxed (value, self->rows);
      break;

    case PROP_HBASE_GET_ROWS_WITH_COLUMNS_TS_ARGS_COLUMNS:
      g_value_set_boxed (value, self->columns);
      break;

    case PROP_HBASE_GET_ROWS_WITH_COLUMNS_TS_ARGS_TIMESTAMP:
      g_value_set_int64 (value, self->timestamp);
      break;

    case PROP_HBASE_GET_ROWS_WITH_COLUMNS_TS_ARGS_ATTRIBUTES:
      g_value_set_boxed (value, self->attributes);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
hbase_get_rows_with_columns_ts_args_instance_init (HbaseGetRowsWithColumnsTsArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->tableName = NULL;
  object->__isset_tableName = FALSE;
  object->rows = g_ptr_array_new_with_free_func (thrift_string_free);
  object->__isset_rows = FALSE;
  object->columns = g_ptr_array_new_with_free_func (thrift_string_free);
  object->__isset_columns = FALSE;
  object->timestamp = 0;
  object->__isset_timestamp = FALSE;
  object->attributes = g_hash_table_new_full (g_str_hash, g_str_equal, thrift_string_free, thrift_string_free);
  object->__isset_attributes = FALSE;
}

static void 
hbase_get_rows_with_columns_ts_args_finalize (GObject *object)
{
  HbaseGetRowsWithColumnsTsArgs *tobject = HBASE_GET_ROWS_WITH_COLUMNS_TS_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->tableName != NULL)
  {
    thrift_string_free(tobject->tableName);
    tobject->tableName = NULL;
  }
  if (tobject->rows != NULL)
  {
    g_ptr_array_unref (tobject->rows);
    tobject->rows = NULL;
  }
  if (tobject->columns != NULL)
  {
    g_ptr_array_unref (tobject->columns);
    tobject->columns = NULL;
  }
  if (tobject->attributes != NULL)
  {
    g_hash_table_destroy (tobject->attributes);
    tobject->attributes = NULL;
  }
}

static void
hbase_get_rows_with_columns_ts_args_class_init (HbaseGetRowsWithColumnsTsArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = hbase_get_rows_with_columns_ts_args_read;
  struct_class->write = hbase_get_rows_with_columns_ts_args_write;

  gobject_class->finalize = hbase_get_rows_with_columns_ts_args_finalize;
  gobject_class->get_property = hbase_get_rows_with_columns_ts_args_get_property;
  gobject_class->set_property = hbase_get_rows_with_columns_ts_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_GET_ROWS_WITH_COLUMNS_TS_ARGS_TABLE_NAME,
     g_param_spec_boxed ("tableName",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_GET_ROWS_WITH_COLUMNS_TS_ARGS_ROWS,
     g_param_spec_boxed ("rows",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_GET_ROWS_WITH_COLUMNS_TS_ARGS_COLUMNS,
     g_param_spec_boxed ("columns",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_GET_ROWS_WITH_COLUMNS_TS_ARGS_TIMESTAMP,
     g_param_spec_int64 ("timestamp",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_GET_ROWS_WITH_COLUMNS_TS_ARGS_ATTRIBUTES,
     g_param_spec_boxed ("attributes",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));
}

GType
hbase_get_rows_with_columns_ts_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (HbaseGetRowsWithColumnsTsArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) hbase_get_rows_with_columns_ts_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (HbaseGetRowsWithColumnsTsArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) hbase_get_rows_with_columns_ts_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "HbaseGetRowsWithColumnsTsArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _HbaseGetRowsWithColumnsTsResultProperties
{
  PROP_HBASE_GET_ROWS_WITH_COLUMNS_TS_RESULT_0,
  PROP_HBASE_GET_ROWS_WITH_COLUMNS_TS_RESULT_SUCCESS,
  PROP_HBASE_GET_ROWS_WITH_COLUMNS_TS_RESULT_IO
};

/* reads a hbase_get_rows_with_columns_ts_result object */
static gint32
hbase_get_rows_with_columns_ts_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  HbaseGetRowsWithColumnsTsResult * this_object = HBASE_GET_ROWS_WITH_COLUMNS_TS_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              TRowResult * _elem104 = NULL;
              if ( _elem104 != NULL)
              {
                g_object_unref (_elem104);
              }
              _elem104 = g_object_new (TYPE_T_ROW_RESULT, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem104), protocol, error)) < 0)
              {
                g_object_unref (_elem104);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->success, _elem104);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->io != NULL)
          {
            g_object_unref (this_object->io);
          }
          this_object->io = g_object_new (TYPE_I_O_ERROR, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
          {
            g_object_unref (this_object->io);
            this_object->io = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_io = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
hbase_get_rows_with_columns_ts_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  HbaseGetRowsWithColumnsTsResult * this_object = HBASE_GET_ROWS_WITH_COLUMNS_TS_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "HbaseGetRowsWithColumnsTsResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_LIST, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i105;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->success ? this_object->success->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i105 = 0; i105 < (this_object->success ? this_object->success->len : 0); i105++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->success, i105))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_io == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "io", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
hbase_get_rows_with_columns_ts_result_set_property (GObject *object,
                                                    guint property_id,
                                                    const GValue *value,
                                                    GParamSpec *pspec)
{
  HbaseGetRowsWithColumnsTsResult *self = HBASE_GET_ROWS_WITH_COLUMNS_TS_RESULT (object);

  switch (property_id)
  {
    case PROP_HBASE_GET_ROWS_WITH_COLUMNS_TS_RESULT_SUCCESS:
      if (self->success != NULL)
        g_ptr_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    case PROP_HBASE_GET_ROWS_WITH_COLUMNS_TS_RESULT_IO:
      if (self->io != NULL)
        g_object_unref (self->io);
      self->io = g_value_dup_object (value);
      self->__isset_io = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
hbase_get_rows_with_columns_ts_result_get_property (GObject *object,
                                                    guint property_id,
                                                    GValue *value,
                                                    GParamSpec *pspec)
{
  HbaseGetRowsWithColumnsTsResult *self = HBASE_GET_ROWS_WITH_COLUMNS_TS_RESULT (object);

  switch (property_id)
  {
    case PROP_HBASE_GET_ROWS_WITH_COLUMNS_TS_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    case PROP_HBASE_GET_ROWS_WITH_COLUMNS_TS_RESULT_IO:
      g_value_set_object (value, self->io);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
hbase_get_rows_with_columns_ts_result_instance_init (HbaseGetRowsWithColumnsTsResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_success = FALSE;
  object->io = NULL;
  object->__isset_io = FALSE;
}

static void 
hbase_get_rows_with_columns_ts_result_finalize (GObject *object)
{
  HbaseGetRowsWithColumnsTsResult *tobject = HBASE_GET_ROWS_WITH_COLUMNS_TS_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_ptr_array_unref (tobject->success);
    tobject->success = NULL;
  }
  if (tobject->io != NULL)
  {
    g_object_unref(tobject->io);
    tobject->io = NULL;
  }
}

static void
hbase_get_rows_with_columns_ts_result_class_init (HbaseGetRowsWithColumnsTsResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = hbase_get_rows_with_columns_ts_result_read;
  struct_class->write = hbase_get_rows_with_columns_ts_result_write;

  gobject_class->finalize = hbase_get_rows_with_columns_ts_result_finalize;
  gobject_class->get_property = hbase_get_rows_with_columns_ts_result_get_property;
  gobject_class->set_property = hbase_get_rows_with_columns_ts_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_GET_ROWS_WITH_COLUMNS_TS_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_GET_ROWS_WITH_COLUMNS_TS_RESULT_IO,
     g_param_spec_object ("io",
                         NULL,
                         NULL,
                         TYPE_I_O_ERROR,
                         G_PARAM_READWRITE));
}

GType
hbase_get_rows_with_columns_ts_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (HbaseGetRowsWithColumnsTsResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) hbase_get_rows_with_columns_ts_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (HbaseGetRowsWithColumnsTsResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) hbase_get_rows_with_columns_ts_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "HbaseGetRowsWithColumnsTsResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _HbaseMutateRowArgsProperties
{
  PROP_HBASE_MUTATE_ROW_ARGS_0,
  PROP_HBASE_MUTATE_ROW_ARGS_TABLE_NAME,
  PROP_HBASE_MUTATE_ROW_ARGS_ROW,
  PROP_HBASE_MUTATE_ROW_ARGS_MUTATIONS,
  PROP_HBASE_MUTATE_ROW_ARGS_ATTRIBUTES
};

/* reads a hbase_mutate_row_args object */
static gint32
hbase_mutate_row_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  HbaseMutateRowArgs * this_object = HBASE_MUTATE_ROW_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->tableName != NULL)
          {
            g_free(this_object->tableName);
            this_object->tableName = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->tableName = g_byte_array_new();
          g_byte_array_append (this_object->tableName, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_tableName = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->row != NULL)
          {
            g_free(this_object->row);
            this_object->row = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->row = g_byte_array_new();
          g_byte_array_append (this_object->row, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_row = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              Mutation * _elem106 = NULL;
              if ( _elem106 != NULL)
              {
                g_object_unref (_elem106);
              }
              _elem106 = g_object_new (TYPE_MUTATION, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem106), protocol, error)) < 0)
              {
                g_object_unref (_elem106);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->mutations, _elem106);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_mutations = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              Text key107 = NULL;
              Text val108 = NULL;
              if (key107 != NULL)
              {
                g_free(key107);
                key107 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              key107 = g_byte_array_new();
              g_byte_array_append (key107, (guint8 *) data, (guint) len);
              g_free (data);
              if (val108 != NULL)
              {
                g_free(val108);
                val108 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              val108 = g_byte_array_new();
              g_byte_array_append (val108, (guint8 *) data, (guint) len);
              g_free (data);
              if (this_object->attributes && key107)
                g_hash_table_insert ((GHashTable *)this_object->attributes, (gpointer) key107, (gpointer) val108);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_attributes = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
hbase_mutate_row_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  HbaseMutateRowArgs * this_object = HBASE_MUTATE_ROW_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "HbaseMutateRowArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "tableName", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->tableName ? ((GByteArray *) this_object->tableName)->data : NULL, this_object->tableName ? ((GByteArray *) this_object->tableName)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "row", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->row ? ((GByteArray *) this_object->row)->data : NULL, this_object->row ? ((GByteArray *) this_object->row)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "mutations", T_LIST, 3, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i109;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->mutations ? this_object->mutations->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i109 = 0; i109 < (this_object->mutations ? this_object->mutations->len : 0); i109++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->mutations, i109))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "attributes", T_MAP, 4, error)) < 0)
    return -1;
  xfer += ret;
  {
    Text key110 = NULL;
    Text val111 = NULL;
    GList *key_list = NULL, *iter = NULL;
    Text* keys;
    int i = 0, key_count;

    if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRING, this_object->attributes ? (gint32) g_hash_table_size ((GHashTable *) this_object->attributes) : 0, error)) < 0)
      return -1;
    xfer += ret;
    if (this_object->attributes)
      g_hash_table_foreach ((GHashTable *) this_object->attributes, thrift_hash_table_get_keys, &key_list);
    key_count = g_list_length (key_list);
    keys = g_newa (Text, key_count);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
      keys[i++] = (Text) iter->data;
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key110 = keys[i];
      val111 = (Text) g_hash_table_lookup (((GHashTable *) this_object->attributes), (gpointer) key110);

      if ((ret = thrift_protocol_write_binary (protocol,  key110 ? ((GByteArray *)  key110)->data : NULL,  key110 ? ((GByteArray *)  key110)->len : 0, error)) < 0)
        return -1;
      xfer += ret;

      if ((ret = thrift_protocol_write_binary (protocol,  val111 ? ((GByteArray *)  val111)->data : NULL,  val111 ? ((GByteArray *)  val111)->len : 0, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
hbase_mutate_row_args_set_property (GObject *object,
                                    guint property_id,
                                    const GValue *value,
                                    GParamSpec *pspec)
{
  HbaseMutateRowArgs *self = HBASE_MUTATE_ROW_ARGS (object);

  switch (property_id)
  {
    case PROP_HBASE_MUTATE_ROW_ARGS_TABLE_NAME:
      if (self->tableName != NULL)
        g_byte_array_unref (self->tableName);
      self->tableName = g_value_dup_boxed (value);
      self->__isset_tableName = TRUE;
      break;

    case PROP_HBASE_MUTATE_ROW_ARGS_ROW:
      if (self->row != NULL)
        g_byte_array_unref (self->row);
      self->row = g_value_dup_boxed (value);
      self->__isset_row = TRUE;
      break;

    case PROP_HBASE_MUTATE_ROW_ARGS_MUTATIONS:
      if (self->mutations != NULL)
        g_ptr_array_unref (self->mutations);
      self->mutations = g_value_dup_boxed (value);
      self->__isset_mutations = TRUE;
      break;

    case PROP_HBASE_MUTATE_ROW_ARGS_ATTRIBUTES:
      if (self->attributes != NULL)
        g_hash_table_unref (self->attributes);
      self->attributes = g_value_dup_boxed (value);
      self->__isset_attributes = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
hbase_mutate_row_args_get_property (GObject *object,
                                    guint property_id,
                                    GValue *value,
                                    GParamSpec *pspec)
{
  HbaseMutateRowArgs *self = HBASE_MUTATE_ROW_ARGS (object);

  switch (property_id)
  {
    case PROP_HBASE_MUTATE_ROW_ARGS_TABLE_NAME:
      g_value_set_boxed (value, self->tableName);
      break;

    case PROP_HBASE_MUTATE_ROW_ARGS_ROW:
      g_value_set_boxed (value, self->row);
      break;

    case PROP_HBASE_MUTATE_ROW_ARGS_MUTATIONS:
      g_value_set_boxed (value, self->mutations);
      break;

    case PROP_HBASE_MUTATE_ROW_ARGS_ATTRIBUTES:
      g_value_set_boxed (value, self->attributes);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
hbase_mutate_row_args_instance_init (HbaseMutateRowArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->tableName = NULL;
  object->__isset_tableName = FALSE;
  object->row = NULL;
  object->__isset_row = FALSE;
  object->mutations = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_mutations = FALSE;
  object->attributes = g_hash_table_new_full (g_str_hash, g_str_equal, thrift_string_free, thrift_string_free);
  object->__isset_attributes = FALSE;
}

static void 
hbase_mutate_row_args_finalize (GObject *object)
{
  HbaseMutateRowArgs *tobject = HBASE_MUTATE_ROW_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->tableName != NULL)
  {
    thrift_string_free(tobject->tableName);
    tobject->tableName = NULL;
  }
  if (tobject->row != NULL)
  {
    thrift_string_free(tobject->row);
    tobject->row = NULL;
  }
  if (tobject->mutations != NULL)
  {
    g_ptr_array_unref (tobject->mutations);
    tobject->mutations = NULL;
  }
  if (tobject->attributes != NULL)
  {
    g_hash_table_destroy (tobject->attributes);
    tobject->attributes = NULL;
  }
}

static void
hbase_mutate_row_args_class_init (HbaseMutateRowArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = hbase_mutate_row_args_read;
  struct_class->write = hbase_mutate_row_args_write;

  gobject_class->finalize = hbase_mutate_row_args_finalize;
  gobject_class->get_property = hbase_mutate_row_args_get_property;
  gobject_class->set_property = hbase_mutate_row_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_MUTATE_ROW_ARGS_TABLE_NAME,
     g_param_spec_boxed ("tableName",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_MUTATE_ROW_ARGS_ROW,
     g_param_spec_boxed ("row",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_MUTATE_ROW_ARGS_MUTATIONS,
     g_param_spec_boxed ("mutations",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_MUTATE_ROW_ARGS_ATTRIBUTES,
     g_param_spec_boxed ("attributes",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));
}

GType
hbase_mutate_row_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (HbaseMutateRowArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) hbase_mutate_row_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (HbaseMutateRowArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) hbase_mutate_row_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "HbaseMutateRowArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _HbaseMutateRowResultProperties
{
  PROP_HBASE_MUTATE_ROW_RESULT_0,
  PROP_HBASE_MUTATE_ROW_RESULT_IO,
  PROP_HBASE_MUTATE_ROW_RESULT_IA
};

/* reads a hbase_mutate_row_result object */
static gint32
hbase_mutate_row_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  HbaseMutateRowResult * this_object = HBASE_MUTATE_ROW_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->io != NULL)
          {
            g_object_unref (this_object->io);
          }
          this_object->io = g_object_new (TYPE_I_O_ERROR, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
          {
            g_object_unref (this_object->io);
            this_object->io = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_io = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ia != NULL)
          {
            g_object_unref (this_object->ia);
          }
          this_object->ia = g_object_new (TYPE_ILLEGAL_ARGUMENT, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ia), protocol, error)) < 0)
          {
            g_object_unref (this_object->ia);
            this_object->ia = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ia = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
hbase_mutate_row_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  HbaseMutateRowResult * this_object = HBASE_MUTATE_ROW_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "HbaseMutateRowResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_io == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "io", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ia == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ia", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ia), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
hbase_mutate_row_result_set_property (GObject *object,
                                      guint property_id,
                                      const GValue *value,
                                      GParamSpec *pspec)
{
  HbaseMutateRowResult *self = HBASE_MUTATE_ROW_RESULT (object);

  switch (property_id)
  {
    case PROP_HBASE_MUTATE_ROW_RESULT_IO:
      if (self->io != NULL)
        g_object_unref (self->io);
      self->io = g_value_dup_object (value);
      self->__isset_io = TRUE;
      break;

    case PROP_HBASE_MUTATE_ROW_RESULT_IA:
      if (self->ia != NULL)
        g_object_unref (self->ia);
      self->ia = g_value_dup_object (value);
      self->__isset_ia = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
hbase_mutate_row_result_get_property (GObject *object,
                                      guint property_id,
                                      GValue *value,
                                      GParamSpec *pspec)
{
  HbaseMutateRowResult *self = HBASE_MUTATE_ROW_RESULT (object);

  switch (property_id)
  {
    case PROP_HBASE_MUTATE_ROW_RESULT_IO:
      g_value_set_object (value, self->io);
      break;

    case PROP_HBASE_MUTATE_ROW_RESULT_IA:
      g_value_set_object (value, self->ia);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
hbase_mutate_row_result_instance_init (HbaseMutateRowResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->io = NULL;
  object->__isset_io = FALSE;
  object->ia = NULL;
  object->__isset_ia = FALSE;
}

static void 
hbase_mutate_row_result_finalize (GObject *object)
{
  HbaseMutateRowResult *tobject = HBASE_MUTATE_ROW_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->io != NULL)
  {
    g_object_unref(tobject->io);
    tobject->io = NULL;
  }
  if (tobject->ia != NULL)
  {
    g_object_unref(tobject->ia);
    tobject->ia = NULL;
  }
}

static void
hbase_mutate_row_result_class_init (HbaseMutateRowResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = hbase_mutate_row_result_read;
  struct_class->write = hbase_mutate_row_result_write;

  gobject_class->finalize = hbase_mutate_row_result_finalize;
  gobject_class->get_property = hbase_mutate_row_result_get_property;
  gobject_class->set_property = hbase_mutate_row_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_MUTATE_ROW_RESULT_IO,
     g_param_spec_object ("io",
                         NULL,
                         NULL,
                         TYPE_I_O_ERROR,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_MUTATE_ROW_RESULT_IA,
     g_param_spec_object ("ia",
                         NULL,
                         NULL,
                         TYPE_ILLEGAL_ARGUMENT,
                         G_PARAM_READWRITE));
}

GType
hbase_mutate_row_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (HbaseMutateRowResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) hbase_mutate_row_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (HbaseMutateRowResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) hbase_mutate_row_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "HbaseMutateRowResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _HbaseMutateRowTsArgsProperties
{
  PROP_HBASE_MUTATE_ROW_TS_ARGS_0,
  PROP_HBASE_MUTATE_ROW_TS_ARGS_TABLE_NAME,
  PROP_HBASE_MUTATE_ROW_TS_ARGS_ROW,
  PROP_HBASE_MUTATE_ROW_TS_ARGS_MUTATIONS,
  PROP_HBASE_MUTATE_ROW_TS_ARGS_TIMESTAMP,
  PROP_HBASE_MUTATE_ROW_TS_ARGS_ATTRIBUTES
};

/* reads a hbase_mutate_row_ts_args object */
static gint32
hbase_mutate_row_ts_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  HbaseMutateRowTsArgs * this_object = HBASE_MUTATE_ROW_TS_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->tableName != NULL)
          {
            g_free(this_object->tableName);
            this_object->tableName = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->tableName = g_byte_array_new();
          g_byte_array_append (this_object->tableName, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_tableName = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->row != NULL)
          {
            g_free(this_object->row);
            this_object->row = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->row = g_byte_array_new();
          g_byte_array_append (this_object->row, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_row = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              Mutation * _elem112 = NULL;
              if ( _elem112 != NULL)
              {
                g_object_unref (_elem112);
              }
              _elem112 = g_object_new (TYPE_MUTATION, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem112), protocol, error)) < 0)
              {
                g_object_unref (_elem112);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->mutations, _elem112);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_mutations = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->timestamp, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_timestamp = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              Text key113 = NULL;
              Text val114 = NULL;
              if (key113 != NULL)
              {
                g_free(key113);
                key113 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              key113 = g_byte_array_new();
              g_byte_array_append (key113, (guint8 *) data, (guint) len);
              g_free (data);
              if (val114 != NULL)
              {
                g_free(val114);
                val114 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              val114 = g_byte_array_new();
              g_byte_array_append (val114, (guint8 *) data, (guint) len);
              g_free (data);
              if (this_object->attributes && key113)
                g_hash_table_insert ((GHashTable *)this_object->attributes, (gpointer) key113, (gpointer) val114);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_attributes = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
hbase_mutate_row_ts_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  HbaseMutateRowTsArgs * this_object = HBASE_MUTATE_ROW_TS_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "HbaseMutateRowTsArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "tableName", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->tableName ? ((GByteArray *) this_object->tableName)->data : NULL, this_object->tableName ? ((GByteArray *) this_object->tableName)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "row", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->row ? ((GByteArray *) this_object->row)->data : NULL, this_object->row ? ((GByteArray *) this_object->row)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "mutations", T_LIST, 3, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i115;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->mutations ? this_object->mutations->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i115 = 0; i115 < (this_object->mutations ? this_object->mutations->len : 0); i115++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->mutations, i115))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "timestamp", T_I64, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->timestamp, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "attributes", T_MAP, 5, error)) < 0)
    return -1;
  xfer += ret;
  {
    Text key116 = NULL;
    Text val117 = NULL;
    GList *key_list = NULL, *iter = NULL;
    Text* keys;
    int i = 0, key_count;

    if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRING, this_object->attributes ? (gint32) g_hash_table_size ((GHashTable *) this_object->attributes) : 0, error)) < 0)
      return -1;
    xfer += ret;
    if (this_object->attributes)
      g_hash_table_foreach ((GHashTable *) this_object->attributes, thrift_hash_table_get_keys, &key_list);
    key_count = g_list_length (key_list);
    keys = g_newa (Text, key_count);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
      keys[i++] = (Text) iter->data;
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key116 = keys[i];
      val117 = (Text) g_hash_table_lookup (((GHashTable *) this_object->attributes), (gpointer) key116);

      if ((ret = thrift_protocol_write_binary (protocol,  key116 ? ((GByteArray *)  key116)->data : NULL,  key116 ? ((GByteArray *)  key116)->len : 0, error)) < 0)
        return -1;
      xfer += ret;

      if ((ret = thrift_protocol_write_binary (protocol,  val117 ? ((GByteArray *)  val117)->data : NULL,  val117 ? ((GByteArray *)  val117)->len : 0, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
hbase_mutate_row_ts_args_set_property (GObject *object,
                                       guint property_id,
                                       const GValue *value,
                                       GParamSpec *pspec)
{
  HbaseMutateRowTsArgs *self = HBASE_MUTATE_ROW_TS_ARGS (object);

  switch (property_id)
  {
    case PROP_HBASE_MUTATE_ROW_TS_ARGS_TABLE_NAME:
      if (self->tableName != NULL)
        g_byte_array_unref (self->tableName);
      self->tableName = g_value_dup_boxed (value);
      self->__isset_tableName = TRUE;
      break;

    case PROP_HBASE_MUTATE_ROW_TS_ARGS_ROW:
      if (self->row != NULL)
        g_byte_array_unref (self->row);
      self->row = g_value_dup_boxed (value);
      self->__isset_row = TRUE;
      break;

    case PROP_HBASE_MUTATE_ROW_TS_ARGS_MUTATIONS:
      if (self->mutations != NULL)
        g_ptr_array_unref (self->mutations);
      self->mutations = g_value_dup_boxed (value);
      self->__isset_mutations = TRUE;
      break;

    case PROP_HBASE_MUTATE_ROW_TS_ARGS_TIMESTAMP:
      self->timestamp = g_value_get_int64 (value);
      self->__isset_timestamp = TRUE;
      break;

    case PROP_HBASE_MUTATE_ROW_TS_ARGS_ATTRIBUTES:
      if (self->attributes != NULL)
        g_hash_table_unref (self->attributes);
      self->attributes = g_value_dup_boxed (value);
      self->__isset_attributes = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
hbase_mutate_row_ts_args_get_property (GObject *object,
                                       guint property_id,
                                       GValue *value,
                                       GParamSpec *pspec)
{
  HbaseMutateRowTsArgs *self = HBASE_MUTATE_ROW_TS_ARGS (object);

  switch (property_id)
  {
    case PROP_HBASE_MUTATE_ROW_TS_ARGS_TABLE_NAME:
      g_value_set_boxed (value, self->tableName);
      break;

    case PROP_HBASE_MUTATE_ROW_TS_ARGS_ROW:
      g_value_set_boxed (value, self->row);
      break;

    case PROP_HBASE_MUTATE_ROW_TS_ARGS_MUTATIONS:
      g_value_set_boxed (value, self->mutations);
      break;

    case PROP_HBASE_MUTATE_ROW_TS_ARGS_TIMESTAMP:
      g_value_set_int64 (value, self->timestamp);
      break;

    case PROP_HBASE_MUTATE_ROW_TS_ARGS_ATTRIBUTES:
      g_value_set_boxed (value, self->attributes);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
hbase_mutate_row_ts_args_instance_init (HbaseMutateRowTsArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->tableName = NULL;
  object->__isset_tableName = FALSE;
  object->row = NULL;
  object->__isset_row = FALSE;
  object->mutations = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_mutations = FALSE;
  object->timestamp = 0;
  object->__isset_timestamp = FALSE;
  object->attributes = g_hash_table_new_full (g_str_hash, g_str_equal, thrift_string_free, thrift_string_free);
  object->__isset_attributes = FALSE;
}

static void 
hbase_mutate_row_ts_args_finalize (GObject *object)
{
  HbaseMutateRowTsArgs *tobject = HBASE_MUTATE_ROW_TS_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->tableName != NULL)
  {
    thrift_string_free(tobject->tableName);
    tobject->tableName = NULL;
  }
  if (tobject->row != NULL)
  {
    thrift_string_free(tobject->row);
    tobject->row = NULL;
  }
  if (tobject->mutations != NULL)
  {
    g_ptr_array_unref (tobject->mutations);
    tobject->mutations = NULL;
  }
  if (tobject->attributes != NULL)
  {
    g_hash_table_destroy (tobject->attributes);
    tobject->attributes = NULL;
  }
}

static void
hbase_mutate_row_ts_args_class_init (HbaseMutateRowTsArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = hbase_mutate_row_ts_args_read;
  struct_class->write = hbase_mutate_row_ts_args_write;

  gobject_class->finalize = hbase_mutate_row_ts_args_finalize;
  gobject_class->get_property = hbase_mutate_row_ts_args_get_property;
  gobject_class->set_property = hbase_mutate_row_ts_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_MUTATE_ROW_TS_ARGS_TABLE_NAME,
     g_param_spec_boxed ("tableName",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_MUTATE_ROW_TS_ARGS_ROW,
     g_param_spec_boxed ("row",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_MUTATE_ROW_TS_ARGS_MUTATIONS,
     g_param_spec_boxed ("mutations",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_MUTATE_ROW_TS_ARGS_TIMESTAMP,
     g_param_spec_int64 ("timestamp",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_MUTATE_ROW_TS_ARGS_ATTRIBUTES,
     g_param_spec_boxed ("attributes",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));
}

GType
hbase_mutate_row_ts_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (HbaseMutateRowTsArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) hbase_mutate_row_ts_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (HbaseMutateRowTsArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) hbase_mutate_row_ts_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "HbaseMutateRowTsArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _HbaseMutateRowTsResultProperties
{
  PROP_HBASE_MUTATE_ROW_TS_RESULT_0,
  PROP_HBASE_MUTATE_ROW_TS_RESULT_IO,
  PROP_HBASE_MUTATE_ROW_TS_RESULT_IA
};

/* reads a hbase_mutate_row_ts_result object */
static gint32
hbase_mutate_row_ts_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  HbaseMutateRowTsResult * this_object = HBASE_MUTATE_ROW_TS_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->io != NULL)
          {
            g_object_unref (this_object->io);
          }
          this_object->io = g_object_new (TYPE_I_O_ERROR, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
          {
            g_object_unref (this_object->io);
            this_object->io = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_io = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ia != NULL)
          {
            g_object_unref (this_object->ia);
          }
          this_object->ia = g_object_new (TYPE_ILLEGAL_ARGUMENT, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ia), protocol, error)) < 0)
          {
            g_object_unref (this_object->ia);
            this_object->ia = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ia = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
hbase_mutate_row_ts_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  HbaseMutateRowTsResult * this_object = HBASE_MUTATE_ROW_TS_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "HbaseMutateRowTsResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_io == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "io", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ia == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ia", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ia), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
hbase_mutate_row_ts_result_set_property (GObject *object,
                                         guint property_id,
                                         const GValue *value,
                                         GParamSpec *pspec)
{
  HbaseMutateRowTsResult *self = HBASE_MUTATE_ROW_TS_RESULT (object);

  switch (property_id)
  {
    case PROP_HBASE_MUTATE_ROW_TS_RESULT_IO:
      if (self->io != NULL)
        g_object_unref (self->io);
      self->io = g_value_dup_object (value);
      self->__isset_io = TRUE;
      break;

    case PROP_HBASE_MUTATE_ROW_TS_RESULT_IA:
      if (self->ia != NULL)
        g_object_unref (self->ia);
      self->ia = g_value_dup_object (value);
      self->__isset_ia = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
hbase_mutate_row_ts_result_get_property (GObject *object,
                                         guint property_id,
                                         GValue *value,
                                         GParamSpec *pspec)
{
  HbaseMutateRowTsResult *self = HBASE_MUTATE_ROW_TS_RESULT (object);

  switch (property_id)
  {
    case PROP_HBASE_MUTATE_ROW_TS_RESULT_IO:
      g_value_set_object (value, self->io);
      break;

    case PROP_HBASE_MUTATE_ROW_TS_RESULT_IA:
      g_value_set_object (value, self->ia);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
hbase_mutate_row_ts_result_instance_init (HbaseMutateRowTsResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->io = NULL;
  object->__isset_io = FALSE;
  object->ia = NULL;
  object->__isset_ia = FALSE;
}

static void 
hbase_mutate_row_ts_result_finalize (GObject *object)
{
  HbaseMutateRowTsResult *tobject = HBASE_MUTATE_ROW_TS_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->io != NULL)
  {
    g_object_unref(tobject->io);
    tobject->io = NULL;
  }
  if (tobject->ia != NULL)
  {
    g_object_unref(tobject->ia);
    tobject->ia = NULL;
  }
}

static void
hbase_mutate_row_ts_result_class_init (HbaseMutateRowTsResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = hbase_mutate_row_ts_result_read;
  struct_class->write = hbase_mutate_row_ts_result_write;

  gobject_class->finalize = hbase_mutate_row_ts_result_finalize;
  gobject_class->get_property = hbase_mutate_row_ts_result_get_property;
  gobject_class->set_property = hbase_mutate_row_ts_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_MUTATE_ROW_TS_RESULT_IO,
     g_param_spec_object ("io",
                         NULL,
                         NULL,
                         TYPE_I_O_ERROR,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_MUTATE_ROW_TS_RESULT_IA,
     g_param_spec_object ("ia",
                         NULL,
                         NULL,
                         TYPE_ILLEGAL_ARGUMENT,
                         G_PARAM_READWRITE));
}

GType
hbase_mutate_row_ts_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (HbaseMutateRowTsResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) hbase_mutate_row_ts_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (HbaseMutateRowTsResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) hbase_mutate_row_ts_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "HbaseMutateRowTsResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _HbaseMutateRowsArgsProperties
{
  PROP_HBASE_MUTATE_ROWS_ARGS_0,
  PROP_HBASE_MUTATE_ROWS_ARGS_TABLE_NAME,
  PROP_HBASE_MUTATE_ROWS_ARGS_ROW_BATCHES,
  PROP_HBASE_MUTATE_ROWS_ARGS_ATTRIBUTES
};

/* reads a hbase_mutate_rows_args object */
static gint32
hbase_mutate_rows_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  HbaseMutateRowsArgs * this_object = HBASE_MUTATE_ROWS_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->tableName != NULL)
          {
            g_free(this_object->tableName);
            this_object->tableName = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->tableName = g_byte_array_new();
          g_byte_array_append (this_object->tableName, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_tableName = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              BatchMutation * _elem118 = NULL;
              if ( _elem118 != NULL)
              {
                g_object_unref (_elem118);
              }
              _elem118 = g_object_new (TYPE_BATCH_MUTATION, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem118), protocol, error)) < 0)
              {
                g_object_unref (_elem118);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->rowBatches, _elem118);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_rowBatches = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              Text key119 = NULL;
              Text val120 = NULL;
              if (key119 != NULL)
              {
                g_free(key119);
                key119 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              key119 = g_byte_array_new();
              g_byte_array_append (key119, (guint8 *) data, (guint) len);
              g_free (data);
              if (val120 != NULL)
              {
                g_free(val120);
                val120 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              val120 = g_byte_array_new();
              g_byte_array_append (val120, (guint8 *) data, (guint) len);
              g_free (data);
              if (this_object->attributes && key119)
                g_hash_table_insert ((GHashTable *)this_object->attributes, (gpointer) key119, (gpointer) val120);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_attributes = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
hbase_mutate_rows_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  HbaseMutateRowsArgs * this_object = HBASE_MUTATE_ROWS_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "HbaseMutateRowsArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "tableName", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->tableName ? ((GByteArray *) this_object->tableName)->data : NULL, this_object->tableName ? ((GByteArray *) this_object->tableName)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "rowBatches", T_LIST, 2, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i121;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->rowBatches ? this_object->rowBatches->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i121 = 0; i121 < (this_object->rowBatches ? this_object->rowBatches->len : 0); i121++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->rowBatches, i121))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "attributes", T_MAP, 3, error)) < 0)
    return -1;
  xfer += ret;
  {
    Text key122 = NULL;
    Text val123 = NULL;
    GList *key_list = NULL, *iter = NULL;
    Text* keys;
    int i = 0, key_count;

    if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRING, this_object->attributes ? (gint32) g_hash_table_size ((GHashTable *) this_object->attributes) : 0, error)) < 0)
      return -1;
    xfer += ret;
    if (this_object->attributes)
      g_hash_table_foreach ((GHashTable *) this_object->attributes, thrift_hash_table_get_keys, &key_list);
    key_count = g_list_length (key_list);
    keys = g_newa (Text, key_count);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
      keys[i++] = (Text) iter->data;
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key122 = keys[i];
      val123 = (Text) g_hash_table_lookup (((GHashTable *) this_object->attributes), (gpointer) key122);

      if ((ret = thrift_protocol_write_binary (protocol,  key122 ? ((GByteArray *)  key122)->data : NULL,  key122 ? ((GByteArray *)  key122)->len : 0, error)) < 0)
        return -1;
      xfer += ret;

      if ((ret = thrift_protocol_write_binary (protocol,  val123 ? ((GByteArray *)  val123)->data : NULL,  val123 ? ((GByteArray *)  val123)->len : 0, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
hbase_mutate_rows_args_set_property (GObject *object,
                                     guint property_id,
                                     const GValue *value,
                                     GParamSpec *pspec)
{
  HbaseMutateRowsArgs *self = HBASE_MUTATE_ROWS_ARGS (object);

  switch (property_id)
  {
    case PROP_HBASE_MUTATE_ROWS_ARGS_TABLE_NAME:
      if (self->tableName != NULL)
        g_byte_array_unref (self->tableName);
      self->tableName = g_value_dup_boxed (value);
      self->__isset_tableName = TRUE;
      break;

    case PROP_HBASE_MUTATE_ROWS_ARGS_ROW_BATCHES:
      if (self->rowBatches != NULL)
        g_ptr_array_unref (self->rowBatches);
      self->rowBatches = g_value_dup_boxed (value);
      self->__isset_rowBatches = TRUE;
      break;

    case PROP_HBASE_MUTATE_ROWS_ARGS_ATTRIBUTES:
      if (self->attributes != NULL)
        g_hash_table_unref (self->attributes);
      self->attributes = g_value_dup_boxed (value);
      self->__isset_attributes = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
hbase_mutate_rows_args_get_property (GObject *object,
                                     guint property_id,
                                     GValue *value,
                                     GParamSpec *pspec)
{
  HbaseMutateRowsArgs *self = HBASE_MUTATE_ROWS_ARGS (object);

  switch (property_id)
  {
    case PROP_HBASE_MUTATE_ROWS_ARGS_TABLE_NAME:
      g_value_set_boxed (value, self->tableName);
      break;

    case PROP_HBASE_MUTATE_ROWS_ARGS_ROW_BATCHES:
      g_value_set_boxed (value, self->rowBatches);
      break;

    case PROP_HBASE_MUTATE_ROWS_ARGS_ATTRIBUTES:
      g_value_set_boxed (value, self->attributes);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
hbase_mutate_rows_args_instance_init (HbaseMutateRowsArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->tableName = NULL;
  object->__isset_tableName = FALSE;
  object->rowBatches = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_rowBatches = FALSE;
  object->attributes = g_hash_table_new_full (g_str_hash, g_str_equal, thrift_string_free, thrift_string_free);
  object->__isset_attributes = FALSE;
}

static void 
hbase_mutate_rows_args_finalize (GObject *object)
{
  HbaseMutateRowsArgs *tobject = HBASE_MUTATE_ROWS_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->tableName != NULL)
  {
    thrift_string_free(tobject->tableName);
    tobject->tableName = NULL;
  }
  if (tobject->rowBatches != NULL)
  {
    g_ptr_array_unref (tobject->rowBatches);
    tobject->rowBatches = NULL;
  }
  if (tobject->attributes != NULL)
  {
    g_hash_table_destroy (tobject->attributes);
    tobject->attributes = NULL;
  }
}

static void
hbase_mutate_rows_args_class_init (HbaseMutateRowsArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = hbase_mutate_rows_args_read;
  struct_class->write = hbase_mutate_rows_args_write;

  gobject_class->finalize = hbase_mutate_rows_args_finalize;
  gobject_class->get_property = hbase_mutate_rows_args_get_property;
  gobject_class->set_property = hbase_mutate_rows_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_MUTATE_ROWS_ARGS_TABLE_NAME,
     g_param_spec_boxed ("tableName",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_MUTATE_ROWS_ARGS_ROW_BATCHES,
     g_param_spec_boxed ("rowBatches",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_MUTATE_ROWS_ARGS_ATTRIBUTES,
     g_param_spec_boxed ("attributes",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));
}

GType
hbase_mutate_rows_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (HbaseMutateRowsArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) hbase_mutate_rows_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (HbaseMutateRowsArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) hbase_mutate_rows_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "HbaseMutateRowsArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _HbaseMutateRowsResultProperties
{
  PROP_HBASE_MUTATE_ROWS_RESULT_0,
  PROP_HBASE_MUTATE_ROWS_RESULT_IO,
  PROP_HBASE_MUTATE_ROWS_RESULT_IA
};

/* reads a hbase_mutate_rows_result object */
static gint32
hbase_mutate_rows_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  HbaseMutateRowsResult * this_object = HBASE_MUTATE_ROWS_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->io != NULL)
          {
            g_object_unref (this_object->io);
          }
          this_object->io = g_object_new (TYPE_I_O_ERROR, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
          {
            g_object_unref (this_object->io);
            this_object->io = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_io = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ia != NULL)
          {
            g_object_unref (this_object->ia);
          }
          this_object->ia = g_object_new (TYPE_ILLEGAL_ARGUMENT, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ia), protocol, error)) < 0)
          {
            g_object_unref (this_object->ia);
            this_object->ia = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ia = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
hbase_mutate_rows_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  HbaseMutateRowsResult * this_object = HBASE_MUTATE_ROWS_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "HbaseMutateRowsResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_io == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "io", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ia == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ia", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ia), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
hbase_mutate_rows_result_set_property (GObject *object,
                                       guint property_id,
                                       const GValue *value,
                                       GParamSpec *pspec)
{
  HbaseMutateRowsResult *self = HBASE_MUTATE_ROWS_RESULT (object);

  switch (property_id)
  {
    case PROP_HBASE_MUTATE_ROWS_RESULT_IO:
      if (self->io != NULL)
        g_object_unref (self->io);
      self->io = g_value_dup_object (value);
      self->__isset_io = TRUE;
      break;

    case PROP_HBASE_MUTATE_ROWS_RESULT_IA:
      if (self->ia != NULL)
        g_object_unref (self->ia);
      self->ia = g_value_dup_object (value);
      self->__isset_ia = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
hbase_mutate_rows_result_get_property (GObject *object,
                                       guint property_id,
                                       GValue *value,
                                       GParamSpec *pspec)
{
  HbaseMutateRowsResult *self = HBASE_MUTATE_ROWS_RESULT (object);

  switch (property_id)
  {
    case PROP_HBASE_MUTATE_ROWS_RESULT_IO:
      g_value_set_object (value, self->io);
      break;

    case PROP_HBASE_MUTATE_ROWS_RESULT_IA:
      g_value_set_object (value, self->ia);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
hbase_mutate_rows_result_instance_init (HbaseMutateRowsResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->io = NULL;
  object->__isset_io = FALSE;
  object->ia = NULL;
  object->__isset_ia = FALSE;
}

static void 
hbase_mutate_rows_result_finalize (GObject *object)
{
  HbaseMutateRowsResult *tobject = HBASE_MUTATE_ROWS_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->io != NULL)
  {
    g_object_unref(tobject->io);
    tobject->io = NULL;
  }
  if (tobject->ia != NULL)
  {
    g_object_unref(tobject->ia);
    tobject->ia = NULL;
  }
}

static void
hbase_mutate_rows_result_class_init (HbaseMutateRowsResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = hbase_mutate_rows_result_read;
  struct_class->write = hbase_mutate_rows_result_write;

  gobject_class->finalize = hbase_mutate_rows_result_finalize;
  gobject_class->get_property = hbase_mutate_rows_result_get_property;
  gobject_class->set_property = hbase_mutate_rows_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_MUTATE_ROWS_RESULT_IO,
     g_param_spec_object ("io",
                         NULL,
                         NULL,
                         TYPE_I_O_ERROR,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_MUTATE_ROWS_RESULT_IA,
     g_param_spec_object ("ia",
                         NULL,
                         NULL,
                         TYPE_ILLEGAL_ARGUMENT,
                         G_PARAM_READWRITE));
}

GType
hbase_mutate_rows_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (HbaseMutateRowsResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) hbase_mutate_rows_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (HbaseMutateRowsResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) hbase_mutate_rows_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "HbaseMutateRowsResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _HbaseMutateRowsTsArgsProperties
{
  PROP_HBASE_MUTATE_ROWS_TS_ARGS_0,
  PROP_HBASE_MUTATE_ROWS_TS_ARGS_TABLE_NAME,
  PROP_HBASE_MUTATE_ROWS_TS_ARGS_ROW_BATCHES,
  PROP_HBASE_MUTATE_ROWS_TS_ARGS_TIMESTAMP,
  PROP_HBASE_MUTATE_ROWS_TS_ARGS_ATTRIBUTES
};

/* reads a hbase_mutate_rows_ts_args object */
static gint32
hbase_mutate_rows_ts_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  HbaseMutateRowsTsArgs * this_object = HBASE_MUTATE_ROWS_TS_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->tableName != NULL)
          {
            g_free(this_object->tableName);
            this_object->tableName = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->tableName = g_byte_array_new();
          g_byte_array_append (this_object->tableName, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_tableName = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              BatchMutation * _elem124 = NULL;
              if ( _elem124 != NULL)
              {
                g_object_unref (_elem124);
              }
              _elem124 = g_object_new (TYPE_BATCH_MUTATION, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem124), protocol, error)) < 0)
              {
                g_object_unref (_elem124);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->rowBatches, _elem124);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_rowBatches = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->timestamp, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_timestamp = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              Text key125 = NULL;
              Text val126 = NULL;
              if (key125 != NULL)
              {
                g_free(key125);
                key125 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              key125 = g_byte_array_new();
              g_byte_array_append (key125, (guint8 *) data, (guint) len);
              g_free (data);
              if (val126 != NULL)
              {
                g_free(val126);
                val126 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              val126 = g_byte_array_new();
              g_byte_array_append (val126, (guint8 *) data, (guint) len);
              g_free (data);
              if (this_object->attributes && key125)
                g_hash_table_insert ((GHashTable *)this_object->attributes, (gpointer) key125, (gpointer) val126);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_attributes = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
hbase_mutate_rows_ts_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  HbaseMutateRowsTsArgs * this_object = HBASE_MUTATE_ROWS_TS_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "HbaseMutateRowsTsArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "tableName", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->tableName ? ((GByteArray *) this_object->tableName)->data : NULL, this_object->tableName ? ((GByteArray *) this_object->tableName)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "rowBatches", T_LIST, 2, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i127;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->rowBatches ? this_object->rowBatches->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i127 = 0; i127 < (this_object->rowBatches ? this_object->rowBatches->len : 0); i127++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->rowBatches, i127))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "timestamp", T_I64, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->timestamp, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "attributes", T_MAP, 4, error)) < 0)
    return -1;
  xfer += ret;
  {
    Text key128 = NULL;
    Text val129 = NULL;
    GList *key_list = NULL, *iter = NULL;
    Text* keys;
    int i = 0, key_count;

    if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRING, this_object->attributes ? (gint32) g_hash_table_size ((GHashTable *) this_object->attributes) : 0, error)) < 0)
      return -1;
    xfer += ret;
    if (this_object->attributes)
      g_hash_table_foreach ((GHashTable *) this_object->attributes, thrift_hash_table_get_keys, &key_list);
    key_count = g_list_length (key_list);
    keys = g_newa (Text, key_count);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
      keys[i++] = (Text) iter->data;
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key128 = keys[i];
      val129 = (Text) g_hash_table_lookup (((GHashTable *) this_object->attributes), (gpointer) key128);

      if ((ret = thrift_protocol_write_binary (protocol,  key128 ? ((GByteArray *)  key128)->data : NULL,  key128 ? ((GByteArray *)  key128)->len : 0, error)) < 0)
        return -1;
      xfer += ret;

      if ((ret = thrift_protocol_write_binary (protocol,  val129 ? ((GByteArray *)  val129)->data : NULL,  val129 ? ((GByteArray *)  val129)->len : 0, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
hbase_mutate_rows_ts_args_set_property (GObject *object,
                                        guint property_id,
                                        const GValue *value,
                                        GParamSpec *pspec)
{
  HbaseMutateRowsTsArgs *self = HBASE_MUTATE_ROWS_TS_ARGS (object);

  switch (property_id)
  {
    case PROP_HBASE_MUTATE_ROWS_TS_ARGS_TABLE_NAME:
      if (self->tableName != NULL)
        g_byte_array_unref (self->tableName);
      self->tableName = g_value_dup_boxed (value);
      self->__isset_tableName = TRUE;
      break;

    case PROP_HBASE_MUTATE_ROWS_TS_ARGS_ROW_BATCHES:
      if (self->rowBatches != NULL)
        g_ptr_array_unref (self->rowBatches);
      self->rowBatches = g_value_dup_boxed (value);
      self->__isset_rowBatches = TRUE;
      break;

    case PROP_HBASE_MUTATE_ROWS_TS_ARGS_TIMESTAMP:
      self->timestamp = g_value_get_int64 (value);
      self->__isset_timestamp = TRUE;
      break;

    case PROP_HBASE_MUTATE_ROWS_TS_ARGS_ATTRIBUTES:
      if (self->attributes != NULL)
        g_hash_table_unref (self->attributes);
      self->attributes = g_value_dup_boxed (value);
      self->__isset_attributes = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
hbase_mutate_rows_ts_args_get_property (GObject *object,
                                        guint property_id,
                                        GValue *value,
                                        GParamSpec *pspec)
{
  HbaseMutateRowsTsArgs *self = HBASE_MUTATE_ROWS_TS_ARGS (object);

  switch (property_id)
  {
    case PROP_HBASE_MUTATE_ROWS_TS_ARGS_TABLE_NAME:
      g_value_set_boxed (value, self->tableName);
      break;

    case PROP_HBASE_MUTATE_ROWS_TS_ARGS_ROW_BATCHES:
      g_value_set_boxed (value, self->rowBatches);
      break;

    case PROP_HBASE_MUTATE_ROWS_TS_ARGS_TIMESTAMP:
      g_value_set_int64 (value, self->timestamp);
      break;

    case PROP_HBASE_MUTATE_ROWS_TS_ARGS_ATTRIBUTES:
      g_value_set_boxed (value, self->attributes);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
hbase_mutate_rows_ts_args_instance_init (HbaseMutateRowsTsArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->tableName = NULL;
  object->__isset_tableName = FALSE;
  object->rowBatches = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_rowBatches = FALSE;
  object->timestamp = 0;
  object->__isset_timestamp = FALSE;
  object->attributes = g_hash_table_new_full (g_str_hash, g_str_equal, thrift_string_free, thrift_string_free);
  object->__isset_attributes = FALSE;
}

static void 
hbase_mutate_rows_ts_args_finalize (GObject *object)
{
  HbaseMutateRowsTsArgs *tobject = HBASE_MUTATE_ROWS_TS_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->tableName != NULL)
  {
    thrift_string_free(tobject->tableName);
    tobject->tableName = NULL;
  }
  if (tobject->rowBatches != NULL)
  {
    g_ptr_array_unref (tobject->rowBatches);
    tobject->rowBatches = NULL;
  }
  if (tobject->attributes != NULL)
  {
    g_hash_table_destroy (tobject->attributes);
    tobject->attributes = NULL;
  }
}

static void
hbase_mutate_rows_ts_args_class_init (HbaseMutateRowsTsArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = hbase_mutate_rows_ts_args_read;
  struct_class->write = hbase_mutate_rows_ts_args_write;

  gobject_class->finalize = hbase_mutate_rows_ts_args_finalize;
  gobject_class->get_property = hbase_mutate_rows_ts_args_get_property;
  gobject_class->set_property = hbase_mutate_rows_ts_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_MUTATE_ROWS_TS_ARGS_TABLE_NAME,
     g_param_spec_boxed ("tableName",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_MUTATE_ROWS_TS_ARGS_ROW_BATCHES,
     g_param_spec_boxed ("rowBatches",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_MUTATE_ROWS_TS_ARGS_TIMESTAMP,
     g_param_spec_int64 ("timestamp",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_MUTATE_ROWS_TS_ARGS_ATTRIBUTES,
     g_param_spec_boxed ("attributes",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));
}

GType
hbase_mutate_rows_ts_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (HbaseMutateRowsTsArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) hbase_mutate_rows_ts_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (HbaseMutateRowsTsArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) hbase_mutate_rows_ts_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "HbaseMutateRowsTsArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _HbaseMutateRowsTsResultProperties
{
  PROP_HBASE_MUTATE_ROWS_TS_RESULT_0,
  PROP_HBASE_MUTATE_ROWS_TS_RESULT_IO,
  PROP_HBASE_MUTATE_ROWS_TS_RESULT_IA
};

/* reads a hbase_mutate_rows_ts_result object */
static gint32
hbase_mutate_rows_ts_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  HbaseMutateRowsTsResult * this_object = HBASE_MUTATE_ROWS_TS_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->io != NULL)
          {
            g_object_unref (this_object->io);
          }
          this_object->io = g_object_new (TYPE_I_O_ERROR, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
          {
            g_object_unref (this_object->io);
            this_object->io = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_io = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ia != NULL)
          {
            g_object_unref (this_object->ia);
          }
          this_object->ia = g_object_new (TYPE_ILLEGAL_ARGUMENT, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ia), protocol, error)) < 0)
          {
            g_object_unref (this_object->ia);
            this_object->ia = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ia = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
hbase_mutate_rows_ts_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  HbaseMutateRowsTsResult * this_object = HBASE_MUTATE_ROWS_TS_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "HbaseMutateRowsTsResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_io == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "io", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ia == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ia", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ia), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
hbase_mutate_rows_ts_result_set_property (GObject *object,
                                          guint property_id,
                                          const GValue *value,
                                          GParamSpec *pspec)
{
  HbaseMutateRowsTsResult *self = HBASE_MUTATE_ROWS_TS_RESULT (object);

  switch (property_id)
  {
    case PROP_HBASE_MUTATE_ROWS_TS_RESULT_IO:
      if (self->io != NULL)
        g_object_unref (self->io);
      self->io = g_value_dup_object (value);
      self->__isset_io = TRUE;
      break;

    case PROP_HBASE_MUTATE_ROWS_TS_RESULT_IA:
      if (self->ia != NULL)
        g_object_unref (self->ia);
      self->ia = g_value_dup_object (value);
      self->__isset_ia = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
hbase_mutate_rows_ts_result_get_property (GObject *object,
                                          guint property_id,
                                          GValue *value,
                                          GParamSpec *pspec)
{
  HbaseMutateRowsTsResult *self = HBASE_MUTATE_ROWS_TS_RESULT (object);

  switch (property_id)
  {
    case PROP_HBASE_MUTATE_ROWS_TS_RESULT_IO:
      g_value_set_object (value, self->io);
      break;

    case PROP_HBASE_MUTATE_ROWS_TS_RESULT_IA:
      g_value_set_object (value, self->ia);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
hbase_mutate_rows_ts_result_instance_init (HbaseMutateRowsTsResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->io = NULL;
  object->__isset_io = FALSE;
  object->ia = NULL;
  object->__isset_ia = FALSE;
}

static void 
hbase_mutate_rows_ts_result_finalize (GObject *object)
{
  HbaseMutateRowsTsResult *tobject = HBASE_MUTATE_ROWS_TS_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->io != NULL)
  {
    g_object_unref(tobject->io);
    tobject->io = NULL;
  }
  if (tobject->ia != NULL)
  {
    g_object_unref(tobject->ia);
    tobject->ia = NULL;
  }
}

static void
hbase_mutate_rows_ts_result_class_init (HbaseMutateRowsTsResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = hbase_mutate_rows_ts_result_read;
  struct_class->write = hbase_mutate_rows_ts_result_write;

  gobject_class->finalize = hbase_mutate_rows_ts_result_finalize;
  gobject_class->get_property = hbase_mutate_rows_ts_result_get_property;
  gobject_class->set_property = hbase_mutate_rows_ts_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_MUTATE_ROWS_TS_RESULT_IO,
     g_param_spec_object ("io",
                         NULL,
                         NULL,
                         TYPE_I_O_ERROR,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_MUTATE_ROWS_TS_RESULT_IA,
     g_param_spec_object ("ia",
                         NULL,
                         NULL,
                         TYPE_ILLEGAL_ARGUMENT,
                         G_PARAM_READWRITE));
}

GType
hbase_mutate_rows_ts_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (HbaseMutateRowsTsResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) hbase_mutate_rows_ts_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (HbaseMutateRowsTsResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) hbase_mutate_rows_ts_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "HbaseMutateRowsTsResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _HbaseAtomicIncrementArgsProperties
{
  PROP_HBASE_ATOMIC_INCREMENT_ARGS_0,
  PROP_HBASE_ATOMIC_INCREMENT_ARGS_TABLE_NAME,
  PROP_HBASE_ATOMIC_INCREMENT_ARGS_ROW,
  PROP_HBASE_ATOMIC_INCREMENT_ARGS_COLUMN,
  PROP_HBASE_ATOMIC_INCREMENT_ARGS_VALUE
};

/* reads a hbase_atomic_increment_args object */
static gint32
hbase_atomic_increment_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  HbaseAtomicIncrementArgs * this_object = HBASE_ATOMIC_INCREMENT_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->tableName != NULL)
          {
            g_free(this_object->tableName);
            this_object->tableName = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->tableName = g_byte_array_new();
          g_byte_array_append (this_object->tableName, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_tableName = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->row != NULL)
          {
            g_free(this_object->row);
            this_object->row = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->row = g_byte_array_new();
          g_byte_array_append (this_object->row, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_row = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if (this_object->column != NULL)
          {
            g_free(this_object->column);
            this_object->column = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->column = g_byte_array_new();
          g_byte_array_append (this_object->column, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_column = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->value, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_value = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
hbase_atomic_increment_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  HbaseAtomicIncrementArgs * this_object = HBASE_ATOMIC_INCREMENT_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "HbaseAtomicIncrementArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "tableName", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->tableName ? ((GByteArray *) this_object->tableName)->data : NULL, this_object->tableName ? ((GByteArray *) this_object->tableName)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "row", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->row ? ((GByteArray *) this_object->row)->data : NULL, this_object->row ? ((GByteArray *) this_object->row)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "column", T_STRING, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->column ? ((GByteArray *) this_object->column)->data : NULL, this_object->column ? ((GByteArray *) this_object->column)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "value", T_I64, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->value, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
hbase_atomic_increment_args_set_property (GObject *object,
                                          guint property_id,
                                          const GValue *value,
                                          GParamSpec *pspec)
{
  HbaseAtomicIncrementArgs *self = HBASE_ATOMIC_INCREMENT_ARGS (object);

  switch (property_id)
  {
    case PROP_HBASE_ATOMIC_INCREMENT_ARGS_TABLE_NAME:
      if (self->tableName != NULL)
        g_byte_array_unref (self->tableName);
      self->tableName = g_value_dup_boxed (value);
      self->__isset_tableName = TRUE;
      break;

    case PROP_HBASE_ATOMIC_INCREMENT_ARGS_ROW:
      if (self->row != NULL)
        g_byte_array_unref (self->row);
      self->row = g_value_dup_boxed (value);
      self->__isset_row = TRUE;
      break;

    case PROP_HBASE_ATOMIC_INCREMENT_ARGS_COLUMN:
      if (self->column != NULL)
        g_byte_array_unref (self->column);
      self->column = g_value_dup_boxed (value);
      self->__isset_column = TRUE;
      break;

    case PROP_HBASE_ATOMIC_INCREMENT_ARGS_VALUE:
      self->value = g_value_get_int64 (value);
      self->__isset_value = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
hbase_atomic_increment_args_get_property (GObject *object,
                                          guint property_id,
                                          GValue *value,
                                          GParamSpec *pspec)
{
  HbaseAtomicIncrementArgs *self = HBASE_ATOMIC_INCREMENT_ARGS (object);

  switch (property_id)
  {
    case PROP_HBASE_ATOMIC_INCREMENT_ARGS_TABLE_NAME:
      g_value_set_boxed (value, self->tableName);
      break;

    case PROP_HBASE_ATOMIC_INCREMENT_ARGS_ROW:
      g_value_set_boxed (value, self->row);
      break;

    case PROP_HBASE_ATOMIC_INCREMENT_ARGS_COLUMN:
      g_value_set_boxed (value, self->column);
      break;

    case PROP_HBASE_ATOMIC_INCREMENT_ARGS_VALUE:
      g_value_set_int64 (value, self->value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
hbase_atomic_increment_args_instance_init (HbaseAtomicIncrementArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->tableName = NULL;
  object->__isset_tableName = FALSE;
  object->row = NULL;
  object->__isset_row = FALSE;
  object->column = NULL;
  object->__isset_column = FALSE;
  object->value = 0;
  object->__isset_value = FALSE;
}

static void 
hbase_atomic_increment_args_finalize (GObject *object)
{
  HbaseAtomicIncrementArgs *tobject = HBASE_ATOMIC_INCREMENT_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->tableName != NULL)
  {
    thrift_string_free(tobject->tableName);
    tobject->tableName = NULL;
  }
  if (tobject->row != NULL)
  {
    thrift_string_free(tobject->row);
    tobject->row = NULL;
  }
  if (tobject->column != NULL)
  {
    thrift_string_free(tobject->column);
    tobject->column = NULL;
  }
}

static void
hbase_atomic_increment_args_class_init (HbaseAtomicIncrementArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = hbase_atomic_increment_args_read;
  struct_class->write = hbase_atomic_increment_args_write;

  gobject_class->finalize = hbase_atomic_increment_args_finalize;
  gobject_class->get_property = hbase_atomic_increment_args_get_property;
  gobject_class->set_property = hbase_atomic_increment_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_ATOMIC_INCREMENT_ARGS_TABLE_NAME,
     g_param_spec_boxed ("tableName",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_ATOMIC_INCREMENT_ARGS_ROW,
     g_param_spec_boxed ("row",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_ATOMIC_INCREMENT_ARGS_COLUMN,
     g_param_spec_boxed ("column",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_ATOMIC_INCREMENT_ARGS_VALUE,
     g_param_spec_int64 ("value",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));
}

GType
hbase_atomic_increment_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (HbaseAtomicIncrementArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) hbase_atomic_increment_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (HbaseAtomicIncrementArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) hbase_atomic_increment_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "HbaseAtomicIncrementArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _HbaseAtomicIncrementResultProperties
{
  PROP_HBASE_ATOMIC_INCREMENT_RESULT_0,
  PROP_HBASE_ATOMIC_INCREMENT_RESULT_SUCCESS,
  PROP_HBASE_ATOMIC_INCREMENT_RESULT_IO,
  PROP_HBASE_ATOMIC_INCREMENT_RESULT_IA
};

/* reads a hbase_atomic_increment_result object */
static gint32
hbase_atomic_increment_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  HbaseAtomicIncrementResult * this_object = HBASE_ATOMIC_INCREMENT_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->io != NULL)
          {
            g_object_unref (this_object->io);
          }
          this_object->io = g_object_new (TYPE_I_O_ERROR, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
          {
            g_object_unref (this_object->io);
            this_object->io = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_io = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ia != NULL)
          {
            g_object_unref (this_object->ia);
          }
          this_object->ia = g_object_new (TYPE_ILLEGAL_ARGUMENT, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ia), protocol, error)) < 0)
          {
            g_object_unref (this_object->ia);
            this_object->ia = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ia = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
hbase_atomic_increment_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  HbaseAtomicIncrementResult * this_object = HBASE_ATOMIC_INCREMENT_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "HbaseAtomicIncrementResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I64, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, this_object->success, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_io == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "io", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ia == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ia", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ia), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
hbase_atomic_increment_result_set_property (GObject *object,
                                            guint property_id,
                                            const GValue *value,
                                            GParamSpec *pspec)
{
  HbaseAtomicIncrementResult *self = HBASE_ATOMIC_INCREMENT_RESULT (object);

  switch (property_id)
  {
    case PROP_HBASE_ATOMIC_INCREMENT_RESULT_SUCCESS:
      self->success = g_value_get_int64 (value);
      self->__isset_success = TRUE;
      break;

    case PROP_HBASE_ATOMIC_INCREMENT_RESULT_IO:
      if (self->io != NULL)
        g_object_unref (self->io);
      self->io = g_value_dup_object (value);
      self->__isset_io = TRUE;
      break;

    case PROP_HBASE_ATOMIC_INCREMENT_RESULT_IA:
      if (self->ia != NULL)
        g_object_unref (self->ia);
      self->ia = g_value_dup_object (value);
      self->__isset_ia = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
hbase_atomic_increment_result_get_property (GObject *object,
                                            guint property_id,
                                            GValue *value,
                                            GParamSpec *pspec)
{
  HbaseAtomicIncrementResult *self = HBASE_ATOMIC_INCREMENT_RESULT (object);

  switch (property_id)
  {
    case PROP_HBASE_ATOMIC_INCREMENT_RESULT_SUCCESS:
      g_value_set_int64 (value, self->success);
      break;

    case PROP_HBASE_ATOMIC_INCREMENT_RESULT_IO:
      g_value_set_object (value, self->io);
      break;

    case PROP_HBASE_ATOMIC_INCREMENT_RESULT_IA:
      g_value_set_object (value, self->ia);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
hbase_atomic_increment_result_instance_init (HbaseAtomicIncrementResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
  object->io = NULL;
  object->__isset_io = FALSE;
  object->ia = NULL;
  object->__isset_ia = FALSE;
}

static void 
hbase_atomic_increment_result_finalize (GObject *object)
{
  HbaseAtomicIncrementResult *tobject = HBASE_ATOMIC_INCREMENT_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->io != NULL)
  {
    g_object_unref(tobject->io);
    tobject->io = NULL;
  }
  if (tobject->ia != NULL)
  {
    g_object_unref(tobject->ia);
    tobject->ia = NULL;
  }
}

static void
hbase_atomic_increment_result_class_init (HbaseAtomicIncrementResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = hbase_atomic_increment_result_read;
  struct_class->write = hbase_atomic_increment_result_write;

  gobject_class->finalize = hbase_atomic_increment_result_finalize;
  gobject_class->get_property = hbase_atomic_increment_result_get_property;
  gobject_class->set_property = hbase_atomic_increment_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_ATOMIC_INCREMENT_RESULT_SUCCESS,
     g_param_spec_int64 ("success",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_ATOMIC_INCREMENT_RESULT_IO,
     g_param_spec_object ("io",
                         NULL,
                         NULL,
                         TYPE_I_O_ERROR,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_ATOMIC_INCREMENT_RESULT_IA,
     g_param_spec_object ("ia",
                         NULL,
                         NULL,
                         TYPE_ILLEGAL_ARGUMENT,
                         G_PARAM_READWRITE));
}

GType
hbase_atomic_increment_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (HbaseAtomicIncrementResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) hbase_atomic_increment_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (HbaseAtomicIncrementResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) hbase_atomic_increment_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "HbaseAtomicIncrementResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _HbaseDeleteAllArgsProperties
{
  PROP_HBASE_DELETE_ALL_ARGS_0,
  PROP_HBASE_DELETE_ALL_ARGS_TABLE_NAME,
  PROP_HBASE_DELETE_ALL_ARGS_ROW,
  PROP_HBASE_DELETE_ALL_ARGS_COLUMN,
  PROP_HBASE_DELETE_ALL_ARGS_ATTRIBUTES
};

/* reads a hbase_delete_all_args object */
static gint32
hbase_delete_all_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  HbaseDeleteAllArgs * this_object = HBASE_DELETE_ALL_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->tableName != NULL)
          {
            g_free(this_object->tableName);
            this_object->tableName = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->tableName = g_byte_array_new();
          g_byte_array_append (this_object->tableName, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_tableName = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->row != NULL)
          {
            g_free(this_object->row);
            this_object->row = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->row = g_byte_array_new();
          g_byte_array_append (this_object->row, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_row = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if (this_object->column != NULL)
          {
            g_free(this_object->column);
            this_object->column = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->column = g_byte_array_new();
          g_byte_array_append (this_object->column, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_column = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              Text key130 = NULL;
              Text val131 = NULL;
              if (key130 != NULL)
              {
                g_free(key130);
                key130 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              key130 = g_byte_array_new();
              g_byte_array_append (key130, (guint8 *) data, (guint) len);
              g_free (data);
              if (val131 != NULL)
              {
                g_free(val131);
                val131 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              val131 = g_byte_array_new();
              g_byte_array_append (val131, (guint8 *) data, (guint) len);
              g_free (data);
              if (this_object->attributes && key130)
                g_hash_table_insert ((GHashTable *)this_object->attributes, (gpointer) key130, (gpointer) val131);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_attributes = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
hbase_delete_all_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  HbaseDeleteAllArgs * this_object = HBASE_DELETE_ALL_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "HbaseDeleteAllArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "tableName", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->tableName ? ((GByteArray *) this_object->tableName)->data : NULL, this_object->tableName ? ((GByteArray *) this_object->tableName)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "row", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->row ? ((GByteArray *) this_object->row)->data : NULL, this_object->row ? ((GByteArray *) this_object->row)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "column", T_STRING, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->column ? ((GByteArray *) this_object->column)->data : NULL, this_object->column ? ((GByteArray *) this_object->column)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "attributes", T_MAP, 4, error)) < 0)
    return -1;
  xfer += ret;
  {
    Text key132 = NULL;
    Text val133 = NULL;
    GList *key_list = NULL, *iter = NULL;
    Text* keys;
    int i = 0, key_count;

    if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRING, this_object->attributes ? (gint32) g_hash_table_size ((GHashTable *) this_object->attributes) : 0, error)) < 0)
      return -1;
    xfer += ret;
    if (this_object->attributes)
      g_hash_table_foreach ((GHashTable *) this_object->attributes, thrift_hash_table_get_keys, &key_list);
    key_count = g_list_length (key_list);
    keys = g_newa (Text, key_count);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
      keys[i++] = (Text) iter->data;
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key132 = keys[i];
      val133 = (Text) g_hash_table_lookup (((GHashTable *) this_object->attributes), (gpointer) key132);

      if ((ret = thrift_protocol_write_binary (protocol,  key132 ? ((GByteArray *)  key132)->data : NULL,  key132 ? ((GByteArray *)  key132)->len : 0, error)) < 0)
        return -1;
      xfer += ret;

      if ((ret = thrift_protocol_write_binary (protocol,  val133 ? ((GByteArray *)  val133)->data : NULL,  val133 ? ((GByteArray *)  val133)->len : 0, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
hbase_delete_all_args_set_property (GObject *object,
                                    guint property_id,
                                    const GValue *value,
                                    GParamSpec *pspec)
{
  HbaseDeleteAllArgs *self = HBASE_DELETE_ALL_ARGS (object);

  switch (property_id)
  {
    case PROP_HBASE_DELETE_ALL_ARGS_TABLE_NAME:
      if (self->tableName != NULL)
        g_byte_array_unref (self->tableName);
      self->tableName = g_value_dup_boxed (value);
      self->__isset_tableName = TRUE;
      break;

    case PROP_HBASE_DELETE_ALL_ARGS_ROW:
      if (self->row != NULL)
        g_byte_array_unref (self->row);
      self->row = g_value_dup_boxed (value);
      self->__isset_row = TRUE;
      break;

    case PROP_HBASE_DELETE_ALL_ARGS_COLUMN:
      if (self->column != NULL)
        g_byte_array_unref (self->column);
      self->column = g_value_dup_boxed (value);
      self->__isset_column = TRUE;
      break;

    case PROP_HBASE_DELETE_ALL_ARGS_ATTRIBUTES:
      if (self->attributes != NULL)
        g_hash_table_unref (self->attributes);
      self->attributes = g_value_dup_boxed (value);
      self->__isset_attributes = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
hbase_delete_all_args_get_property (GObject *object,
                                    guint property_id,
                                    GValue *value,
                                    GParamSpec *pspec)
{
  HbaseDeleteAllArgs *self = HBASE_DELETE_ALL_ARGS (object);

  switch (property_id)
  {
    case PROP_HBASE_DELETE_ALL_ARGS_TABLE_NAME:
      g_value_set_boxed (value, self->tableName);
      break;

    case PROP_HBASE_DELETE_ALL_ARGS_ROW:
      g_value_set_boxed (value, self->row);
      break;

    case PROP_HBASE_DELETE_ALL_ARGS_COLUMN:
      g_value_set_boxed (value, self->column);
      break;

    case PROP_HBASE_DELETE_ALL_ARGS_ATTRIBUTES:
      g_value_set_boxed (value, self->attributes);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
hbase_delete_all_args_instance_init (HbaseDeleteAllArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->tableName = NULL;
  object->__isset_tableName = FALSE;
  object->row = NULL;
  object->__isset_row = FALSE;
  object->column = NULL;
  object->__isset_column = FALSE;
  object->attributes = g_hash_table_new_full (g_str_hash, g_str_equal, thrift_string_free, thrift_string_free);
  object->__isset_attributes = FALSE;
}

static void 
hbase_delete_all_args_finalize (GObject *object)
{
  HbaseDeleteAllArgs *tobject = HBASE_DELETE_ALL_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->tableName != NULL)
  {
    thrift_string_free(tobject->tableName);
    tobject->tableName = NULL;
  }
  if (tobject->row != NULL)
  {
    thrift_string_free(tobject->row);
    tobject->row = NULL;
  }
  if (tobject->column != NULL)
  {
    thrift_string_free(tobject->column);
    tobject->column = NULL;
  }
  if (tobject->attributes != NULL)
  {
    g_hash_table_destroy (tobject->attributes);
    tobject->attributes = NULL;
  }
}

static void
hbase_delete_all_args_class_init (HbaseDeleteAllArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = hbase_delete_all_args_read;
  struct_class->write = hbase_delete_all_args_write;

  gobject_class->finalize = hbase_delete_all_args_finalize;
  gobject_class->get_property = hbase_delete_all_args_get_property;
  gobject_class->set_property = hbase_delete_all_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_DELETE_ALL_ARGS_TABLE_NAME,
     g_param_spec_boxed ("tableName",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_DELETE_ALL_ARGS_ROW,
     g_param_spec_boxed ("row",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_DELETE_ALL_ARGS_COLUMN,
     g_param_spec_boxed ("column",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_DELETE_ALL_ARGS_ATTRIBUTES,
     g_param_spec_boxed ("attributes",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));
}

GType
hbase_delete_all_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (HbaseDeleteAllArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) hbase_delete_all_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (HbaseDeleteAllArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) hbase_delete_all_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "HbaseDeleteAllArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _HbaseDeleteAllResultProperties
{
  PROP_HBASE_DELETE_ALL_RESULT_0,
  PROP_HBASE_DELETE_ALL_RESULT_IO
};

/* reads a hbase_delete_all_result object */
static gint32
hbase_delete_all_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  HbaseDeleteAllResult * this_object = HBASE_DELETE_ALL_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->io != NULL)
          {
            g_object_unref (this_object->io);
          }
          this_object->io = g_object_new (TYPE_I_O_ERROR, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
          {
            g_object_unref (this_object->io);
            this_object->io = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_io = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
hbase_delete_all_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  HbaseDeleteAllResult * this_object = HBASE_DELETE_ALL_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "HbaseDeleteAllResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_io == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "io", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
hbase_delete_all_result_set_property (GObject *object,
                                      guint property_id,
                                      const GValue *value,
                                      GParamSpec *pspec)
{
  HbaseDeleteAllResult *self = HBASE_DELETE_ALL_RESULT (object);

  switch (property_id)
  {
    case PROP_HBASE_DELETE_ALL_RESULT_IO:
      if (self->io != NULL)
        g_object_unref (self->io);
      self->io = g_value_dup_object (value);
      self->__isset_io = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
hbase_delete_all_result_get_property (GObject *object,
                                      guint property_id,
                                      GValue *value,
                                      GParamSpec *pspec)
{
  HbaseDeleteAllResult *self = HBASE_DELETE_ALL_RESULT (object);

  switch (property_id)
  {
    case PROP_HBASE_DELETE_ALL_RESULT_IO:
      g_value_set_object (value, self->io);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
hbase_delete_all_result_instance_init (HbaseDeleteAllResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->io = NULL;
  object->__isset_io = FALSE;
}

static void 
hbase_delete_all_result_finalize (GObject *object)
{
  HbaseDeleteAllResult *tobject = HBASE_DELETE_ALL_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->io != NULL)
  {
    g_object_unref(tobject->io);
    tobject->io = NULL;
  }
}

static void
hbase_delete_all_result_class_init (HbaseDeleteAllResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = hbase_delete_all_result_read;
  struct_class->write = hbase_delete_all_result_write;

  gobject_class->finalize = hbase_delete_all_result_finalize;
  gobject_class->get_property = hbase_delete_all_result_get_property;
  gobject_class->set_property = hbase_delete_all_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_DELETE_ALL_RESULT_IO,
     g_param_spec_object ("io",
                         NULL,
                         NULL,
                         TYPE_I_O_ERROR,
                         G_PARAM_READWRITE));
}

GType
hbase_delete_all_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (HbaseDeleteAllResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) hbase_delete_all_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (HbaseDeleteAllResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) hbase_delete_all_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "HbaseDeleteAllResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _HbaseDeleteAllTsArgsProperties
{
  PROP_HBASE_DELETE_ALL_TS_ARGS_0,
  PROP_HBASE_DELETE_ALL_TS_ARGS_TABLE_NAME,
  PROP_HBASE_DELETE_ALL_TS_ARGS_ROW,
  PROP_HBASE_DELETE_ALL_TS_ARGS_COLUMN,
  PROP_HBASE_DELETE_ALL_TS_ARGS_TIMESTAMP,
  PROP_HBASE_DELETE_ALL_TS_ARGS_ATTRIBUTES
};

/* reads a hbase_delete_all_ts_args object */
static gint32
hbase_delete_all_ts_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  HbaseDeleteAllTsArgs * this_object = HBASE_DELETE_ALL_TS_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->tableName != NULL)
          {
            g_free(this_object->tableName);
            this_object->tableName = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->tableName = g_byte_array_new();
          g_byte_array_append (this_object->tableName, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_tableName = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->row != NULL)
          {
            g_free(this_object->row);
            this_object->row = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->row = g_byte_array_new();
          g_byte_array_append (this_object->row, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_row = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if (this_object->column != NULL)
          {
            g_free(this_object->column);
            this_object->column = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->column = g_byte_array_new();
          g_byte_array_append (this_object->column, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_column = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->timestamp, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_timestamp = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              Text key134 = NULL;
              Text val135 = NULL;
              if (key134 != NULL)
              {
                g_free(key134);
                key134 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              key134 = g_byte_array_new();
              g_byte_array_append (key134, (guint8 *) data, (guint) len);
              g_free (data);
              if (val135 != NULL)
              {
                g_free(val135);
                val135 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              val135 = g_byte_array_new();
              g_byte_array_append (val135, (guint8 *) data, (guint) len);
              g_free (data);
              if (this_object->attributes && key134)
                g_hash_table_insert ((GHashTable *)this_object->attributes, (gpointer) key134, (gpointer) val135);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_attributes = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
hbase_delete_all_ts_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  HbaseDeleteAllTsArgs * this_object = HBASE_DELETE_ALL_TS_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "HbaseDeleteAllTsArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "tableName", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->tableName ? ((GByteArray *) this_object->tableName)->data : NULL, this_object->tableName ? ((GByteArray *) this_object->tableName)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "row", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->row ? ((GByteArray *) this_object->row)->data : NULL, this_object->row ? ((GByteArray *) this_object->row)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "column", T_STRING, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->column ? ((GByteArray *) this_object->column)->data : NULL, this_object->column ? ((GByteArray *) this_object->column)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "timestamp", T_I64, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->timestamp, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "attributes", T_MAP, 5, error)) < 0)
    return -1;
  xfer += ret;
  {
    Text key136 = NULL;
    Text val137 = NULL;
    GList *key_list = NULL, *iter = NULL;
    Text* keys;
    int i = 0, key_count;

    if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRING, this_object->attributes ? (gint32) g_hash_table_size ((GHashTable *) this_object->attributes) : 0, error)) < 0)
      return -1;
    xfer += ret;
    if (this_object->attributes)
      g_hash_table_foreach ((GHashTable *) this_object->attributes, thrift_hash_table_get_keys, &key_list);
    key_count = g_list_length (key_list);
    keys = g_newa (Text, key_count);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
      keys[i++] = (Text) iter->data;
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key136 = keys[i];
      val137 = (Text) g_hash_table_lookup (((GHashTable *) this_object->attributes), (gpointer) key136);

      if ((ret = thrift_protocol_write_binary (protocol,  key136 ? ((GByteArray *)  key136)->data : NULL,  key136 ? ((GByteArray *)  key136)->len : 0, error)) < 0)
        return -1;
      xfer += ret;

      if ((ret = thrift_protocol_write_binary (protocol,  val137 ? ((GByteArray *)  val137)->data : NULL,  val137 ? ((GByteArray *)  val137)->len : 0, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
hbase_delete_all_ts_args_set_property (GObject *object,
                                       guint property_id,
                                       const GValue *value,
                                       GParamSpec *pspec)
{
  HbaseDeleteAllTsArgs *self = HBASE_DELETE_ALL_TS_ARGS (object);

  switch (property_id)
  {
    case PROP_HBASE_DELETE_ALL_TS_ARGS_TABLE_NAME:
      if (self->tableName != NULL)
        g_byte_array_unref (self->tableName);
      self->tableName = g_value_dup_boxed (value);
      self->__isset_tableName = TRUE;
      break;

    case PROP_HBASE_DELETE_ALL_TS_ARGS_ROW:
      if (self->row != NULL)
        g_byte_array_unref (self->row);
      self->row = g_value_dup_boxed (value);
      self->__isset_row = TRUE;
      break;

    case PROP_HBASE_DELETE_ALL_TS_ARGS_COLUMN:
      if (self->column != NULL)
        g_byte_array_unref (self->column);
      self->column = g_value_dup_boxed (value);
      self->__isset_column = TRUE;
      break;

    case PROP_HBASE_DELETE_ALL_TS_ARGS_TIMESTAMP:
      self->timestamp = g_value_get_int64 (value);
      self->__isset_timestamp = TRUE;
      break;

    case PROP_HBASE_DELETE_ALL_TS_ARGS_ATTRIBUTES:
      if (self->attributes != NULL)
        g_hash_table_unref (self->attributes);
      self->attributes = g_value_dup_boxed (value);
      self->__isset_attributes = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
hbase_delete_all_ts_args_get_property (GObject *object,
                                       guint property_id,
                                       GValue *value,
                                       GParamSpec *pspec)
{
  HbaseDeleteAllTsArgs *self = HBASE_DELETE_ALL_TS_ARGS (object);

  switch (property_id)
  {
    case PROP_HBASE_DELETE_ALL_TS_ARGS_TABLE_NAME:
      g_value_set_boxed (value, self->tableName);
      break;

    case PROP_HBASE_DELETE_ALL_TS_ARGS_ROW:
      g_value_set_boxed (value, self->row);
      break;

    case PROP_HBASE_DELETE_ALL_TS_ARGS_COLUMN:
      g_value_set_boxed (value, self->column);
      break;

    case PROP_HBASE_DELETE_ALL_TS_ARGS_TIMESTAMP:
      g_value_set_int64 (value, self->timestamp);
      break;

    case PROP_HBASE_DELETE_ALL_TS_ARGS_ATTRIBUTES:
      g_value_set_boxed (value, self->attributes);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
hbase_delete_all_ts_args_instance_init (HbaseDeleteAllTsArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->tableName = NULL;
  object->__isset_tableName = FALSE;
  object->row = NULL;
  object->__isset_row = FALSE;
  object->column = NULL;
  object->__isset_column = FALSE;
  object->timestamp = 0;
  object->__isset_timestamp = FALSE;
  object->attributes = g_hash_table_new_full (g_str_hash, g_str_equal, thrift_string_free, thrift_string_free);
  object->__isset_attributes = FALSE;
}

static void 
hbase_delete_all_ts_args_finalize (GObject *object)
{
  HbaseDeleteAllTsArgs *tobject = HBASE_DELETE_ALL_TS_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->tableName != NULL)
  {
    thrift_string_free(tobject->tableName);
    tobject->tableName = NULL;
  }
  if (tobject->row != NULL)
  {
    thrift_string_free(tobject->row);
    tobject->row = NULL;
  }
  if (tobject->column != NULL)
  {
    thrift_string_free(tobject->column);
    tobject->column = NULL;
  }
  if (tobject->attributes != NULL)
  {
    g_hash_table_destroy (tobject->attributes);
    tobject->attributes = NULL;
  }
}

static void
hbase_delete_all_ts_args_class_init (HbaseDeleteAllTsArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = hbase_delete_all_ts_args_read;
  struct_class->write = hbase_delete_all_ts_args_write;

  gobject_class->finalize = hbase_delete_all_ts_args_finalize;
  gobject_class->get_property = hbase_delete_all_ts_args_get_property;
  gobject_class->set_property = hbase_delete_all_ts_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_DELETE_ALL_TS_ARGS_TABLE_NAME,
     g_param_spec_boxed ("tableName",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_DELETE_ALL_TS_ARGS_ROW,
     g_param_spec_boxed ("row",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_DELETE_ALL_TS_ARGS_COLUMN,
     g_param_spec_boxed ("column",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_DELETE_ALL_TS_ARGS_TIMESTAMP,
     g_param_spec_int64 ("timestamp",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_DELETE_ALL_TS_ARGS_ATTRIBUTES,
     g_param_spec_boxed ("attributes",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));
}

GType
hbase_delete_all_ts_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (HbaseDeleteAllTsArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) hbase_delete_all_ts_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (HbaseDeleteAllTsArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) hbase_delete_all_ts_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "HbaseDeleteAllTsArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _HbaseDeleteAllTsResultProperties
{
  PROP_HBASE_DELETE_ALL_TS_RESULT_0,
  PROP_HBASE_DELETE_ALL_TS_RESULT_IO
};

/* reads a hbase_delete_all_ts_result object */
static gint32
hbase_delete_all_ts_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  HbaseDeleteAllTsResult * this_object = HBASE_DELETE_ALL_TS_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->io != NULL)
          {
            g_object_unref (this_object->io);
          }
          this_object->io = g_object_new (TYPE_I_O_ERROR, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
          {
            g_object_unref (this_object->io);
            this_object->io = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_io = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
hbase_delete_all_ts_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  HbaseDeleteAllTsResult * this_object = HBASE_DELETE_ALL_TS_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "HbaseDeleteAllTsResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_io == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "io", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
hbase_delete_all_ts_result_set_property (GObject *object,
                                         guint property_id,
                                         const GValue *value,
                                         GParamSpec *pspec)
{
  HbaseDeleteAllTsResult *self = HBASE_DELETE_ALL_TS_RESULT (object);

  switch (property_id)
  {
    case PROP_HBASE_DELETE_ALL_TS_RESULT_IO:
      if (self->io != NULL)
        g_object_unref (self->io);
      self->io = g_value_dup_object (value);
      self->__isset_io = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
hbase_delete_all_ts_result_get_property (GObject *object,
                                         guint property_id,
                                         GValue *value,
                                         GParamSpec *pspec)
{
  HbaseDeleteAllTsResult *self = HBASE_DELETE_ALL_TS_RESULT (object);

  switch (property_id)
  {
    case PROP_HBASE_DELETE_ALL_TS_RESULT_IO:
      g_value_set_object (value, self->io);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
hbase_delete_all_ts_result_instance_init (HbaseDeleteAllTsResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->io = NULL;
  object->__isset_io = FALSE;
}

static void 
hbase_delete_all_ts_result_finalize (GObject *object)
{
  HbaseDeleteAllTsResult *tobject = HBASE_DELETE_ALL_TS_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->io != NULL)
  {
    g_object_unref(tobject->io);
    tobject->io = NULL;
  }
}

static void
hbase_delete_all_ts_result_class_init (HbaseDeleteAllTsResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = hbase_delete_all_ts_result_read;
  struct_class->write = hbase_delete_all_ts_result_write;

  gobject_class->finalize = hbase_delete_all_ts_result_finalize;
  gobject_class->get_property = hbase_delete_all_ts_result_get_property;
  gobject_class->set_property = hbase_delete_all_ts_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_DELETE_ALL_TS_RESULT_IO,
     g_param_spec_object ("io",
                         NULL,
                         NULL,
                         TYPE_I_O_ERROR,
                         G_PARAM_READWRITE));
}

GType
hbase_delete_all_ts_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (HbaseDeleteAllTsResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) hbase_delete_all_ts_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (HbaseDeleteAllTsResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) hbase_delete_all_ts_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "HbaseDeleteAllTsResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _HbaseDeleteAllRowArgsProperties
{
  PROP_HBASE_DELETE_ALL_ROW_ARGS_0,
  PROP_HBASE_DELETE_ALL_ROW_ARGS_TABLE_NAME,
  PROP_HBASE_DELETE_ALL_ROW_ARGS_ROW,
  PROP_HBASE_DELETE_ALL_ROW_ARGS_ATTRIBUTES
};

/* reads a hbase_delete_all_row_args object */
static gint32
hbase_delete_all_row_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  HbaseDeleteAllRowArgs * this_object = HBASE_DELETE_ALL_ROW_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->tableName != NULL)
          {
            g_free(this_object->tableName);
            this_object->tableName = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->tableName = g_byte_array_new();
          g_byte_array_append (this_object->tableName, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_tableName = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->row != NULL)
          {
            g_free(this_object->row);
            this_object->row = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->row = g_byte_array_new();
          g_byte_array_append (this_object->row, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_row = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              Text key138 = NULL;
              Text val139 = NULL;
              if (key138 != NULL)
              {
                g_free(key138);
                key138 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              key138 = g_byte_array_new();
              g_byte_array_append (key138, (guint8 *) data, (guint) len);
              g_free (data);
              if (val139 != NULL)
              {
                g_free(val139);
                val139 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              val139 = g_byte_array_new();
              g_byte_array_append (val139, (guint8 *) data, (guint) len);
              g_free (data);
              if (this_object->attributes && key138)
                g_hash_table_insert ((GHashTable *)this_object->attributes, (gpointer) key138, (gpointer) val139);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_attributes = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
hbase_delete_all_row_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  HbaseDeleteAllRowArgs * this_object = HBASE_DELETE_ALL_ROW_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "HbaseDeleteAllRowArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "tableName", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->tableName ? ((GByteArray *) this_object->tableName)->data : NULL, this_object->tableName ? ((GByteArray *) this_object->tableName)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "row", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->row ? ((GByteArray *) this_object->row)->data : NULL, this_object->row ? ((GByteArray *) this_object->row)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "attributes", T_MAP, 3, error)) < 0)
    return -1;
  xfer += ret;
  {
    Text key140 = NULL;
    Text val141 = NULL;
    GList *key_list = NULL, *iter = NULL;
    Text* keys;
    int i = 0, key_count;

    if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRING, this_object->attributes ? (gint32) g_hash_table_size ((GHashTable *) this_object->attributes) : 0, error)) < 0)
      return -1;
    xfer += ret;
    if (this_object->attributes)
      g_hash_table_foreach ((GHashTable *) this_object->attributes, thrift_hash_table_get_keys, &key_list);
    key_count = g_list_length (key_list);
    keys = g_newa (Text, key_count);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
      keys[i++] = (Text) iter->data;
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key140 = keys[i];
      val141 = (Text) g_hash_table_lookup (((GHashTable *) this_object->attributes), (gpointer) key140);

      if ((ret = thrift_protocol_write_binary (protocol,  key140 ? ((GByteArray *)  key140)->data : NULL,  key140 ? ((GByteArray *)  key140)->len : 0, error)) < 0)
        return -1;
      xfer += ret;

      if ((ret = thrift_protocol_write_binary (protocol,  val141 ? ((GByteArray *)  val141)->data : NULL,  val141 ? ((GByteArray *)  val141)->len : 0, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
hbase_delete_all_row_args_set_property (GObject *object,
                                        guint property_id,
                                        const GValue *value,
                                        GParamSpec *pspec)
{
  HbaseDeleteAllRowArgs *self = HBASE_DELETE_ALL_ROW_ARGS (object);

  switch (property_id)
  {
    case PROP_HBASE_DELETE_ALL_ROW_ARGS_TABLE_NAME:
      if (self->tableName != NULL)
        g_byte_array_unref (self->tableName);
      self->tableName = g_value_dup_boxed (value);
      self->__isset_tableName = TRUE;
      break;

    case PROP_HBASE_DELETE_ALL_ROW_ARGS_ROW:
      if (self->row != NULL)
        g_byte_array_unref (self->row);
      self->row = g_value_dup_boxed (value);
      self->__isset_row = TRUE;
      break;

    case PROP_HBASE_DELETE_ALL_ROW_ARGS_ATTRIBUTES:
      if (self->attributes != NULL)
        g_hash_table_unref (self->attributes);
      self->attributes = g_value_dup_boxed (value);
      self->__isset_attributes = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
hbase_delete_all_row_args_get_property (GObject *object,
                                        guint property_id,
                                        GValue *value,
                                        GParamSpec *pspec)
{
  HbaseDeleteAllRowArgs *self = HBASE_DELETE_ALL_ROW_ARGS (object);

  switch (property_id)
  {
    case PROP_HBASE_DELETE_ALL_ROW_ARGS_TABLE_NAME:
      g_value_set_boxed (value, self->tableName);
      break;

    case PROP_HBASE_DELETE_ALL_ROW_ARGS_ROW:
      g_value_set_boxed (value, self->row);
      break;

    case PROP_HBASE_DELETE_ALL_ROW_ARGS_ATTRIBUTES:
      g_value_set_boxed (value, self->attributes);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
hbase_delete_all_row_args_instance_init (HbaseDeleteAllRowArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->tableName = NULL;
  object->__isset_tableName = FALSE;
  object->row = NULL;
  object->__isset_row = FALSE;
  object->attributes = g_hash_table_new_full (g_str_hash, g_str_equal, thrift_string_free, thrift_string_free);
  object->__isset_attributes = FALSE;
}

static void 
hbase_delete_all_row_args_finalize (GObject *object)
{
  HbaseDeleteAllRowArgs *tobject = HBASE_DELETE_ALL_ROW_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->tableName != NULL)
  {
    thrift_string_free(tobject->tableName);
    tobject->tableName = NULL;
  }
  if (tobject->row != NULL)
  {
    thrift_string_free(tobject->row);
    tobject->row = NULL;
  }
  if (tobject->attributes != NULL)
  {
    g_hash_table_destroy (tobject->attributes);
    tobject->attributes = NULL;
  }
}

static void
hbase_delete_all_row_args_class_init (HbaseDeleteAllRowArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = hbase_delete_all_row_args_read;
  struct_class->write = hbase_delete_all_row_args_write;

  gobject_class->finalize = hbase_delete_all_row_args_finalize;
  gobject_class->get_property = hbase_delete_all_row_args_get_property;
  gobject_class->set_property = hbase_delete_all_row_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_DELETE_ALL_ROW_ARGS_TABLE_NAME,
     g_param_spec_boxed ("tableName",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_DELETE_ALL_ROW_ARGS_ROW,
     g_param_spec_boxed ("row",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_DELETE_ALL_ROW_ARGS_ATTRIBUTES,
     g_param_spec_boxed ("attributes",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));
}

GType
hbase_delete_all_row_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (HbaseDeleteAllRowArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) hbase_delete_all_row_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (HbaseDeleteAllRowArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) hbase_delete_all_row_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "HbaseDeleteAllRowArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _HbaseDeleteAllRowResultProperties
{
  PROP_HBASE_DELETE_ALL_ROW_RESULT_0,
  PROP_HBASE_DELETE_ALL_ROW_RESULT_IO
};

/* reads a hbase_delete_all_row_result object */
static gint32
hbase_delete_all_row_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  HbaseDeleteAllRowResult * this_object = HBASE_DELETE_ALL_ROW_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->io != NULL)
          {
            g_object_unref (this_object->io);
          }
          this_object->io = g_object_new (TYPE_I_O_ERROR, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
          {
            g_object_unref (this_object->io);
            this_object->io = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_io = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
hbase_delete_all_row_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  HbaseDeleteAllRowResult * this_object = HBASE_DELETE_ALL_ROW_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "HbaseDeleteAllRowResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_io == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "io", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
hbase_delete_all_row_result_set_property (GObject *object,
                                          guint property_id,
                                          const GValue *value,
                                          GParamSpec *pspec)
{
  HbaseDeleteAllRowResult *self = HBASE_DELETE_ALL_ROW_RESULT (object);

  switch (property_id)
  {
    case PROP_HBASE_DELETE_ALL_ROW_RESULT_IO:
      if (self->io != NULL)
        g_object_unref (self->io);
      self->io = g_value_dup_object (value);
      self->__isset_io = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
hbase_delete_all_row_result_get_property (GObject *object,
                                          guint property_id,
                                          GValue *value,
                                          GParamSpec *pspec)
{
  HbaseDeleteAllRowResult *self = HBASE_DELETE_ALL_ROW_RESULT (object);

  switch (property_id)
  {
    case PROP_HBASE_DELETE_ALL_ROW_RESULT_IO:
      g_value_set_object (value, self->io);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
hbase_delete_all_row_result_instance_init (HbaseDeleteAllRowResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->io = NULL;
  object->__isset_io = FALSE;
}

static void 
hbase_delete_all_row_result_finalize (GObject *object)
{
  HbaseDeleteAllRowResult *tobject = HBASE_DELETE_ALL_ROW_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->io != NULL)
  {
    g_object_unref(tobject->io);
    tobject->io = NULL;
  }
}

static void
hbase_delete_all_row_result_class_init (HbaseDeleteAllRowResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = hbase_delete_all_row_result_read;
  struct_class->write = hbase_delete_all_row_result_write;

  gobject_class->finalize = hbase_delete_all_row_result_finalize;
  gobject_class->get_property = hbase_delete_all_row_result_get_property;
  gobject_class->set_property = hbase_delete_all_row_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_DELETE_ALL_ROW_RESULT_IO,
     g_param_spec_object ("io",
                         NULL,
                         NULL,
                         TYPE_I_O_ERROR,
                         G_PARAM_READWRITE));
}

GType
hbase_delete_all_row_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (HbaseDeleteAllRowResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) hbase_delete_all_row_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (HbaseDeleteAllRowResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) hbase_delete_all_row_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "HbaseDeleteAllRowResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _HbaseIncrementArgsProperties
{
  PROP_HBASE_INCREMENT_ARGS_0,
  PROP_HBASE_INCREMENT_ARGS_INCREMENT
};

/* reads a hbase_increment_args object */
static gint32
hbase_increment_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  HbaseIncrementArgs * this_object = HBASE_INCREMENT_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->increment), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_increment = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
hbase_increment_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  HbaseIncrementArgs * this_object = HBASE_INCREMENT_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "HbaseIncrementArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "increment", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->increment), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
hbase_increment_args_set_property (GObject *object,
                                   guint property_id,
                                   const GValue *value,
                                   GParamSpec *pspec)
{
  HbaseIncrementArgs *self = HBASE_INCREMENT_ARGS (object);

  switch (property_id)
  {
    case PROP_HBASE_INCREMENT_ARGS_INCREMENT:
      if (self->increment != NULL)
        g_object_unref (self->increment);
      self->increment = g_value_dup_object (value);
      self->__isset_increment = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
hbase_increment_args_get_property (GObject *object,
                                   guint property_id,
                                   GValue *value,
                                   GParamSpec *pspec)
{
  HbaseIncrementArgs *self = HBASE_INCREMENT_ARGS (object);

  switch (property_id)
  {
    case PROP_HBASE_INCREMENT_ARGS_INCREMENT:
      g_value_set_object (value, self->increment);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
hbase_increment_args_instance_init (HbaseIncrementArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->increment = g_object_new (TYPE_T_INCREMENT, NULL);
  object->__isset_increment = FALSE;
}

static void 
hbase_increment_args_finalize (GObject *object)
{
  HbaseIncrementArgs *tobject = HBASE_INCREMENT_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->increment != NULL)
  {
    g_object_unref(tobject->increment);
    tobject->increment = NULL;
  }
}

static void
hbase_increment_args_class_init (HbaseIncrementArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = hbase_increment_args_read;
  struct_class->write = hbase_increment_args_write;

  gobject_class->finalize = hbase_increment_args_finalize;
  gobject_class->get_property = hbase_increment_args_get_property;
  gobject_class->set_property = hbase_increment_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_INCREMENT_ARGS_INCREMENT,
     g_param_spec_object ("increment",
                         NULL,
                         NULL,
                         TYPE_T_INCREMENT,
                         G_PARAM_READWRITE));
}

GType
hbase_increment_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (HbaseIncrementArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) hbase_increment_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (HbaseIncrementArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) hbase_increment_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "HbaseIncrementArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _HbaseIncrementResultProperties
{
  PROP_HBASE_INCREMENT_RESULT_0,
  PROP_HBASE_INCREMENT_RESULT_IO
};

/* reads a hbase_increment_result object */
static gint32
hbase_increment_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  HbaseIncrementResult * this_object = HBASE_INCREMENT_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->io != NULL)
          {
            g_object_unref (this_object->io);
          }
          this_object->io = g_object_new (TYPE_I_O_ERROR, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
          {
            g_object_unref (this_object->io);
            this_object->io = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_io = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
hbase_increment_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  HbaseIncrementResult * this_object = HBASE_INCREMENT_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "HbaseIncrementResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_io == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "io", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
hbase_increment_result_set_property (GObject *object,
                                     guint property_id,
                                     const GValue *value,
                                     GParamSpec *pspec)
{
  HbaseIncrementResult *self = HBASE_INCREMENT_RESULT (object);

  switch (property_id)
  {
    case PROP_HBASE_INCREMENT_RESULT_IO:
      if (self->io != NULL)
        g_object_unref (self->io);
      self->io = g_value_dup_object (value);
      self->__isset_io = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
hbase_increment_result_get_property (GObject *object,
                                     guint property_id,
                                     GValue *value,
                                     GParamSpec *pspec)
{
  HbaseIncrementResult *self = HBASE_INCREMENT_RESULT (object);

  switch (property_id)
  {
    case PROP_HBASE_INCREMENT_RESULT_IO:
      g_value_set_object (value, self->io);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
hbase_increment_result_instance_init (HbaseIncrementResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->io = NULL;
  object->__isset_io = FALSE;
}

static void 
hbase_increment_result_finalize (GObject *object)
{
  HbaseIncrementResult *tobject = HBASE_INCREMENT_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->io != NULL)
  {
    g_object_unref(tobject->io);
    tobject->io = NULL;
  }
}

static void
hbase_increment_result_class_init (HbaseIncrementResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = hbase_increment_result_read;
  struct_class->write = hbase_increment_result_write;

  gobject_class->finalize = hbase_increment_result_finalize;
  gobject_class->get_property = hbase_increment_result_get_property;
  gobject_class->set_property = hbase_increment_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_INCREMENT_RESULT_IO,
     g_param_spec_object ("io",
                         NULL,
                         NULL,
                         TYPE_I_O_ERROR,
                         G_PARAM_READWRITE));
}

GType
hbase_increment_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (HbaseIncrementResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) hbase_increment_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (HbaseIncrementResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) hbase_increment_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "HbaseIncrementResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _HbaseIncrementRowsArgsProperties
{
  PROP_HBASE_INCREMENT_ROWS_ARGS_0,
  PROP_HBASE_INCREMENT_ROWS_ARGS_INCREMENTS
};

/* reads a hbase_increment_rows_args object */
static gint32
hbase_increment_rows_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  HbaseIncrementRowsArgs * this_object = HBASE_INCREMENT_ROWS_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              TIncrement * _elem142 = NULL;
              if ( _elem142 != NULL)
              {
                g_object_unref (_elem142);
              }
              _elem142 = g_object_new (TYPE_T_INCREMENT, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem142), protocol, error)) < 0)
              {
                g_object_unref (_elem142);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->increments, _elem142);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_increments = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
hbase_increment_rows_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  HbaseIncrementRowsArgs * this_object = HBASE_INCREMENT_ROWS_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "HbaseIncrementRowsArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "increments", T_LIST, 1, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i143;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->increments ? this_object->increments->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i143 = 0; i143 < (this_object->increments ? this_object->increments->len : 0); i143++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->increments, i143))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
hbase_increment_rows_args_set_property (GObject *object,
                                        guint property_id,
                                        const GValue *value,
                                        GParamSpec *pspec)
{
  HbaseIncrementRowsArgs *self = HBASE_INCREMENT_ROWS_ARGS (object);

  switch (property_id)
  {
    case PROP_HBASE_INCREMENT_ROWS_ARGS_INCREMENTS:
      if (self->increments != NULL)
        g_ptr_array_unref (self->increments);
      self->increments = g_value_dup_boxed (value);
      self->__isset_increments = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
hbase_increment_rows_args_get_property (GObject *object,
                                        guint property_id,
                                        GValue *value,
                                        GParamSpec *pspec)
{
  HbaseIncrementRowsArgs *self = HBASE_INCREMENT_ROWS_ARGS (object);

  switch (property_id)
  {
    case PROP_HBASE_INCREMENT_ROWS_ARGS_INCREMENTS:
      g_value_set_boxed (value, self->increments);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
hbase_increment_rows_args_instance_init (HbaseIncrementRowsArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->increments = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_increments = FALSE;
}

static void 
hbase_increment_rows_args_finalize (GObject *object)
{
  HbaseIncrementRowsArgs *tobject = HBASE_INCREMENT_ROWS_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->increments != NULL)
  {
    g_ptr_array_unref (tobject->increments);
    tobject->increments = NULL;
  }
}

static void
hbase_increment_rows_args_class_init (HbaseIncrementRowsArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = hbase_increment_rows_args_read;
  struct_class->write = hbase_increment_rows_args_write;

  gobject_class->finalize = hbase_increment_rows_args_finalize;
  gobject_class->get_property = hbase_increment_rows_args_get_property;
  gobject_class->set_property = hbase_increment_rows_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_INCREMENT_ROWS_ARGS_INCREMENTS,
     g_param_spec_boxed ("increments",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
hbase_increment_rows_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (HbaseIncrementRowsArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) hbase_increment_rows_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (HbaseIncrementRowsArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) hbase_increment_rows_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "HbaseIncrementRowsArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _HbaseIncrementRowsResultProperties
{
  PROP_HBASE_INCREMENT_ROWS_RESULT_0,
  PROP_HBASE_INCREMENT_ROWS_RESULT_IO
};

/* reads a hbase_increment_rows_result object */
static gint32
hbase_increment_rows_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  HbaseIncrementRowsResult * this_object = HBASE_INCREMENT_ROWS_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->io != NULL)
          {
            g_object_unref (this_object->io);
          }
          this_object->io = g_object_new (TYPE_I_O_ERROR, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
          {
            g_object_unref (this_object->io);
            this_object->io = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_io = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
hbase_increment_rows_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  HbaseIncrementRowsResult * this_object = HBASE_INCREMENT_ROWS_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "HbaseIncrementRowsResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_io == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "io", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
hbase_increment_rows_result_set_property (GObject *object,
                                          guint property_id,
                                          const GValue *value,
                                          GParamSpec *pspec)
{
  HbaseIncrementRowsResult *self = HBASE_INCREMENT_ROWS_RESULT (object);

  switch (property_id)
  {
    case PROP_HBASE_INCREMENT_ROWS_RESULT_IO:
      if (self->io != NULL)
        g_object_unref (self->io);
      self->io = g_value_dup_object (value);
      self->__isset_io = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
hbase_increment_rows_result_get_property (GObject *object,
                                          guint property_id,
                                          GValue *value,
                                          GParamSpec *pspec)
{
  HbaseIncrementRowsResult *self = HBASE_INCREMENT_ROWS_RESULT (object);

  switch (property_id)
  {
    case PROP_HBASE_INCREMENT_ROWS_RESULT_IO:
      g_value_set_object (value, self->io);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
hbase_increment_rows_result_instance_init (HbaseIncrementRowsResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->io = NULL;
  object->__isset_io = FALSE;
}

static void 
hbase_increment_rows_result_finalize (GObject *object)
{
  HbaseIncrementRowsResult *tobject = HBASE_INCREMENT_ROWS_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->io != NULL)
  {
    g_object_unref(tobject->io);
    tobject->io = NULL;
  }
}

static void
hbase_increment_rows_result_class_init (HbaseIncrementRowsResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = hbase_increment_rows_result_read;
  struct_class->write = hbase_increment_rows_result_write;

  gobject_class->finalize = hbase_increment_rows_result_finalize;
  gobject_class->get_property = hbase_increment_rows_result_get_property;
  gobject_class->set_property = hbase_increment_rows_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_INCREMENT_ROWS_RESULT_IO,
     g_param_spec_object ("io",
                         NULL,
                         NULL,
                         TYPE_I_O_ERROR,
                         G_PARAM_READWRITE));
}

GType
hbase_increment_rows_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (HbaseIncrementRowsResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) hbase_increment_rows_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (HbaseIncrementRowsResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) hbase_increment_rows_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "HbaseIncrementRowsResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _HbaseDeleteAllRowTsArgsProperties
{
  PROP_HBASE_DELETE_ALL_ROW_TS_ARGS_0,
  PROP_HBASE_DELETE_ALL_ROW_TS_ARGS_TABLE_NAME,
  PROP_HBASE_DELETE_ALL_ROW_TS_ARGS_ROW,
  PROP_HBASE_DELETE_ALL_ROW_TS_ARGS_TIMESTAMP,
  PROP_HBASE_DELETE_ALL_ROW_TS_ARGS_ATTRIBUTES
};

/* reads a hbase_delete_all_row_ts_args object */
static gint32
hbase_delete_all_row_ts_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  HbaseDeleteAllRowTsArgs * this_object = HBASE_DELETE_ALL_ROW_TS_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->tableName != NULL)
          {
            g_free(this_object->tableName);
            this_object->tableName = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->tableName = g_byte_array_new();
          g_byte_array_append (this_object->tableName, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_tableName = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->row != NULL)
          {
            g_free(this_object->row);
            this_object->row = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->row = g_byte_array_new();
          g_byte_array_append (this_object->row, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_row = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->timestamp, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_timestamp = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              Text key144 = NULL;
              Text val145 = NULL;
              if (key144 != NULL)
              {
                g_free(key144);
                key144 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              key144 = g_byte_array_new();
              g_byte_array_append (key144, (guint8 *) data, (guint) len);
              g_free (data);
              if (val145 != NULL)
              {
                g_free(val145);
                val145 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              val145 = g_byte_array_new();
              g_byte_array_append (val145, (guint8 *) data, (guint) len);
              g_free (data);
              if (this_object->attributes && key144)
                g_hash_table_insert ((GHashTable *)this_object->attributes, (gpointer) key144, (gpointer) val145);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_attributes = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
hbase_delete_all_row_ts_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  HbaseDeleteAllRowTsArgs * this_object = HBASE_DELETE_ALL_ROW_TS_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "HbaseDeleteAllRowTsArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "tableName", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->tableName ? ((GByteArray *) this_object->tableName)->data : NULL, this_object->tableName ? ((GByteArray *) this_object->tableName)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "row", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->row ? ((GByteArray *) this_object->row)->data : NULL, this_object->row ? ((GByteArray *) this_object->row)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "timestamp", T_I64, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->timestamp, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "attributes", T_MAP, 4, error)) < 0)
    return -1;
  xfer += ret;
  {
    Text key146 = NULL;
    Text val147 = NULL;
    GList *key_list = NULL, *iter = NULL;
    Text* keys;
    int i = 0, key_count;

    if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRING, this_object->attributes ? (gint32) g_hash_table_size ((GHashTable *) this_object->attributes) : 0, error)) < 0)
      return -1;
    xfer += ret;
    if (this_object->attributes)
      g_hash_table_foreach ((GHashTable *) this_object->attributes, thrift_hash_table_get_keys, &key_list);
    key_count = g_list_length (key_list);
    keys = g_newa (Text, key_count);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
      keys[i++] = (Text) iter->data;
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key146 = keys[i];
      val147 = (Text) g_hash_table_lookup (((GHashTable *) this_object->attributes), (gpointer) key146);

      if ((ret = thrift_protocol_write_binary (protocol,  key146 ? ((GByteArray *)  key146)->data : NULL,  key146 ? ((GByteArray *)  key146)->len : 0, error)) < 0)
        return -1;
      xfer += ret;

      if ((ret = thrift_protocol_write_binary (protocol,  val147 ? ((GByteArray *)  val147)->data : NULL,  val147 ? ((GByteArray *)  val147)->len : 0, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
hbase_delete_all_row_ts_args_set_property (GObject *object,
                                           guint property_id,
                                           const GValue *value,
                                           GParamSpec *pspec)
{
  HbaseDeleteAllRowTsArgs *self = HBASE_DELETE_ALL_ROW_TS_ARGS (object);

  switch (property_id)
  {
    case PROP_HBASE_DELETE_ALL_ROW_TS_ARGS_TABLE_NAME:
      if (self->tableName != NULL)
        g_byte_array_unref (self->tableName);
      self->tableName = g_value_dup_boxed (value);
      self->__isset_tableName = TRUE;
      break;

    case PROP_HBASE_DELETE_ALL_ROW_TS_ARGS_ROW:
      if (self->row != NULL)
        g_byte_array_unref (self->row);
      self->row = g_value_dup_boxed (value);
      self->__isset_row = TRUE;
      break;

    case PROP_HBASE_DELETE_ALL_ROW_TS_ARGS_TIMESTAMP:
      self->timestamp = g_value_get_int64 (value);
      self->__isset_timestamp = TRUE;
      break;

    case PROP_HBASE_DELETE_ALL_ROW_TS_ARGS_ATTRIBUTES:
      if (self->attributes != NULL)
        g_hash_table_unref (self->attributes);
      self->attributes = g_value_dup_boxed (value);
      self->__isset_attributes = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
hbase_delete_all_row_ts_args_get_property (GObject *object,
                                           guint property_id,
                                           GValue *value,
                                           GParamSpec *pspec)
{
  HbaseDeleteAllRowTsArgs *self = HBASE_DELETE_ALL_ROW_TS_ARGS (object);

  switch (property_id)
  {
    case PROP_HBASE_DELETE_ALL_ROW_TS_ARGS_TABLE_NAME:
      g_value_set_boxed (value, self->tableName);
      break;

    case PROP_HBASE_DELETE_ALL_ROW_TS_ARGS_ROW:
      g_value_set_boxed (value, self->row);
      break;

    case PROP_HBASE_DELETE_ALL_ROW_TS_ARGS_TIMESTAMP:
      g_value_set_int64 (value, self->timestamp);
      break;

    case PROP_HBASE_DELETE_ALL_ROW_TS_ARGS_ATTRIBUTES:
      g_value_set_boxed (value, self->attributes);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
hbase_delete_all_row_ts_args_instance_init (HbaseDeleteAllRowTsArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->tableName = NULL;
  object->__isset_tableName = FALSE;
  object->row = NULL;
  object->__isset_row = FALSE;
  object->timestamp = 0;
  object->__isset_timestamp = FALSE;
  object->attributes = g_hash_table_new_full (g_str_hash, g_str_equal, thrift_string_free, thrift_string_free);
  object->__isset_attributes = FALSE;
}

static void 
hbase_delete_all_row_ts_args_finalize (GObject *object)
{
  HbaseDeleteAllRowTsArgs *tobject = HBASE_DELETE_ALL_ROW_TS_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->tableName != NULL)
  {
    thrift_string_free(tobject->tableName);
    tobject->tableName = NULL;
  }
  if (tobject->row != NULL)
  {
    thrift_string_free(tobject->row);
    tobject->row = NULL;
  }
  if (tobject->attributes != NULL)
  {
    g_hash_table_destroy (tobject->attributes);
    tobject->attributes = NULL;
  }
}

static void
hbase_delete_all_row_ts_args_class_init (HbaseDeleteAllRowTsArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = hbase_delete_all_row_ts_args_read;
  struct_class->write = hbase_delete_all_row_ts_args_write;

  gobject_class->finalize = hbase_delete_all_row_ts_args_finalize;
  gobject_class->get_property = hbase_delete_all_row_ts_args_get_property;
  gobject_class->set_property = hbase_delete_all_row_ts_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_DELETE_ALL_ROW_TS_ARGS_TABLE_NAME,
     g_param_spec_boxed ("tableName",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_DELETE_ALL_ROW_TS_ARGS_ROW,
     g_param_spec_boxed ("row",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_DELETE_ALL_ROW_TS_ARGS_TIMESTAMP,
     g_param_spec_int64 ("timestamp",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_DELETE_ALL_ROW_TS_ARGS_ATTRIBUTES,
     g_param_spec_boxed ("attributes",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));
}

GType
hbase_delete_all_row_ts_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (HbaseDeleteAllRowTsArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) hbase_delete_all_row_ts_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (HbaseDeleteAllRowTsArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) hbase_delete_all_row_ts_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "HbaseDeleteAllRowTsArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _HbaseDeleteAllRowTsResultProperties
{
  PROP_HBASE_DELETE_ALL_ROW_TS_RESULT_0,
  PROP_HBASE_DELETE_ALL_ROW_TS_RESULT_IO
};

/* reads a hbase_delete_all_row_ts_result object */
static gint32
hbase_delete_all_row_ts_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  HbaseDeleteAllRowTsResult * this_object = HBASE_DELETE_ALL_ROW_TS_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->io != NULL)
          {
            g_object_unref (this_object->io);
          }
          this_object->io = g_object_new (TYPE_I_O_ERROR, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
          {
            g_object_unref (this_object->io);
            this_object->io = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_io = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
hbase_delete_all_row_ts_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  HbaseDeleteAllRowTsResult * this_object = HBASE_DELETE_ALL_ROW_TS_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "HbaseDeleteAllRowTsResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_io == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "io", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
hbase_delete_all_row_ts_result_set_property (GObject *object,
                                             guint property_id,
                                             const GValue *value,
                                             GParamSpec *pspec)
{
  HbaseDeleteAllRowTsResult *self = HBASE_DELETE_ALL_ROW_TS_RESULT (object);

  switch (property_id)
  {
    case PROP_HBASE_DELETE_ALL_ROW_TS_RESULT_IO:
      if (self->io != NULL)
        g_object_unref (self->io);
      self->io = g_value_dup_object (value);
      self->__isset_io = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
hbase_delete_all_row_ts_result_get_property (GObject *object,
                                             guint property_id,
                                             GValue *value,
                                             GParamSpec *pspec)
{
  HbaseDeleteAllRowTsResult *self = HBASE_DELETE_ALL_ROW_TS_RESULT (object);

  switch (property_id)
  {
    case PROP_HBASE_DELETE_ALL_ROW_TS_RESULT_IO:
      g_value_set_object (value, self->io);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
hbase_delete_all_row_ts_result_instance_init (HbaseDeleteAllRowTsResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->io = NULL;
  object->__isset_io = FALSE;
}

static void 
hbase_delete_all_row_ts_result_finalize (GObject *object)
{
  HbaseDeleteAllRowTsResult *tobject = HBASE_DELETE_ALL_ROW_TS_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->io != NULL)
  {
    g_object_unref(tobject->io);
    tobject->io = NULL;
  }
}

static void
hbase_delete_all_row_ts_result_class_init (HbaseDeleteAllRowTsResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = hbase_delete_all_row_ts_result_read;
  struct_class->write = hbase_delete_all_row_ts_result_write;

  gobject_class->finalize = hbase_delete_all_row_ts_result_finalize;
  gobject_class->get_property = hbase_delete_all_row_ts_result_get_property;
  gobject_class->set_property = hbase_delete_all_row_ts_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_DELETE_ALL_ROW_TS_RESULT_IO,
     g_param_spec_object ("io",
                         NULL,
                         NULL,
                         TYPE_I_O_ERROR,
                         G_PARAM_READWRITE));
}

GType
hbase_delete_all_row_ts_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (HbaseDeleteAllRowTsResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) hbase_delete_all_row_ts_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (HbaseDeleteAllRowTsResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) hbase_delete_all_row_ts_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "HbaseDeleteAllRowTsResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _HbaseScannerOpenWithScanArgsProperties
{
  PROP_HBASE_SCANNER_OPEN_WITH_SCAN_ARGS_0,
  PROP_HBASE_SCANNER_OPEN_WITH_SCAN_ARGS_TABLE_NAME,
  PROP_HBASE_SCANNER_OPEN_WITH_SCAN_ARGS_SCAN,
  PROP_HBASE_SCANNER_OPEN_WITH_SCAN_ARGS_ATTRIBUTES
};

/* reads a hbase_scanner_open_with_scan_args object */
static gint32
hbase_scanner_open_with_scan_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  HbaseScannerOpenWithScanArgs * this_object = HBASE_SCANNER_OPEN_WITH_SCAN_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->tableName != NULL)
          {
            g_free(this_object->tableName);
            this_object->tableName = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->tableName = g_byte_array_new();
          g_byte_array_append (this_object->tableName, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_tableName = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->scan), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_scan = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              Text key148 = NULL;
              Text val149 = NULL;
              if (key148 != NULL)
              {
                g_free(key148);
                key148 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              key148 = g_byte_array_new();
              g_byte_array_append (key148, (guint8 *) data, (guint) len);
              g_free (data);
              if (val149 != NULL)
              {
                g_free(val149);
                val149 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              val149 = g_byte_array_new();
              g_byte_array_append (val149, (guint8 *) data, (guint) len);
              g_free (data);
              if (this_object->attributes && key148)
                g_hash_table_insert ((GHashTable *)this_object->attributes, (gpointer) key148, (gpointer) val149);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_attributes = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
hbase_scanner_open_with_scan_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  HbaseScannerOpenWithScanArgs * this_object = HBASE_SCANNER_OPEN_WITH_SCAN_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "HbaseScannerOpenWithScanArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "tableName", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->tableName ? ((GByteArray *) this_object->tableName)->data : NULL, this_object->tableName ? ((GByteArray *) this_object->tableName)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "scan", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->scan), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "attributes", T_MAP, 3, error)) < 0)
    return -1;
  xfer += ret;
  {
    Text key150 = NULL;
    Text val151 = NULL;
    GList *key_list = NULL, *iter = NULL;
    Text* keys;
    int i = 0, key_count;

    if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRING, this_object->attributes ? (gint32) g_hash_table_size ((GHashTable *) this_object->attributes) : 0, error)) < 0)
      return -1;
    xfer += ret;
    if (this_object->attributes)
      g_hash_table_foreach ((GHashTable *) this_object->attributes, thrift_hash_table_get_keys, &key_list);
    key_count = g_list_length (key_list);
    keys = g_newa (Text, key_count);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
      keys[i++] = (Text) iter->data;
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key150 = keys[i];
      val151 = (Text) g_hash_table_lookup (((GHashTable *) this_object->attributes), (gpointer) key150);

      if ((ret = thrift_protocol_write_binary (protocol,  key150 ? ((GByteArray *)  key150)->data : NULL,  key150 ? ((GByteArray *)  key150)->len : 0, error)) < 0)
        return -1;
      xfer += ret;

      if ((ret = thrift_protocol_write_binary (protocol,  val151 ? ((GByteArray *)  val151)->data : NULL,  val151 ? ((GByteArray *)  val151)->len : 0, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
hbase_scanner_open_with_scan_args_set_property (GObject *object,
                                                guint property_id,
                                                const GValue *value,
                                                GParamSpec *pspec)
{
  HbaseScannerOpenWithScanArgs *self = HBASE_SCANNER_OPEN_WITH_SCAN_ARGS (object);

  switch (property_id)
  {
    case PROP_HBASE_SCANNER_OPEN_WITH_SCAN_ARGS_TABLE_NAME:
      if (self->tableName != NULL)
        g_byte_array_unref (self->tableName);
      self->tableName = g_value_dup_boxed (value);
      self->__isset_tableName = TRUE;
      break;

    case PROP_HBASE_SCANNER_OPEN_WITH_SCAN_ARGS_SCAN:
      if (self->scan != NULL)
        g_object_unref (self->scan);
      self->scan = g_value_dup_object (value);
      self->__isset_scan = TRUE;
      break;

    case PROP_HBASE_SCANNER_OPEN_WITH_SCAN_ARGS_ATTRIBUTES:
      if (self->attributes != NULL)
        g_hash_table_unref (self->attributes);
      self->attributes = g_value_dup_boxed (value);
      self->__isset_attributes = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
hbase_scanner_open_with_scan_args_get_property (GObject *object,
                                                guint property_id,
                                                GValue *value,
                                                GParamSpec *pspec)
{
  HbaseScannerOpenWithScanArgs *self = HBASE_SCANNER_OPEN_WITH_SCAN_ARGS (object);

  switch (property_id)
  {
    case PROP_HBASE_SCANNER_OPEN_WITH_SCAN_ARGS_TABLE_NAME:
      g_value_set_boxed (value, self->tableName);
      break;

    case PROP_HBASE_SCANNER_OPEN_WITH_SCAN_ARGS_SCAN:
      g_value_set_object (value, self->scan);
      break;

    case PROP_HBASE_SCANNER_OPEN_WITH_SCAN_ARGS_ATTRIBUTES:
      g_value_set_boxed (value, self->attributes);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
hbase_scanner_open_with_scan_args_instance_init (HbaseScannerOpenWithScanArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->tableName = NULL;
  object->__isset_tableName = FALSE;
  object->scan = g_object_new (TYPE_T_SCAN, NULL);
  object->__isset_scan = FALSE;
  object->attributes = g_hash_table_new_full (g_str_hash, g_str_equal, thrift_string_free, thrift_string_free);
  object->__isset_attributes = FALSE;
}

static void 
hbase_scanner_open_with_scan_args_finalize (GObject *object)
{
  HbaseScannerOpenWithScanArgs *tobject = HBASE_SCANNER_OPEN_WITH_SCAN_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->tableName != NULL)
  {
    thrift_string_free(tobject->tableName);
    tobject->tableName = NULL;
  }
  if (tobject->scan != NULL)
  {
    g_object_unref(tobject->scan);
    tobject->scan = NULL;
  }
  if (tobject->attributes != NULL)
  {
    g_hash_table_destroy (tobject->attributes);
    tobject->attributes = NULL;
  }
}

static void
hbase_scanner_open_with_scan_args_class_init (HbaseScannerOpenWithScanArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = hbase_scanner_open_with_scan_args_read;
  struct_class->write = hbase_scanner_open_with_scan_args_write;

  gobject_class->finalize = hbase_scanner_open_with_scan_args_finalize;
  gobject_class->get_property = hbase_scanner_open_with_scan_args_get_property;
  gobject_class->set_property = hbase_scanner_open_with_scan_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_SCANNER_OPEN_WITH_SCAN_ARGS_TABLE_NAME,
     g_param_spec_boxed ("tableName",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_SCANNER_OPEN_WITH_SCAN_ARGS_SCAN,
     g_param_spec_object ("scan",
                         NULL,
                         NULL,
                         TYPE_T_SCAN,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_SCANNER_OPEN_WITH_SCAN_ARGS_ATTRIBUTES,
     g_param_spec_boxed ("attributes",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));
}

GType
hbase_scanner_open_with_scan_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (HbaseScannerOpenWithScanArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) hbase_scanner_open_with_scan_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (HbaseScannerOpenWithScanArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) hbase_scanner_open_with_scan_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "HbaseScannerOpenWithScanArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _HbaseScannerOpenWithScanResultProperties
{
  PROP_HBASE_SCANNER_OPEN_WITH_SCAN_RESULT_0,
  PROP_HBASE_SCANNER_OPEN_WITH_SCAN_RESULT_SUCCESS,
  PROP_HBASE_SCANNER_OPEN_WITH_SCAN_RESULT_IO
};

/* reads a hbase_scanner_open_with_scan_result object */
static gint32
hbase_scanner_open_with_scan_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  HbaseScannerOpenWithScanResult * this_object = HBASE_SCANNER_OPEN_WITH_SCAN_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->io != NULL)
          {
            g_object_unref (this_object->io);
          }
          this_object->io = g_object_new (TYPE_I_O_ERROR, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
          {
            g_object_unref (this_object->io);
            this_object->io = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_io = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
hbase_scanner_open_with_scan_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  HbaseScannerOpenWithScanResult * this_object = HBASE_SCANNER_OPEN_WITH_SCAN_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "HbaseScannerOpenWithScanResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I32, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->success, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_io == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "io", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
hbase_scanner_open_with_scan_result_set_property (GObject *object,
                                                  guint property_id,
                                                  const GValue *value,
                                                  GParamSpec *pspec)
{
  HbaseScannerOpenWithScanResult *self = HBASE_SCANNER_OPEN_WITH_SCAN_RESULT (object);

  switch (property_id)
  {
    case PROP_HBASE_SCANNER_OPEN_WITH_SCAN_RESULT_SUCCESS:
      self->success = g_value_get_int (value);
      self->__isset_success = TRUE;
      break;

    case PROP_HBASE_SCANNER_OPEN_WITH_SCAN_RESULT_IO:
      if (self->io != NULL)
        g_object_unref (self->io);
      self->io = g_value_dup_object (value);
      self->__isset_io = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
hbase_scanner_open_with_scan_result_get_property (GObject *object,
                                                  guint property_id,
                                                  GValue *value,
                                                  GParamSpec *pspec)
{
  HbaseScannerOpenWithScanResult *self = HBASE_SCANNER_OPEN_WITH_SCAN_RESULT (object);

  switch (property_id)
  {
    case PROP_HBASE_SCANNER_OPEN_WITH_SCAN_RESULT_SUCCESS:
      g_value_set_int (value, self->success);
      break;

    case PROP_HBASE_SCANNER_OPEN_WITH_SCAN_RESULT_IO:
      g_value_set_object (value, self->io);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
hbase_scanner_open_with_scan_result_instance_init (HbaseScannerOpenWithScanResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
  object->io = NULL;
  object->__isset_io = FALSE;
}

static void 
hbase_scanner_open_with_scan_result_finalize (GObject *object)
{
  HbaseScannerOpenWithScanResult *tobject = HBASE_SCANNER_OPEN_WITH_SCAN_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->io != NULL)
  {
    g_object_unref(tobject->io);
    tobject->io = NULL;
  }
}

static void
hbase_scanner_open_with_scan_result_class_init (HbaseScannerOpenWithScanResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = hbase_scanner_open_with_scan_result_read;
  struct_class->write = hbase_scanner_open_with_scan_result_write;

  gobject_class->finalize = hbase_scanner_open_with_scan_result_finalize;
  gobject_class->get_property = hbase_scanner_open_with_scan_result_get_property;
  gobject_class->set_property = hbase_scanner_open_with_scan_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_SCANNER_OPEN_WITH_SCAN_RESULT_SUCCESS,
     g_param_spec_int ("success",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_SCANNER_OPEN_WITH_SCAN_RESULT_IO,
     g_param_spec_object ("io",
                         NULL,
                         NULL,
                         TYPE_I_O_ERROR,
                         G_PARAM_READWRITE));
}

GType
hbase_scanner_open_with_scan_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (HbaseScannerOpenWithScanResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) hbase_scanner_open_with_scan_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (HbaseScannerOpenWithScanResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) hbase_scanner_open_with_scan_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "HbaseScannerOpenWithScanResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _HbaseScannerOpenArgsProperties
{
  PROP_HBASE_SCANNER_OPEN_ARGS_0,
  PROP_HBASE_SCANNER_OPEN_ARGS_TABLE_NAME,
  PROP_HBASE_SCANNER_OPEN_ARGS_START_ROW,
  PROP_HBASE_SCANNER_OPEN_ARGS_COLUMNS,
  PROP_HBASE_SCANNER_OPEN_ARGS_ATTRIBUTES
};

/* reads a hbase_scanner_open_args object */
static gint32
hbase_scanner_open_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  HbaseScannerOpenArgs * this_object = HBASE_SCANNER_OPEN_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->tableName != NULL)
          {
            g_free(this_object->tableName);
            this_object->tableName = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->tableName = g_byte_array_new();
          g_byte_array_append (this_object->tableName, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_tableName = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->startRow != NULL)
          {
            g_free(this_object->startRow);
            this_object->startRow = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->startRow = g_byte_array_new();
          g_byte_array_append (this_object->startRow, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_startRow = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              GByteArray * _elem152 = NULL;
              if (_elem152 != NULL)
              {
                g_free(_elem152);
                _elem152 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              _elem152 = g_byte_array_new();
              g_byte_array_append (_elem152, (guint8 *) data, (guint) len);
              g_free (data);
              g_ptr_array_add (this_object->columns, _elem152);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_columns = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              Text key153 = NULL;
              Text val154 = NULL;
              if (key153 != NULL)
              {
                g_free(key153);
                key153 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              key153 = g_byte_array_new();
              g_byte_array_append (key153, (guint8 *) data, (guint) len);
              g_free (data);
              if (val154 != NULL)
              {
                g_free(val154);
                val154 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              val154 = g_byte_array_new();
              g_byte_array_append (val154, (guint8 *) data, (guint) len);
              g_free (data);
              if (this_object->attributes && key153)
                g_hash_table_insert ((GHashTable *)this_object->attributes, (gpointer) key153, (gpointer) val154);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_attributes = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
hbase_scanner_open_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  HbaseScannerOpenArgs * this_object = HBASE_SCANNER_OPEN_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "HbaseScannerOpenArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "tableName", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->tableName ? ((GByteArray *) this_object->tableName)->data : NULL, this_object->tableName ? ((GByteArray *) this_object->tableName)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "startRow", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->startRow ? ((GByteArray *) this_object->startRow)->data : NULL, this_object->startRow ? ((GByteArray *) this_object->startRow)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "columns", T_LIST, 3, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i155;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (this_object->columns ? this_object->columns->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i155 = 0; i155 < (this_object->columns ? this_object->columns->len : 0); i155++)
    {
      if ((ret = thrift_protocol_write_binary (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->columns, i155)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->columns, i155)))->data : NULL, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->columns, i155)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->columns, i155)))->len : 0, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "attributes", T_MAP, 4, error)) < 0)
    return -1;
  xfer += ret;
  {
    Text key156 = NULL;
    Text val157 = NULL;
    GList *key_list = NULL, *iter = NULL;
    Text* keys;
    int i = 0, key_count;

    if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRING, this_object->attributes ? (gint32) g_hash_table_size ((GHashTable *) this_object->attributes) : 0, error)) < 0)
      return -1;
    xfer += ret;
    if (this_object->attributes)
      g_hash_table_foreach ((GHashTable *) this_object->attributes, thrift_hash_table_get_keys, &key_list);
    key_count = g_list_length (key_list);
    keys = g_newa (Text, key_count);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
      keys[i++] = (Text) iter->data;
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key156 = keys[i];
      val157 = (Text) g_hash_table_lookup (((GHashTable *) this_object->attributes), (gpointer) key156);

      if ((ret = thrift_protocol_write_binary (protocol,  key156 ? ((GByteArray *)  key156)->data : NULL,  key156 ? ((GByteArray *)  key156)->len : 0, error)) < 0)
        return -1;
      xfer += ret;

      if ((ret = thrift_protocol_write_binary (protocol,  val157 ? ((GByteArray *)  val157)->data : NULL,  val157 ? ((GByteArray *)  val157)->len : 0, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
hbase_scanner_open_args_set_property (GObject *object,
                                      guint property_id,
                                      const GValue *value,
                                      GParamSpec *pspec)
{
  HbaseScannerOpenArgs *self = HBASE_SCANNER_OPEN_ARGS (object);

  switch (property_id)
  {
    case PROP_HBASE_SCANNER_OPEN_ARGS_TABLE_NAME:
      if (self->tableName != NULL)
        g_byte_array_unref (self->tableName);
      self->tableName = g_value_dup_boxed (value);
      self->__isset_tableName = TRUE;
      break;

    case PROP_HBASE_SCANNER_OPEN_ARGS_START_ROW:
      if (self->startRow != NULL)
        g_byte_array_unref (self->startRow);
      self->startRow = g_value_dup_boxed (value);
      self->__isset_startRow = TRUE;
      break;

    case PROP_HBASE_SCANNER_OPEN_ARGS_COLUMNS:
      if (self->columns != NULL)
        g_ptr_array_unref (self->columns);
      self->columns = g_value_dup_boxed (value);
      self->__isset_columns = TRUE;
      break;

    case PROP_HBASE_SCANNER_OPEN_ARGS_ATTRIBUTES:
      if (self->attributes != NULL)
        g_hash_table_unref (self->attributes);
      self->attributes = g_value_dup_boxed (value);
      self->__isset_attributes = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
hbase_scanner_open_args_get_property (GObject *object,
                                      guint property_id,
                                      GValue *value,
                                      GParamSpec *pspec)
{
  HbaseScannerOpenArgs *self = HBASE_SCANNER_OPEN_ARGS (object);

  switch (property_id)
  {
    case PROP_HBASE_SCANNER_OPEN_ARGS_TABLE_NAME:
      g_value_set_boxed (value, self->tableName);
      break;

    case PROP_HBASE_SCANNER_OPEN_ARGS_START_ROW:
      g_value_set_boxed (value, self->startRow);
      break;

    case PROP_HBASE_SCANNER_OPEN_ARGS_COLUMNS:
      g_value_set_boxed (value, self->columns);
      break;

    case PROP_HBASE_SCANNER_OPEN_ARGS_ATTRIBUTES:
      g_value_set_boxed (value, self->attributes);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
hbase_scanner_open_args_instance_init (HbaseScannerOpenArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->tableName = NULL;
  object->__isset_tableName = FALSE;
  object->startRow = NULL;
  object->__isset_startRow = FALSE;
  object->columns = g_ptr_array_new_with_free_func (thrift_string_free);
  object->__isset_columns = FALSE;
  object->attributes = g_hash_table_new_full (g_str_hash, g_str_equal, thrift_string_free, thrift_string_free);
  object->__isset_attributes = FALSE;
}

static void 
hbase_scanner_open_args_finalize (GObject *object)
{
  HbaseScannerOpenArgs *tobject = HBASE_SCANNER_OPEN_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->tableName != NULL)
  {
    thrift_string_free(tobject->tableName);
    tobject->tableName = NULL;
  }
  if (tobject->startRow != NULL)
  {
    thrift_string_free(tobject->startRow);
    tobject->startRow = NULL;
  }
  if (tobject->columns != NULL)
  {
    g_ptr_array_unref (tobject->columns);
    tobject->columns = NULL;
  }
  if (tobject->attributes != NULL)
  {
    g_hash_table_destroy (tobject->attributes);
    tobject->attributes = NULL;
  }
}

static void
hbase_scanner_open_args_class_init (HbaseScannerOpenArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = hbase_scanner_open_args_read;
  struct_class->write = hbase_scanner_open_args_write;

  gobject_class->finalize = hbase_scanner_open_args_finalize;
  gobject_class->get_property = hbase_scanner_open_args_get_property;
  gobject_class->set_property = hbase_scanner_open_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_SCANNER_OPEN_ARGS_TABLE_NAME,
     g_param_spec_boxed ("tableName",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_SCANNER_OPEN_ARGS_START_ROW,
     g_param_spec_boxed ("startRow",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_SCANNER_OPEN_ARGS_COLUMNS,
     g_param_spec_boxed ("columns",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_SCANNER_OPEN_ARGS_ATTRIBUTES,
     g_param_spec_boxed ("attributes",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));
}

GType
hbase_scanner_open_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (HbaseScannerOpenArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) hbase_scanner_open_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (HbaseScannerOpenArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) hbase_scanner_open_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "HbaseScannerOpenArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _HbaseScannerOpenResultProperties
{
  PROP_HBASE_SCANNER_OPEN_RESULT_0,
  PROP_HBASE_SCANNER_OPEN_RESULT_SUCCESS,
  PROP_HBASE_SCANNER_OPEN_RESULT_IO
};

/* reads a hbase_scanner_open_result object */
static gint32
hbase_scanner_open_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  HbaseScannerOpenResult * this_object = HBASE_SCANNER_OPEN_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->io != NULL)
          {
            g_object_unref (this_object->io);
          }
          this_object->io = g_object_new (TYPE_I_O_ERROR, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
          {
            g_object_unref (this_object->io);
            this_object->io = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_io = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
hbase_scanner_open_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  HbaseScannerOpenResult * this_object = HBASE_SCANNER_OPEN_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "HbaseScannerOpenResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I32, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->success, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_io == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "io", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
hbase_scanner_open_result_set_property (GObject *object,
                                        guint property_id,
                                        const GValue *value,
                                        GParamSpec *pspec)
{
  HbaseScannerOpenResult *self = HBASE_SCANNER_OPEN_RESULT (object);

  switch (property_id)
  {
    case PROP_HBASE_SCANNER_OPEN_RESULT_SUCCESS:
      self->success = g_value_get_int (value);
      self->__isset_success = TRUE;
      break;

    case PROP_HBASE_SCANNER_OPEN_RESULT_IO:
      if (self->io != NULL)
        g_object_unref (self->io);
      self->io = g_value_dup_object (value);
      self->__isset_io = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
hbase_scanner_open_result_get_property (GObject *object,
                                        guint property_id,
                                        GValue *value,
                                        GParamSpec *pspec)
{
  HbaseScannerOpenResult *self = HBASE_SCANNER_OPEN_RESULT (object);

  switch (property_id)
  {
    case PROP_HBASE_SCANNER_OPEN_RESULT_SUCCESS:
      g_value_set_int (value, self->success);
      break;

    case PROP_HBASE_SCANNER_OPEN_RESULT_IO:
      g_value_set_object (value, self->io);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
hbase_scanner_open_result_instance_init (HbaseScannerOpenResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
  object->io = NULL;
  object->__isset_io = FALSE;
}

static void 
hbase_scanner_open_result_finalize (GObject *object)
{
  HbaseScannerOpenResult *tobject = HBASE_SCANNER_OPEN_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->io != NULL)
  {
    g_object_unref(tobject->io);
    tobject->io = NULL;
  }
}

static void
hbase_scanner_open_result_class_init (HbaseScannerOpenResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = hbase_scanner_open_result_read;
  struct_class->write = hbase_scanner_open_result_write;

  gobject_class->finalize = hbase_scanner_open_result_finalize;
  gobject_class->get_property = hbase_scanner_open_result_get_property;
  gobject_class->set_property = hbase_scanner_open_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_SCANNER_OPEN_RESULT_SUCCESS,
     g_param_spec_int ("success",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_SCANNER_OPEN_RESULT_IO,
     g_param_spec_object ("io",
                         NULL,
                         NULL,
                         TYPE_I_O_ERROR,
                         G_PARAM_READWRITE));
}

GType
hbase_scanner_open_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (HbaseScannerOpenResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) hbase_scanner_open_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (HbaseScannerOpenResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) hbase_scanner_open_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "HbaseScannerOpenResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _HbaseScannerOpenWithStopArgsProperties
{
  PROP_HBASE_SCANNER_OPEN_WITH_STOP_ARGS_0,
  PROP_HBASE_SCANNER_OPEN_WITH_STOP_ARGS_TABLE_NAME,
  PROP_HBASE_SCANNER_OPEN_WITH_STOP_ARGS_START_ROW,
  PROP_HBASE_SCANNER_OPEN_WITH_STOP_ARGS_STOP_ROW,
  PROP_HBASE_SCANNER_OPEN_WITH_STOP_ARGS_COLUMNS,
  PROP_HBASE_SCANNER_OPEN_WITH_STOP_ARGS_ATTRIBUTES
};

/* reads a hbase_scanner_open_with_stop_args object */
static gint32
hbase_scanner_open_with_stop_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  HbaseScannerOpenWithStopArgs * this_object = HBASE_SCANNER_OPEN_WITH_STOP_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->tableName != NULL)
          {
            g_free(this_object->tableName);
            this_object->tableName = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->tableName = g_byte_array_new();
          g_byte_array_append (this_object->tableName, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_tableName = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->startRow != NULL)
          {
            g_free(this_object->startRow);
            this_object->startRow = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->startRow = g_byte_array_new();
          g_byte_array_append (this_object->startRow, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_startRow = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if (this_object->stopRow != NULL)
          {
            g_free(this_object->stopRow);
            this_object->stopRow = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->stopRow = g_byte_array_new();
          g_byte_array_append (this_object->stopRow, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_stopRow = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              GByteArray * _elem158 = NULL;
              if (_elem158 != NULL)
              {
                g_free(_elem158);
                _elem158 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              _elem158 = g_byte_array_new();
              g_byte_array_append (_elem158, (guint8 *) data, (guint) len);
              g_free (data);
              g_ptr_array_add (this_object->columns, _elem158);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_columns = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              Text key159 = NULL;
              Text val160 = NULL;
              if (key159 != NULL)
              {
                g_free(key159);
                key159 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              key159 = g_byte_array_new();
              g_byte_array_append (key159, (guint8 *) data, (guint) len);
              g_free (data);
              if (val160 != NULL)
              {
                g_free(val160);
                val160 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              val160 = g_byte_array_new();
              g_byte_array_append (val160, (guint8 *) data, (guint) len);
              g_free (data);
              if (this_object->attributes && key159)
                g_hash_table_insert ((GHashTable *)this_object->attributes, (gpointer) key159, (gpointer) val160);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_attributes = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
hbase_scanner_open_with_stop_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  HbaseScannerOpenWithStopArgs * this_object = HBASE_SCANNER_OPEN_WITH_STOP_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "HbaseScannerOpenWithStopArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "tableName", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->tableName ? ((GByteArray *) this_object->tableName)->data : NULL, this_object->tableName ? ((GByteArray *) this_object->tableName)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "startRow", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->startRow ? ((GByteArray *) this_object->startRow)->data : NULL, this_object->startRow ? ((GByteArray *) this_object->startRow)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "stopRow", T_STRING, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->stopRow ? ((GByteArray *) this_object->stopRow)->data : NULL, this_object->stopRow ? ((GByteArray *) this_object->stopRow)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "columns", T_LIST, 4, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i161;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (this_object->columns ? this_object->columns->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i161 = 0; i161 < (this_object->columns ? this_object->columns->len : 0); i161++)
    {
      if ((ret = thrift_protocol_write_binary (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->columns, i161)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->columns, i161)))->data : NULL, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->columns, i161)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->columns, i161)))->len : 0, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "attributes", T_MAP, 5, error)) < 0)
    return -1;
  xfer += ret;
  {
    Text key162 = NULL;
    Text val163 = NULL;
    GList *key_list = NULL, *iter = NULL;
    Text* keys;
    int i = 0, key_count;

    if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRING, this_object->attributes ? (gint32) g_hash_table_size ((GHashTable *) this_object->attributes) : 0, error)) < 0)
      return -1;
    xfer += ret;
    if (this_object->attributes)
      g_hash_table_foreach ((GHashTable *) this_object->attributes, thrift_hash_table_get_keys, &key_list);
    key_count = g_list_length (key_list);
    keys = g_newa (Text, key_count);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
      keys[i++] = (Text) iter->data;
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key162 = keys[i];
      val163 = (Text) g_hash_table_lookup (((GHashTable *) this_object->attributes), (gpointer) key162);

      if ((ret = thrift_protocol_write_binary (protocol,  key162 ? ((GByteArray *)  key162)->data : NULL,  key162 ? ((GByteArray *)  key162)->len : 0, error)) < 0)
        return -1;
      xfer += ret;

      if ((ret = thrift_protocol_write_binary (protocol,  val163 ? ((GByteArray *)  val163)->data : NULL,  val163 ? ((GByteArray *)  val163)->len : 0, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
hbase_scanner_open_with_stop_args_set_property (GObject *object,
                                                guint property_id,
                                                const GValue *value,
                                                GParamSpec *pspec)
{
  HbaseScannerOpenWithStopArgs *self = HBASE_SCANNER_OPEN_WITH_STOP_ARGS (object);

  switch (property_id)
  {
    case PROP_HBASE_SCANNER_OPEN_WITH_STOP_ARGS_TABLE_NAME:
      if (self->tableName != NULL)
        g_byte_array_unref (self->tableName);
      self->tableName = g_value_dup_boxed (value);
      self->__isset_tableName = TRUE;
      break;

    case PROP_HBASE_SCANNER_OPEN_WITH_STOP_ARGS_START_ROW:
      if (self->startRow != NULL)
        g_byte_array_unref (self->startRow);
      self->startRow = g_value_dup_boxed (value);
      self->__isset_startRow = TRUE;
      break;

    case PROP_HBASE_SCANNER_OPEN_WITH_STOP_ARGS_STOP_ROW:
      if (self->stopRow != NULL)
        g_byte_array_unref (self->stopRow);
      self->stopRow = g_value_dup_boxed (value);
      self->__isset_stopRow = TRUE;
      break;

    case PROP_HBASE_SCANNER_OPEN_WITH_STOP_ARGS_COLUMNS:
      if (self->columns != NULL)
        g_ptr_array_unref (self->columns);
      self->columns = g_value_dup_boxed (value);
      self->__isset_columns = TRUE;
      break;

    case PROP_HBASE_SCANNER_OPEN_WITH_STOP_ARGS_ATTRIBUTES:
      if (self->attributes != NULL)
        g_hash_table_unref (self->attributes);
      self->attributes = g_value_dup_boxed (value);
      self->__isset_attributes = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
hbase_scanner_open_with_stop_args_get_property (GObject *object,
                                                guint property_id,
                                                GValue *value,
                                                GParamSpec *pspec)
{
  HbaseScannerOpenWithStopArgs *self = HBASE_SCANNER_OPEN_WITH_STOP_ARGS (object);

  switch (property_id)
  {
    case PROP_HBASE_SCANNER_OPEN_WITH_STOP_ARGS_TABLE_NAME:
      g_value_set_boxed (value, self->tableName);
      break;

    case PROP_HBASE_SCANNER_OPEN_WITH_STOP_ARGS_START_ROW:
      g_value_set_boxed (value, self->startRow);
      break;

    case PROP_HBASE_SCANNER_OPEN_WITH_STOP_ARGS_STOP_ROW:
      g_value_set_boxed (value, self->stopRow);
      break;

    case PROP_HBASE_SCANNER_OPEN_WITH_STOP_ARGS_COLUMNS:
      g_value_set_boxed (value, self->columns);
      break;

    case PROP_HBASE_SCANNER_OPEN_WITH_STOP_ARGS_ATTRIBUTES:
      g_value_set_boxed (value, self->attributes);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
hbase_scanner_open_with_stop_args_instance_init (HbaseScannerOpenWithStopArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->tableName = NULL;
  object->__isset_tableName = FALSE;
  object->startRow = NULL;
  object->__isset_startRow = FALSE;
  object->stopRow = NULL;
  object->__isset_stopRow = FALSE;
  object->columns = g_ptr_array_new_with_free_func (thrift_string_free);
  object->__isset_columns = FALSE;
  object->attributes = g_hash_table_new_full (g_str_hash, g_str_equal, thrift_string_free, thrift_string_free);
  object->__isset_attributes = FALSE;
}

static void 
hbase_scanner_open_with_stop_args_finalize (GObject *object)
{
  HbaseScannerOpenWithStopArgs *tobject = HBASE_SCANNER_OPEN_WITH_STOP_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->tableName != NULL)
  {
    thrift_string_free(tobject->tableName);
    tobject->tableName = NULL;
  }
  if (tobject->startRow != NULL)
  {
    thrift_string_free(tobject->startRow);
    tobject->startRow = NULL;
  }
  if (tobject->stopRow != NULL)
  {
    thrift_string_free(tobject->stopRow);
    tobject->stopRow = NULL;
  }
  if (tobject->columns != NULL)
  {
    g_ptr_array_unref (tobject->columns);
    tobject->columns = NULL;
  }
  if (tobject->attributes != NULL)
  {
    g_hash_table_destroy (tobject->attributes);
    tobject->attributes = NULL;
  }
}

static void
hbase_scanner_open_with_stop_args_class_init (HbaseScannerOpenWithStopArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = hbase_scanner_open_with_stop_args_read;
  struct_class->write = hbase_scanner_open_with_stop_args_write;

  gobject_class->finalize = hbase_scanner_open_with_stop_args_finalize;
  gobject_class->get_property = hbase_scanner_open_with_stop_args_get_property;
  gobject_class->set_property = hbase_scanner_open_with_stop_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_SCANNER_OPEN_WITH_STOP_ARGS_TABLE_NAME,
     g_param_spec_boxed ("tableName",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_SCANNER_OPEN_WITH_STOP_ARGS_START_ROW,
     g_param_spec_boxed ("startRow",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_SCANNER_OPEN_WITH_STOP_ARGS_STOP_ROW,
     g_param_spec_boxed ("stopRow",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_SCANNER_OPEN_WITH_STOP_ARGS_COLUMNS,
     g_param_spec_boxed ("columns",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_SCANNER_OPEN_WITH_STOP_ARGS_ATTRIBUTES,
     g_param_spec_boxed ("attributes",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));
}

GType
hbase_scanner_open_with_stop_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (HbaseScannerOpenWithStopArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) hbase_scanner_open_with_stop_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (HbaseScannerOpenWithStopArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) hbase_scanner_open_with_stop_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "HbaseScannerOpenWithStopArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _HbaseScannerOpenWithStopResultProperties
{
  PROP_HBASE_SCANNER_OPEN_WITH_STOP_RESULT_0,
  PROP_HBASE_SCANNER_OPEN_WITH_STOP_RESULT_SUCCESS,
  PROP_HBASE_SCANNER_OPEN_WITH_STOP_RESULT_IO
};

/* reads a hbase_scanner_open_with_stop_result object */
static gint32
hbase_scanner_open_with_stop_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  HbaseScannerOpenWithStopResult * this_object = HBASE_SCANNER_OPEN_WITH_STOP_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->io != NULL)
          {
            g_object_unref (this_object->io);
          }
          this_object->io = g_object_new (TYPE_I_O_ERROR, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
          {
            g_object_unref (this_object->io);
            this_object->io = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_io = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
hbase_scanner_open_with_stop_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  HbaseScannerOpenWithStopResult * this_object = HBASE_SCANNER_OPEN_WITH_STOP_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "HbaseScannerOpenWithStopResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I32, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->success, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_io == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "io", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
hbase_scanner_open_with_stop_result_set_property (GObject *object,
                                                  guint property_id,
                                                  const GValue *value,
                                                  GParamSpec *pspec)
{
  HbaseScannerOpenWithStopResult *self = HBASE_SCANNER_OPEN_WITH_STOP_RESULT (object);

  switch (property_id)
  {
    case PROP_HBASE_SCANNER_OPEN_WITH_STOP_RESULT_SUCCESS:
      self->success = g_value_get_int (value);
      self->__isset_success = TRUE;
      break;

    case PROP_HBASE_SCANNER_OPEN_WITH_STOP_RESULT_IO:
      if (self->io != NULL)
        g_object_unref (self->io);
      self->io = g_value_dup_object (value);
      self->__isset_io = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
hbase_scanner_open_with_stop_result_get_property (GObject *object,
                                                  guint property_id,
                                                  GValue *value,
                                                  GParamSpec *pspec)
{
  HbaseScannerOpenWithStopResult *self = HBASE_SCANNER_OPEN_WITH_STOP_RESULT (object);

  switch (property_id)
  {
    case PROP_HBASE_SCANNER_OPEN_WITH_STOP_RESULT_SUCCESS:
      g_value_set_int (value, self->success);
      break;

    case PROP_HBASE_SCANNER_OPEN_WITH_STOP_RESULT_IO:
      g_value_set_object (value, self->io);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
hbase_scanner_open_with_stop_result_instance_init (HbaseScannerOpenWithStopResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
  object->io = NULL;
  object->__isset_io = FALSE;
}

static void 
hbase_scanner_open_with_stop_result_finalize (GObject *object)
{
  HbaseScannerOpenWithStopResult *tobject = HBASE_SCANNER_OPEN_WITH_STOP_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->io != NULL)
  {
    g_object_unref(tobject->io);
    tobject->io = NULL;
  }
}

static void
hbase_scanner_open_with_stop_result_class_init (HbaseScannerOpenWithStopResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = hbase_scanner_open_with_stop_result_read;
  struct_class->write = hbase_scanner_open_with_stop_result_write;

  gobject_class->finalize = hbase_scanner_open_with_stop_result_finalize;
  gobject_class->get_property = hbase_scanner_open_with_stop_result_get_property;
  gobject_class->set_property = hbase_scanner_open_with_stop_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_SCANNER_OPEN_WITH_STOP_RESULT_SUCCESS,
     g_param_spec_int ("success",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_SCANNER_OPEN_WITH_STOP_RESULT_IO,
     g_param_spec_object ("io",
                         NULL,
                         NULL,
                         TYPE_I_O_ERROR,
                         G_PARAM_READWRITE));
}

GType
hbase_scanner_open_with_stop_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (HbaseScannerOpenWithStopResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) hbase_scanner_open_with_stop_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (HbaseScannerOpenWithStopResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) hbase_scanner_open_with_stop_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "HbaseScannerOpenWithStopResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _HbaseScannerOpenWithPrefixArgsProperties
{
  PROP_HBASE_SCANNER_OPEN_WITH_PREFIX_ARGS_0,
  PROP_HBASE_SCANNER_OPEN_WITH_PREFIX_ARGS_TABLE_NAME,
  PROP_HBASE_SCANNER_OPEN_WITH_PREFIX_ARGS_START_AND_PREFIX,
  PROP_HBASE_SCANNER_OPEN_WITH_PREFIX_ARGS_COLUMNS,
  PROP_HBASE_SCANNER_OPEN_WITH_PREFIX_ARGS_ATTRIBUTES
};

/* reads a hbase_scanner_open_with_prefix_args object */
static gint32
hbase_scanner_open_with_prefix_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  HbaseScannerOpenWithPrefixArgs * this_object = HBASE_SCANNER_OPEN_WITH_PREFIX_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->tableName != NULL)
          {
            g_free(this_object->tableName);
            this_object->tableName = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->tableName = g_byte_array_new();
          g_byte_array_append (this_object->tableName, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_tableName = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->startAndPrefix != NULL)
          {
            g_free(this_object->startAndPrefix);
            this_object->startAndPrefix = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->startAndPrefix = g_byte_array_new();
          g_byte_array_append (this_object->startAndPrefix, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_startAndPrefix = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              GByteArray * _elem164 = NULL;
              if (_elem164 != NULL)
              {
                g_free(_elem164);
                _elem164 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              _elem164 = g_byte_array_new();
              g_byte_array_append (_elem164, (guint8 *) data, (guint) len);
              g_free (data);
              g_ptr_array_add (this_object->columns, _elem164);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_columns = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              Text key165 = NULL;
              Text val166 = NULL;
              if (key165 != NULL)
              {
                g_free(key165);
                key165 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              key165 = g_byte_array_new();
              g_byte_array_append (key165, (guint8 *) data, (guint) len);
              g_free (data);
              if (val166 != NULL)
              {
                g_free(val166);
                val166 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              val166 = g_byte_array_new();
              g_byte_array_append (val166, (guint8 *) data, (guint) len);
              g_free (data);
              if (this_object->attributes && key165)
                g_hash_table_insert ((GHashTable *)this_object->attributes, (gpointer) key165, (gpointer) val166);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_attributes = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
hbase_scanner_open_with_prefix_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  HbaseScannerOpenWithPrefixArgs * this_object = HBASE_SCANNER_OPEN_WITH_PREFIX_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "HbaseScannerOpenWithPrefixArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "tableName", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->tableName ? ((GByteArray *) this_object->tableName)->data : NULL, this_object->tableName ? ((GByteArray *) this_object->tableName)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "startAndPrefix", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->startAndPrefix ? ((GByteArray *) this_object->startAndPrefix)->data : NULL, this_object->startAndPrefix ? ((GByteArray *) this_object->startAndPrefix)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "columns", T_LIST, 3, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i167;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (this_object->columns ? this_object->columns->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i167 = 0; i167 < (this_object->columns ? this_object->columns->len : 0); i167++)
    {
      if ((ret = thrift_protocol_write_binary (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->columns, i167)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->columns, i167)))->data : NULL, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->columns, i167)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->columns, i167)))->len : 0, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "attributes", T_MAP, 4, error)) < 0)
    return -1;
  xfer += ret;
  {
    Text key168 = NULL;
    Text val169 = NULL;
    GList *key_list = NULL, *iter = NULL;
    Text* keys;
    int i = 0, key_count;

    if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRING, this_object->attributes ? (gint32) g_hash_table_size ((GHashTable *) this_object->attributes) : 0, error)) < 0)
      return -1;
    xfer += ret;
    if (this_object->attributes)
      g_hash_table_foreach ((GHashTable *) this_object->attributes, thrift_hash_table_get_keys, &key_list);
    key_count = g_list_length (key_list);
    keys = g_newa (Text, key_count);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
      keys[i++] = (Text) iter->data;
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key168 = keys[i];
      val169 = (Text) g_hash_table_lookup (((GHashTable *) this_object->attributes), (gpointer) key168);

      if ((ret = thrift_protocol_write_binary (protocol,  key168 ? ((GByteArray *)  key168)->data : NULL,  key168 ? ((GByteArray *)  key168)->len : 0, error)) < 0)
        return -1;
      xfer += ret;

      if ((ret = thrift_protocol_write_binary (protocol,  val169 ? ((GByteArray *)  val169)->data : NULL,  val169 ? ((GByteArray *)  val169)->len : 0, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
hbase_scanner_open_with_prefix_args_set_property (GObject *object,
                                                  guint property_id,
                                                  const GValue *value,
                                                  GParamSpec *pspec)
{
  HbaseScannerOpenWithPrefixArgs *self = HBASE_SCANNER_OPEN_WITH_PREFIX_ARGS (object);

  switch (property_id)
  {
    case PROP_HBASE_SCANNER_OPEN_WITH_PREFIX_ARGS_TABLE_NAME:
      if (self->tableName != NULL)
        g_byte_array_unref (self->tableName);
      self->tableName = g_value_dup_boxed (value);
      self->__isset_tableName = TRUE;
      break;

    case PROP_HBASE_SCANNER_OPEN_WITH_PREFIX_ARGS_START_AND_PREFIX:
      if (self->startAndPrefix != NULL)
        g_byte_array_unref (self->startAndPrefix);
      self->startAndPrefix = g_value_dup_boxed (value);
      self->__isset_startAndPrefix = TRUE;
      break;

    case PROP_HBASE_SCANNER_OPEN_WITH_PREFIX_ARGS_COLUMNS:
      if (self->columns != NULL)
        g_ptr_array_unref (self->columns);
      self->columns = g_value_dup_boxed (value);
      self->__isset_columns = TRUE;
      break;

    case PROP_HBASE_SCANNER_OPEN_WITH_PREFIX_ARGS_ATTRIBUTES:
      if (self->attributes != NULL)
        g_hash_table_unref (self->attributes);
      self->attributes = g_value_dup_boxed (value);
      self->__isset_attributes = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
hbase_scanner_open_with_prefix_args_get_property (GObject *object,
                                                  guint property_id,
                                                  GValue *value,
                                                  GParamSpec *pspec)
{
  HbaseScannerOpenWithPrefixArgs *self = HBASE_SCANNER_OPEN_WITH_PREFIX_ARGS (object);

  switch (property_id)
  {
    case PROP_HBASE_SCANNER_OPEN_WITH_PREFIX_ARGS_TABLE_NAME:
      g_value_set_boxed (value, self->tableName);
      break;

    case PROP_HBASE_SCANNER_OPEN_WITH_PREFIX_ARGS_START_AND_PREFIX:
      g_value_set_boxed (value, self->startAndPrefix);
      break;

    case PROP_HBASE_SCANNER_OPEN_WITH_PREFIX_ARGS_COLUMNS:
      g_value_set_boxed (value, self->columns);
      break;

    case PROP_HBASE_SCANNER_OPEN_WITH_PREFIX_ARGS_ATTRIBUTES:
      g_value_set_boxed (value, self->attributes);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
hbase_scanner_open_with_prefix_args_instance_init (HbaseScannerOpenWithPrefixArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->tableName = NULL;
  object->__isset_tableName = FALSE;
  object->startAndPrefix = NULL;
  object->__isset_startAndPrefix = FALSE;
  object->columns = g_ptr_array_new_with_free_func (thrift_string_free);
  object->__isset_columns = FALSE;
  object->attributes = g_hash_table_new_full (g_str_hash, g_str_equal, thrift_string_free, thrift_string_free);
  object->__isset_attributes = FALSE;
}

static void 
hbase_scanner_open_with_prefix_args_finalize (GObject *object)
{
  HbaseScannerOpenWithPrefixArgs *tobject = HBASE_SCANNER_OPEN_WITH_PREFIX_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->tableName != NULL)
  {
    thrift_string_free(tobject->tableName);
    tobject->tableName = NULL;
  }
  if (tobject->startAndPrefix != NULL)
  {
    thrift_string_free(tobject->startAndPrefix);
    tobject->startAndPrefix = NULL;
  }
  if (tobject->columns != NULL)
  {
    g_ptr_array_unref (tobject->columns);
    tobject->columns = NULL;
  }
  if (tobject->attributes != NULL)
  {
    g_hash_table_destroy (tobject->attributes);
    tobject->attributes = NULL;
  }
}

static void
hbase_scanner_open_with_prefix_args_class_init (HbaseScannerOpenWithPrefixArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = hbase_scanner_open_with_prefix_args_read;
  struct_class->write = hbase_scanner_open_with_prefix_args_write;

  gobject_class->finalize = hbase_scanner_open_with_prefix_args_finalize;
  gobject_class->get_property = hbase_scanner_open_with_prefix_args_get_property;
  gobject_class->set_property = hbase_scanner_open_with_prefix_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_SCANNER_OPEN_WITH_PREFIX_ARGS_TABLE_NAME,
     g_param_spec_boxed ("tableName",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_SCANNER_OPEN_WITH_PREFIX_ARGS_START_AND_PREFIX,
     g_param_spec_boxed ("startAndPrefix",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_SCANNER_OPEN_WITH_PREFIX_ARGS_COLUMNS,
     g_param_spec_boxed ("columns",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_SCANNER_OPEN_WITH_PREFIX_ARGS_ATTRIBUTES,
     g_param_spec_boxed ("attributes",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));
}

GType
hbase_scanner_open_with_prefix_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (HbaseScannerOpenWithPrefixArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) hbase_scanner_open_with_prefix_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (HbaseScannerOpenWithPrefixArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) hbase_scanner_open_with_prefix_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "HbaseScannerOpenWithPrefixArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _HbaseScannerOpenWithPrefixResultProperties
{
  PROP_HBASE_SCANNER_OPEN_WITH_PREFIX_RESULT_0,
  PROP_HBASE_SCANNER_OPEN_WITH_PREFIX_RESULT_SUCCESS,
  PROP_HBASE_SCANNER_OPEN_WITH_PREFIX_RESULT_IO
};

/* reads a hbase_scanner_open_with_prefix_result object */
static gint32
hbase_scanner_open_with_prefix_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  HbaseScannerOpenWithPrefixResult * this_object = HBASE_SCANNER_OPEN_WITH_PREFIX_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->io != NULL)
          {
            g_object_unref (this_object->io);
          }
          this_object->io = g_object_new (TYPE_I_O_ERROR, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
          {
            g_object_unref (this_object->io);
            this_object->io = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_io = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
hbase_scanner_open_with_prefix_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  HbaseScannerOpenWithPrefixResult * this_object = HBASE_SCANNER_OPEN_WITH_PREFIX_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "HbaseScannerOpenWithPrefixResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I32, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->success, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_io == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "io", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
hbase_scanner_open_with_prefix_result_set_property (GObject *object,
                                                    guint property_id,
                                                    const GValue *value,
                                                    GParamSpec *pspec)
{
  HbaseScannerOpenWithPrefixResult *self = HBASE_SCANNER_OPEN_WITH_PREFIX_RESULT (object);

  switch (property_id)
  {
    case PROP_HBASE_SCANNER_OPEN_WITH_PREFIX_RESULT_SUCCESS:
      self->success = g_value_get_int (value);
      self->__isset_success = TRUE;
      break;

    case PROP_HBASE_SCANNER_OPEN_WITH_PREFIX_RESULT_IO:
      if (self->io != NULL)
        g_object_unref (self->io);
      self->io = g_value_dup_object (value);
      self->__isset_io = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
hbase_scanner_open_with_prefix_result_get_property (GObject *object,
                                                    guint property_id,
                                                    GValue *value,
                                                    GParamSpec *pspec)
{
  HbaseScannerOpenWithPrefixResult *self = HBASE_SCANNER_OPEN_WITH_PREFIX_RESULT (object);

  switch (property_id)
  {
    case PROP_HBASE_SCANNER_OPEN_WITH_PREFIX_RESULT_SUCCESS:
      g_value_set_int (value, self->success);
      break;

    case PROP_HBASE_SCANNER_OPEN_WITH_PREFIX_RESULT_IO:
      g_value_set_object (value, self->io);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
hbase_scanner_open_with_prefix_result_instance_init (HbaseScannerOpenWithPrefixResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
  object->io = NULL;
  object->__isset_io = FALSE;
}

static void 
hbase_scanner_open_with_prefix_result_finalize (GObject *object)
{
  HbaseScannerOpenWithPrefixResult *tobject = HBASE_SCANNER_OPEN_WITH_PREFIX_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->io != NULL)
  {
    g_object_unref(tobject->io);
    tobject->io = NULL;
  }
}

static void
hbase_scanner_open_with_prefix_result_class_init (HbaseScannerOpenWithPrefixResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = hbase_scanner_open_with_prefix_result_read;
  struct_class->write = hbase_scanner_open_with_prefix_result_write;

  gobject_class->finalize = hbase_scanner_open_with_prefix_result_finalize;
  gobject_class->get_property = hbase_scanner_open_with_prefix_result_get_property;
  gobject_class->set_property = hbase_scanner_open_with_prefix_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_SCANNER_OPEN_WITH_PREFIX_RESULT_SUCCESS,
     g_param_spec_int ("success",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_SCANNER_OPEN_WITH_PREFIX_RESULT_IO,
     g_param_spec_object ("io",
                         NULL,
                         NULL,
                         TYPE_I_O_ERROR,
                         G_PARAM_READWRITE));
}

GType
hbase_scanner_open_with_prefix_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (HbaseScannerOpenWithPrefixResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) hbase_scanner_open_with_prefix_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (HbaseScannerOpenWithPrefixResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) hbase_scanner_open_with_prefix_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "HbaseScannerOpenWithPrefixResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _HbaseScannerOpenTsArgsProperties
{
  PROP_HBASE_SCANNER_OPEN_TS_ARGS_0,
  PROP_HBASE_SCANNER_OPEN_TS_ARGS_TABLE_NAME,
  PROP_HBASE_SCANNER_OPEN_TS_ARGS_START_ROW,
  PROP_HBASE_SCANNER_OPEN_TS_ARGS_COLUMNS,
  PROP_HBASE_SCANNER_OPEN_TS_ARGS_TIMESTAMP,
  PROP_HBASE_SCANNER_OPEN_TS_ARGS_ATTRIBUTES
};

/* reads a hbase_scanner_open_ts_args object */
static gint32
hbase_scanner_open_ts_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  HbaseScannerOpenTsArgs * this_object = HBASE_SCANNER_OPEN_TS_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->tableName != NULL)
          {
            g_free(this_object->tableName);
            this_object->tableName = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->tableName = g_byte_array_new();
          g_byte_array_append (this_object->tableName, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_tableName = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->startRow != NULL)
          {
            g_free(this_object->startRow);
            this_object->startRow = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->startRow = g_byte_array_new();
          g_byte_array_append (this_object->startRow, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_startRow = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              GByteArray * _elem170 = NULL;
              if (_elem170 != NULL)
              {
                g_free(_elem170);
                _elem170 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              _elem170 = g_byte_array_new();
              g_byte_array_append (_elem170, (guint8 *) data, (guint) len);
              g_free (data);
              g_ptr_array_add (this_object->columns, _elem170);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_columns = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->timestamp, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_timestamp = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              Text key171 = NULL;
              Text val172 = NULL;
              if (key171 != NULL)
              {
                g_free(key171);
                key171 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              key171 = g_byte_array_new();
              g_byte_array_append (key171, (guint8 *) data, (guint) len);
              g_free (data);
              if (val172 != NULL)
              {
                g_free(val172);
                val172 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              val172 = g_byte_array_new();
              g_byte_array_append (val172, (guint8 *) data, (guint) len);
              g_free (data);
              if (this_object->attributes && key171)
                g_hash_table_insert ((GHashTable *)this_object->attributes, (gpointer) key171, (gpointer) val172);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_attributes = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
hbase_scanner_open_ts_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  HbaseScannerOpenTsArgs * this_object = HBASE_SCANNER_OPEN_TS_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "HbaseScannerOpenTsArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "tableName", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->tableName ? ((GByteArray *) this_object->tableName)->data : NULL, this_object->tableName ? ((GByteArray *) this_object->tableName)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "startRow", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->startRow ? ((GByteArray *) this_object->startRow)->data : NULL, this_object->startRow ? ((GByteArray *) this_object->startRow)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "columns", T_LIST, 3, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i173;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (this_object->columns ? this_object->columns->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i173 = 0; i173 < (this_object->columns ? this_object->columns->len : 0); i173++)
    {
      if ((ret = thrift_protocol_write_binary (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->columns, i173)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->columns, i173)))->data : NULL, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->columns, i173)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->columns, i173)))->len : 0, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "timestamp", T_I64, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->timestamp, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "attributes", T_MAP, 5, error)) < 0)
    return -1;
  xfer += ret;
  {
    Text key174 = NULL;
    Text val175 = NULL;
    GList *key_list = NULL, *iter = NULL;
    Text* keys;
    int i = 0, key_count;

    if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRING, this_object->attributes ? (gint32) g_hash_table_size ((GHashTable *) this_object->attributes) : 0, error)) < 0)
      return -1;
    xfer += ret;
    if (this_object->attributes)
      g_hash_table_foreach ((GHashTable *) this_object->attributes, thrift_hash_table_get_keys, &key_list);
    key_count = g_list_length (key_list);
    keys = g_newa (Text, key_count);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
      keys[i++] = (Text) iter->data;
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key174 = keys[i];
      val175 = (Text) g_hash_table_lookup (((GHashTable *) this_object->attributes), (gpointer) key174);

      if ((ret = thrift_protocol_write_binary (protocol,  key174 ? ((GByteArray *)  key174)->data : NULL,  key174 ? ((GByteArray *)  key174)->len : 0, error)) < 0)
        return -1;
      xfer += ret;

      if ((ret = thrift_protocol_write_binary (protocol,  val175 ? ((GByteArray *)  val175)->data : NULL,  val175 ? ((GByteArray *)  val175)->len : 0, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
hbase_scanner_open_ts_args_set_property (GObject *object,
                                         guint property_id,
                                         const GValue *value,
                                         GParamSpec *pspec)
{
  HbaseScannerOpenTsArgs *self = HBASE_SCANNER_OPEN_TS_ARGS (object);

  switch (property_id)
  {
    case PROP_HBASE_SCANNER_OPEN_TS_ARGS_TABLE_NAME:
      if (self->tableName != NULL)
        g_byte_array_unref (self->tableName);
      self->tableName = g_value_dup_boxed (value);
      self->__isset_tableName = TRUE;
      break;

    case PROP_HBASE_SCANNER_OPEN_TS_ARGS_START_ROW:
      if (self->startRow != NULL)
        g_byte_array_unref (self->startRow);
      self->startRow = g_value_dup_boxed (value);
      self->__isset_startRow = TRUE;
      break;

    case PROP_HBASE_SCANNER_OPEN_TS_ARGS_COLUMNS:
      if (self->columns != NULL)
        g_ptr_array_unref (self->columns);
      self->columns = g_value_dup_boxed (value);
      self->__isset_columns = TRUE;
      break;

    case PROP_HBASE_SCANNER_OPEN_TS_ARGS_TIMESTAMP:
      self->timestamp = g_value_get_int64 (value);
      self->__isset_timestamp = TRUE;
      break;

    case PROP_HBASE_SCANNER_OPEN_TS_ARGS_ATTRIBUTES:
      if (self->attributes != NULL)
        g_hash_table_unref (self->attributes);
      self->attributes = g_value_dup_boxed (value);
      self->__isset_attributes = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
hbase_scanner_open_ts_args_get_property (GObject *object,
                                         guint property_id,
                                         GValue *value,
                                         GParamSpec *pspec)
{
  HbaseScannerOpenTsArgs *self = HBASE_SCANNER_OPEN_TS_ARGS (object);

  switch (property_id)
  {
    case PROP_HBASE_SCANNER_OPEN_TS_ARGS_TABLE_NAME:
      g_value_set_boxed (value, self->tableName);
      break;

    case PROP_HBASE_SCANNER_OPEN_TS_ARGS_START_ROW:
      g_value_set_boxed (value, self->startRow);
      break;

    case PROP_HBASE_SCANNER_OPEN_TS_ARGS_COLUMNS:
      g_value_set_boxed (value, self->columns);
      break;

    case PROP_HBASE_SCANNER_OPEN_TS_ARGS_TIMESTAMP:
      g_value_set_int64 (value, self->timestamp);
      break;

    case PROP_HBASE_SCANNER_OPEN_TS_ARGS_ATTRIBUTES:
      g_value_set_boxed (value, self->attributes);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
hbase_scanner_open_ts_args_instance_init (HbaseScannerOpenTsArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->tableName = NULL;
  object->__isset_tableName = FALSE;
  object->startRow = NULL;
  object->__isset_startRow = FALSE;
  object->columns = g_ptr_array_new_with_free_func (thrift_string_free);
  object->__isset_columns = FALSE;
  object->timestamp = 0;
  object->__isset_timestamp = FALSE;
  object->attributes = g_hash_table_new_full (g_str_hash, g_str_equal, thrift_string_free, thrift_string_free);
  object->__isset_attributes = FALSE;
}

static void 
hbase_scanner_open_ts_args_finalize (GObject *object)
{
  HbaseScannerOpenTsArgs *tobject = HBASE_SCANNER_OPEN_TS_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->tableName != NULL)
  {
    thrift_string_free(tobject->tableName);
    tobject->tableName = NULL;
  }
  if (tobject->startRow != NULL)
  {
    thrift_string_free(tobject->startRow);
    tobject->startRow = NULL;
  }
  if (tobject->columns != NULL)
  {
    g_ptr_array_unref (tobject->columns);
    tobject->columns = NULL;
  }
  if (tobject->attributes != NULL)
  {
    g_hash_table_destroy (tobject->attributes);
    tobject->attributes = NULL;
  }
}

static void
hbase_scanner_open_ts_args_class_init (HbaseScannerOpenTsArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = hbase_scanner_open_ts_args_read;
  struct_class->write = hbase_scanner_open_ts_args_write;

  gobject_class->finalize = hbase_scanner_open_ts_args_finalize;
  gobject_class->get_property = hbase_scanner_open_ts_args_get_property;
  gobject_class->set_property = hbase_scanner_open_ts_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_SCANNER_OPEN_TS_ARGS_TABLE_NAME,
     g_param_spec_boxed ("tableName",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_SCANNER_OPEN_TS_ARGS_START_ROW,
     g_param_spec_boxed ("startRow",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_SCANNER_OPEN_TS_ARGS_COLUMNS,
     g_param_spec_boxed ("columns",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_SCANNER_OPEN_TS_ARGS_TIMESTAMP,
     g_param_spec_int64 ("timestamp",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_SCANNER_OPEN_TS_ARGS_ATTRIBUTES,
     g_param_spec_boxed ("attributes",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));
}

GType
hbase_scanner_open_ts_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (HbaseScannerOpenTsArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) hbase_scanner_open_ts_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (HbaseScannerOpenTsArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) hbase_scanner_open_ts_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "HbaseScannerOpenTsArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _HbaseScannerOpenTsResultProperties
{
  PROP_HBASE_SCANNER_OPEN_TS_RESULT_0,
  PROP_HBASE_SCANNER_OPEN_TS_RESULT_SUCCESS,
  PROP_HBASE_SCANNER_OPEN_TS_RESULT_IO
};

/* reads a hbase_scanner_open_ts_result object */
static gint32
hbase_scanner_open_ts_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  HbaseScannerOpenTsResult * this_object = HBASE_SCANNER_OPEN_TS_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->io != NULL)
          {
            g_object_unref (this_object->io);
          }
          this_object->io = g_object_new (TYPE_I_O_ERROR, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
          {
            g_object_unref (this_object->io);
            this_object->io = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_io = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
hbase_scanner_open_ts_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  HbaseScannerOpenTsResult * this_object = HBASE_SCANNER_OPEN_TS_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "HbaseScannerOpenTsResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I32, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->success, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_io == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "io", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
hbase_scanner_open_ts_result_set_property (GObject *object,
                                           guint property_id,
                                           const GValue *value,
                                           GParamSpec *pspec)
{
  HbaseScannerOpenTsResult *self = HBASE_SCANNER_OPEN_TS_RESULT (object);

  switch (property_id)
  {
    case PROP_HBASE_SCANNER_OPEN_TS_RESULT_SUCCESS:
      self->success = g_value_get_int (value);
      self->__isset_success = TRUE;
      break;

    case PROP_HBASE_SCANNER_OPEN_TS_RESULT_IO:
      if (self->io != NULL)
        g_object_unref (self->io);
      self->io = g_value_dup_object (value);
      self->__isset_io = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
hbase_scanner_open_ts_result_get_property (GObject *object,
                                           guint property_id,
                                           GValue *value,
                                           GParamSpec *pspec)
{
  HbaseScannerOpenTsResult *self = HBASE_SCANNER_OPEN_TS_RESULT (object);

  switch (property_id)
  {
    case PROP_HBASE_SCANNER_OPEN_TS_RESULT_SUCCESS:
      g_value_set_int (value, self->success);
      break;

    case PROP_HBASE_SCANNER_OPEN_TS_RESULT_IO:
      g_value_set_object (value, self->io);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
hbase_scanner_open_ts_result_instance_init (HbaseScannerOpenTsResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
  object->io = NULL;
  object->__isset_io = FALSE;
}

static void 
hbase_scanner_open_ts_result_finalize (GObject *object)
{
  HbaseScannerOpenTsResult *tobject = HBASE_SCANNER_OPEN_TS_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->io != NULL)
  {
    g_object_unref(tobject->io);
    tobject->io = NULL;
  }
}

static void
hbase_scanner_open_ts_result_class_init (HbaseScannerOpenTsResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = hbase_scanner_open_ts_result_read;
  struct_class->write = hbase_scanner_open_ts_result_write;

  gobject_class->finalize = hbase_scanner_open_ts_result_finalize;
  gobject_class->get_property = hbase_scanner_open_ts_result_get_property;
  gobject_class->set_property = hbase_scanner_open_ts_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_SCANNER_OPEN_TS_RESULT_SUCCESS,
     g_param_spec_int ("success",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_SCANNER_OPEN_TS_RESULT_IO,
     g_param_spec_object ("io",
                         NULL,
                         NULL,
                         TYPE_I_O_ERROR,
                         G_PARAM_READWRITE));
}

GType
hbase_scanner_open_ts_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (HbaseScannerOpenTsResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) hbase_scanner_open_ts_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (HbaseScannerOpenTsResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) hbase_scanner_open_ts_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "HbaseScannerOpenTsResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _HbaseScannerOpenWithStopTsArgsProperties
{
  PROP_HBASE_SCANNER_OPEN_WITH_STOP_TS_ARGS_0,
  PROP_HBASE_SCANNER_OPEN_WITH_STOP_TS_ARGS_TABLE_NAME,
  PROP_HBASE_SCANNER_OPEN_WITH_STOP_TS_ARGS_START_ROW,
  PROP_HBASE_SCANNER_OPEN_WITH_STOP_TS_ARGS_STOP_ROW,
  PROP_HBASE_SCANNER_OPEN_WITH_STOP_TS_ARGS_COLUMNS,
  PROP_HBASE_SCANNER_OPEN_WITH_STOP_TS_ARGS_TIMESTAMP,
  PROP_HBASE_SCANNER_OPEN_WITH_STOP_TS_ARGS_ATTRIBUTES
};

/* reads a hbase_scanner_open_with_stop_ts_args object */
static gint32
hbase_scanner_open_with_stop_ts_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  HbaseScannerOpenWithStopTsArgs * this_object = HBASE_SCANNER_OPEN_WITH_STOP_TS_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->tableName != NULL)
          {
            g_free(this_object->tableName);
            this_object->tableName = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->tableName = g_byte_array_new();
          g_byte_array_append (this_object->tableName, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_tableName = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->startRow != NULL)
          {
            g_free(this_object->startRow);
            this_object->startRow = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->startRow = g_byte_array_new();
          g_byte_array_append (this_object->startRow, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_startRow = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if (this_object->stopRow != NULL)
          {
            g_free(this_object->stopRow);
            this_object->stopRow = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->stopRow = g_byte_array_new();
          g_byte_array_append (this_object->stopRow, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_stopRow = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              GByteArray * _elem176 = NULL;
              if (_elem176 != NULL)
              {
                g_free(_elem176);
                _elem176 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              _elem176 = g_byte_array_new();
              g_byte_array_append (_elem176, (guint8 *) data, (guint) len);
              g_free (data);
              g_ptr_array_add (this_object->columns, _elem176);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_columns = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->timestamp, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_timestamp = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              Text key177 = NULL;
              Text val178 = NULL;
              if (key177 != NULL)
              {
                g_free(key177);
                key177 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              key177 = g_byte_array_new();
              g_byte_array_append (key177, (guint8 *) data, (guint) len);
              g_free (data);
              if (val178 != NULL)
              {
                g_free(val178);
                val178 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              val178 = g_byte_array_new();
              g_byte_array_append (val178, (guint8 *) data, (guint) len);
              g_free (data);
              if (this_object->attributes && key177)
                g_hash_table_insert ((GHashTable *)this_object->attributes, (gpointer) key177, (gpointer) val178);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_attributes = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
hbase_scanner_open_with_stop_ts_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  HbaseScannerOpenWithStopTsArgs * this_object = HBASE_SCANNER_OPEN_WITH_STOP_TS_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "HbaseScannerOpenWithStopTsArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "tableName", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->tableName ? ((GByteArray *) this_object->tableName)->data : NULL, this_object->tableName ? ((GByteArray *) this_object->tableName)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "startRow", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->startRow ? ((GByteArray *) this_object->startRow)->data : NULL, this_object->startRow ? ((GByteArray *) this_object->startRow)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "stopRow", T_STRING, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->stopRow ? ((GByteArray *) this_object->stopRow)->data : NULL, this_object->stopRow ? ((GByteArray *) this_object->stopRow)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "columns", T_LIST, 4, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i179;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (this_object->columns ? this_object->columns->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i179 = 0; i179 < (this_object->columns ? this_object->columns->len : 0); i179++)
    {
      if ((ret = thrift_protocol_write_binary (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->columns, i179)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->columns, i179)))->data : NULL, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->columns, i179)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->columns, i179)))->len : 0, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "timestamp", T_I64, 5, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->timestamp, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "attributes", T_MAP, 6, error)) < 0)
    return -1;
  xfer += ret;
  {
    Text key180 = NULL;
    Text val181 = NULL;
    GList *key_list = NULL, *iter = NULL;
    Text* keys;
    int i = 0, key_count;

    if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRING, this_object->attributes ? (gint32) g_hash_table_size ((GHashTable *) this_object->attributes) : 0, error)) < 0)
      return -1;
    xfer += ret;
    if (this_object->attributes)
      g_hash_table_foreach ((GHashTable *) this_object->attributes, thrift_hash_table_get_keys, &key_list);
    key_count = g_list_length (key_list);
    keys = g_newa (Text, key_count);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
      keys[i++] = (Text) iter->data;
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key180 = keys[i];
      val181 = (Text) g_hash_table_lookup (((GHashTable *) this_object->attributes), (gpointer) key180);

      if ((ret = thrift_protocol_write_binary (protocol,  key180 ? ((GByteArray *)  key180)->data : NULL,  key180 ? ((GByteArray *)  key180)->len : 0, error)) < 0)
        return -1;
      xfer += ret;

      if ((ret = thrift_protocol_write_binary (protocol,  val181 ? ((GByteArray *)  val181)->data : NULL,  val181 ? ((GByteArray *)  val181)->len : 0, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
hbase_scanner_open_with_stop_ts_args_set_property (GObject *object,
                                                   guint property_id,
                                                   const GValue *value,
                                                   GParamSpec *pspec)
{
  HbaseScannerOpenWithStopTsArgs *self = HBASE_SCANNER_OPEN_WITH_STOP_TS_ARGS (object);

  switch (property_id)
  {
    case PROP_HBASE_SCANNER_OPEN_WITH_STOP_TS_ARGS_TABLE_NAME:
      if (self->tableName != NULL)
        g_byte_array_unref (self->tableName);
      self->tableName = g_value_dup_boxed (value);
      self->__isset_tableName = TRUE;
      break;

    case PROP_HBASE_SCANNER_OPEN_WITH_STOP_TS_ARGS_START_ROW:
      if (self->startRow != NULL)
        g_byte_array_unref (self->startRow);
      self->startRow = g_value_dup_boxed (value);
      self->__isset_startRow = TRUE;
      break;

    case PROP_HBASE_SCANNER_OPEN_WITH_STOP_TS_ARGS_STOP_ROW:
      if (self->stopRow != NULL)
        g_byte_array_unref (self->stopRow);
      self->stopRow = g_value_dup_boxed (value);
      self->__isset_stopRow = TRUE;
      break;

    case PROP_HBASE_SCANNER_OPEN_WITH_STOP_TS_ARGS_COLUMNS:
      if (self->columns != NULL)
        g_ptr_array_unref (self->columns);
      self->columns = g_value_dup_boxed (value);
      self->__isset_columns = TRUE;
      break;

    case PROP_HBASE_SCANNER_OPEN_WITH_STOP_TS_ARGS_TIMESTAMP:
      self->timestamp = g_value_get_int64 (value);
      self->__isset_timestamp = TRUE;
      break;

    case PROP_HBASE_SCANNER_OPEN_WITH_STOP_TS_ARGS_ATTRIBUTES:
      if (self->attributes != NULL)
        g_hash_table_unref (self->attributes);
      self->attributes = g_value_dup_boxed (value);
      self->__isset_attributes = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
hbase_scanner_open_with_stop_ts_args_get_property (GObject *object,
                                                   guint property_id,
                                                   GValue *value,
                                                   GParamSpec *pspec)
{
  HbaseScannerOpenWithStopTsArgs *self = HBASE_SCANNER_OPEN_WITH_STOP_TS_ARGS (object);

  switch (property_id)
  {
    case PROP_HBASE_SCANNER_OPEN_WITH_STOP_TS_ARGS_TABLE_NAME:
      g_value_set_boxed (value, self->tableName);
      break;

    case PROP_HBASE_SCANNER_OPEN_WITH_STOP_TS_ARGS_START_ROW:
      g_value_set_boxed (value, self->startRow);
      break;

    case PROP_HBASE_SCANNER_OPEN_WITH_STOP_TS_ARGS_STOP_ROW:
      g_value_set_boxed (value, self->stopRow);
      break;

    case PROP_HBASE_SCANNER_OPEN_WITH_STOP_TS_ARGS_COLUMNS:
      g_value_set_boxed (value, self->columns);
      break;

    case PROP_HBASE_SCANNER_OPEN_WITH_STOP_TS_ARGS_TIMESTAMP:
      g_value_set_int64 (value, self->timestamp);
      break;

    case PROP_HBASE_SCANNER_OPEN_WITH_STOP_TS_ARGS_ATTRIBUTES:
      g_value_set_boxed (value, self->attributes);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
hbase_scanner_open_with_stop_ts_args_instance_init (HbaseScannerOpenWithStopTsArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->tableName = NULL;
  object->__isset_tableName = FALSE;
  object->startRow = NULL;
  object->__isset_startRow = FALSE;
  object->stopRow = NULL;
  object->__isset_stopRow = FALSE;
  object->columns = g_ptr_array_new_with_free_func (thrift_string_free);
  object->__isset_columns = FALSE;
  object->timestamp = 0;
  object->__isset_timestamp = FALSE;
  object->attributes = g_hash_table_new_full (g_str_hash, g_str_equal, thrift_string_free, thrift_string_free);
  object->__isset_attributes = FALSE;
}

static void 
hbase_scanner_open_with_stop_ts_args_finalize (GObject *object)
{
  HbaseScannerOpenWithStopTsArgs *tobject = HBASE_SCANNER_OPEN_WITH_STOP_TS_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->tableName != NULL)
  {
    thrift_string_free(tobject->tableName);
    tobject->tableName = NULL;
  }
  if (tobject->startRow != NULL)
  {
    thrift_string_free(tobject->startRow);
    tobject->startRow = NULL;
  }
  if (tobject->stopRow != NULL)
  {
    thrift_string_free(tobject->stopRow);
    tobject->stopRow = NULL;
  }
  if (tobject->columns != NULL)
  {
    g_ptr_array_unref (tobject->columns);
    tobject->columns = NULL;
  }
  if (tobject->attributes != NULL)
  {
    g_hash_table_destroy (tobject->attributes);
    tobject->attributes = NULL;
  }
}

static void
hbase_scanner_open_with_stop_ts_args_class_init (HbaseScannerOpenWithStopTsArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = hbase_scanner_open_with_stop_ts_args_read;
  struct_class->write = hbase_scanner_open_with_stop_ts_args_write;

  gobject_class->finalize = hbase_scanner_open_with_stop_ts_args_finalize;
  gobject_class->get_property = hbase_scanner_open_with_stop_ts_args_get_property;
  gobject_class->set_property = hbase_scanner_open_with_stop_ts_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_SCANNER_OPEN_WITH_STOP_TS_ARGS_TABLE_NAME,
     g_param_spec_boxed ("tableName",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_SCANNER_OPEN_WITH_STOP_TS_ARGS_START_ROW,
     g_param_spec_boxed ("startRow",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_SCANNER_OPEN_WITH_STOP_TS_ARGS_STOP_ROW,
     g_param_spec_boxed ("stopRow",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_SCANNER_OPEN_WITH_STOP_TS_ARGS_COLUMNS,
     g_param_spec_boxed ("columns",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_SCANNER_OPEN_WITH_STOP_TS_ARGS_TIMESTAMP,
     g_param_spec_int64 ("timestamp",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_SCANNER_OPEN_WITH_STOP_TS_ARGS_ATTRIBUTES,
     g_param_spec_boxed ("attributes",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));
}

GType
hbase_scanner_open_with_stop_ts_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (HbaseScannerOpenWithStopTsArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) hbase_scanner_open_with_stop_ts_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (HbaseScannerOpenWithStopTsArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) hbase_scanner_open_with_stop_ts_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "HbaseScannerOpenWithStopTsArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _HbaseScannerOpenWithStopTsResultProperties
{
  PROP_HBASE_SCANNER_OPEN_WITH_STOP_TS_RESULT_0,
  PROP_HBASE_SCANNER_OPEN_WITH_STOP_TS_RESULT_SUCCESS,
  PROP_HBASE_SCANNER_OPEN_WITH_STOP_TS_RESULT_IO
};

/* reads a hbase_scanner_open_with_stop_ts_result object */
static gint32
hbase_scanner_open_with_stop_ts_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  HbaseScannerOpenWithStopTsResult * this_object = HBASE_SCANNER_OPEN_WITH_STOP_TS_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->io != NULL)
          {
            g_object_unref (this_object->io);
          }
          this_object->io = g_object_new (TYPE_I_O_ERROR, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
          {
            g_object_unref (this_object->io);
            this_object->io = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_io = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
hbase_scanner_open_with_stop_ts_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  HbaseScannerOpenWithStopTsResult * this_object = HBASE_SCANNER_OPEN_WITH_STOP_TS_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "HbaseScannerOpenWithStopTsResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I32, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->success, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_io == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "io", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
hbase_scanner_open_with_stop_ts_result_set_property (GObject *object,
                                                     guint property_id,
                                                     const GValue *value,
                                                     GParamSpec *pspec)
{
  HbaseScannerOpenWithStopTsResult *self = HBASE_SCANNER_OPEN_WITH_STOP_TS_RESULT (object);

  switch (property_id)
  {
    case PROP_HBASE_SCANNER_OPEN_WITH_STOP_TS_RESULT_SUCCESS:
      self->success = g_value_get_int (value);
      self->__isset_success = TRUE;
      break;

    case PROP_HBASE_SCANNER_OPEN_WITH_STOP_TS_RESULT_IO:
      if (self->io != NULL)
        g_object_unref (self->io);
      self->io = g_value_dup_object (value);
      self->__isset_io = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
hbase_scanner_open_with_stop_ts_result_get_property (GObject *object,
                                                     guint property_id,
                                                     GValue *value,
                                                     GParamSpec *pspec)
{
  HbaseScannerOpenWithStopTsResult *self = HBASE_SCANNER_OPEN_WITH_STOP_TS_RESULT (object);

  switch (property_id)
  {
    case PROP_HBASE_SCANNER_OPEN_WITH_STOP_TS_RESULT_SUCCESS:
      g_value_set_int (value, self->success);
      break;

    case PROP_HBASE_SCANNER_OPEN_WITH_STOP_TS_RESULT_IO:
      g_value_set_object (value, self->io);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
hbase_scanner_open_with_stop_ts_result_instance_init (HbaseScannerOpenWithStopTsResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
  object->io = NULL;
  object->__isset_io = FALSE;
}

static void 
hbase_scanner_open_with_stop_ts_result_finalize (GObject *object)
{
  HbaseScannerOpenWithStopTsResult *tobject = HBASE_SCANNER_OPEN_WITH_STOP_TS_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->io != NULL)
  {
    g_object_unref(tobject->io);
    tobject->io = NULL;
  }
}

static void
hbase_scanner_open_with_stop_ts_result_class_init (HbaseScannerOpenWithStopTsResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = hbase_scanner_open_with_stop_ts_result_read;
  struct_class->write = hbase_scanner_open_with_stop_ts_result_write;

  gobject_class->finalize = hbase_scanner_open_with_stop_ts_result_finalize;
  gobject_class->get_property = hbase_scanner_open_with_stop_ts_result_get_property;
  gobject_class->set_property = hbase_scanner_open_with_stop_ts_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_SCANNER_OPEN_WITH_STOP_TS_RESULT_SUCCESS,
     g_param_spec_int ("success",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_SCANNER_OPEN_WITH_STOP_TS_RESULT_IO,
     g_param_spec_object ("io",
                         NULL,
                         NULL,
                         TYPE_I_O_ERROR,
                         G_PARAM_READWRITE));
}

GType
hbase_scanner_open_with_stop_ts_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (HbaseScannerOpenWithStopTsResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) hbase_scanner_open_with_stop_ts_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (HbaseScannerOpenWithStopTsResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) hbase_scanner_open_with_stop_ts_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "HbaseScannerOpenWithStopTsResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _HbaseScannerGetArgsProperties
{
  PROP_HBASE_SCANNER_GET_ARGS_0,
  PROP_HBASE_SCANNER_GET_ARGS_ID
};

/* reads a hbase_scanner_get_args object */
static gint32
hbase_scanner_get_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  HbaseScannerGetArgs * this_object = HBASE_SCANNER_GET_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->id, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_id = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
hbase_scanner_get_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  HbaseScannerGetArgs * this_object = HBASE_SCANNER_GET_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "HbaseScannerGetArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "id", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->id, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
hbase_scanner_get_args_set_property (GObject *object,
                                     guint property_id,
                                     const GValue *value,
                                     GParamSpec *pspec)
{
  HbaseScannerGetArgs *self = HBASE_SCANNER_GET_ARGS (object);

  switch (property_id)
  {
    case PROP_HBASE_SCANNER_GET_ARGS_ID:
      self->id = g_value_get_int (value);
      self->__isset_id = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
hbase_scanner_get_args_get_property (GObject *object,
                                     guint property_id,
                                     GValue *value,
                                     GParamSpec *pspec)
{
  HbaseScannerGetArgs *self = HBASE_SCANNER_GET_ARGS (object);

  switch (property_id)
  {
    case PROP_HBASE_SCANNER_GET_ARGS_ID:
      g_value_set_int (value, self->id);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
hbase_scanner_get_args_instance_init (HbaseScannerGetArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->id = 0;
  object->__isset_id = FALSE;
}

static void 
hbase_scanner_get_args_finalize (GObject *object)
{
  HbaseScannerGetArgs *tobject = HBASE_SCANNER_GET_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
hbase_scanner_get_args_class_init (HbaseScannerGetArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = hbase_scanner_get_args_read;
  struct_class->write = hbase_scanner_get_args_write;

  gobject_class->finalize = hbase_scanner_get_args_finalize;
  gobject_class->get_property = hbase_scanner_get_args_get_property;
  gobject_class->set_property = hbase_scanner_get_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_SCANNER_GET_ARGS_ID,
     g_param_spec_int ("id",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
hbase_scanner_get_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (HbaseScannerGetArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) hbase_scanner_get_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (HbaseScannerGetArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) hbase_scanner_get_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "HbaseScannerGetArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _HbaseScannerGetResultProperties
{
  PROP_HBASE_SCANNER_GET_RESULT_0,
  PROP_HBASE_SCANNER_GET_RESULT_SUCCESS,
  PROP_HBASE_SCANNER_GET_RESULT_IO,
  PROP_HBASE_SCANNER_GET_RESULT_IA
};

/* reads a hbase_scanner_get_result object */
static gint32
hbase_scanner_get_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  HbaseScannerGetResult * this_object = HBASE_SCANNER_GET_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              TRowResult * _elem182 = NULL;
              if ( _elem182 != NULL)
              {
                g_object_unref (_elem182);
              }
              _elem182 = g_object_new (TYPE_T_ROW_RESULT, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem182), protocol, error)) < 0)
              {
                g_object_unref (_elem182);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->success, _elem182);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->io != NULL)
          {
            g_object_unref (this_object->io);
          }
          this_object->io = g_object_new (TYPE_I_O_ERROR, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
          {
            g_object_unref (this_object->io);
            this_object->io = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_io = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ia != NULL)
          {
            g_object_unref (this_object->ia);
          }
          this_object->ia = g_object_new (TYPE_ILLEGAL_ARGUMENT, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ia), protocol, error)) < 0)
          {
            g_object_unref (this_object->ia);
            this_object->ia = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ia = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
hbase_scanner_get_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  HbaseScannerGetResult * this_object = HBASE_SCANNER_GET_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "HbaseScannerGetResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_LIST, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i183;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->success ? this_object->success->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i183 = 0; i183 < (this_object->success ? this_object->success->len : 0); i183++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->success, i183))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_io == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "io", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ia == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ia", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ia), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
hbase_scanner_get_result_set_property (GObject *object,
                                       guint property_id,
                                       const GValue *value,
                                       GParamSpec *pspec)
{
  HbaseScannerGetResult *self = HBASE_SCANNER_GET_RESULT (object);

  switch (property_id)
  {
    case PROP_HBASE_SCANNER_GET_RESULT_SUCCESS:
      if (self->success != NULL)
        g_ptr_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    case PROP_HBASE_SCANNER_GET_RESULT_IO:
      if (self->io != NULL)
        g_object_unref (self->io);
      self->io = g_value_dup_object (value);
      self->__isset_io = TRUE;
      break;

    case PROP_HBASE_SCANNER_GET_RESULT_IA:
      if (self->ia != NULL)
        g_object_unref (self->ia);
      self->ia = g_value_dup_object (value);
      self->__isset_ia = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
hbase_scanner_get_result_get_property (GObject *object,
                                       guint property_id,
                                       GValue *value,
                                       GParamSpec *pspec)
{
  HbaseScannerGetResult *self = HBASE_SCANNER_GET_RESULT (object);

  switch (property_id)
  {
    case PROP_HBASE_SCANNER_GET_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    case PROP_HBASE_SCANNER_GET_RESULT_IO:
      g_value_set_object (value, self->io);
      break;

    case PROP_HBASE_SCANNER_GET_RESULT_IA:
      g_value_set_object (value, self->ia);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
hbase_scanner_get_result_instance_init (HbaseScannerGetResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_success = FALSE;
  object->io = NULL;
  object->__isset_io = FALSE;
  object->ia = NULL;
  object->__isset_ia = FALSE;
}

static void 
hbase_scanner_get_result_finalize (GObject *object)
{
  HbaseScannerGetResult *tobject = HBASE_SCANNER_GET_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_ptr_array_unref (tobject->success);
    tobject->success = NULL;
  }
  if (tobject->io != NULL)
  {
    g_object_unref(tobject->io);
    tobject->io = NULL;
  }
  if (tobject->ia != NULL)
  {
    g_object_unref(tobject->ia);
    tobject->ia = NULL;
  }
}

static void
hbase_scanner_get_result_class_init (HbaseScannerGetResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = hbase_scanner_get_result_read;
  struct_class->write = hbase_scanner_get_result_write;

  gobject_class->finalize = hbase_scanner_get_result_finalize;
  gobject_class->get_property = hbase_scanner_get_result_get_property;
  gobject_class->set_property = hbase_scanner_get_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_SCANNER_GET_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_SCANNER_GET_RESULT_IO,
     g_param_spec_object ("io",
                         NULL,
                         NULL,
                         TYPE_I_O_ERROR,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_SCANNER_GET_RESULT_IA,
     g_param_spec_object ("ia",
                         NULL,
                         NULL,
                         TYPE_ILLEGAL_ARGUMENT,
                         G_PARAM_READWRITE));
}

GType
hbase_scanner_get_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (HbaseScannerGetResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) hbase_scanner_get_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (HbaseScannerGetResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) hbase_scanner_get_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "HbaseScannerGetResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _HbaseScannerGetListArgsProperties
{
  PROP_HBASE_SCANNER_GET_LIST_ARGS_0,
  PROP_HBASE_SCANNER_GET_LIST_ARGS_ID,
  PROP_HBASE_SCANNER_GET_LIST_ARGS_NB_ROWS
};

/* reads a hbase_scanner_get_list_args object */
static gint32
hbase_scanner_get_list_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  HbaseScannerGetListArgs * this_object = HBASE_SCANNER_GET_LIST_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->id, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_id = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->nbRows, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_nbRows = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
hbase_scanner_get_list_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  HbaseScannerGetListArgs * this_object = HBASE_SCANNER_GET_LIST_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "HbaseScannerGetListArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "id", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->id, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "nbRows", T_I32, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->nbRows, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
hbase_scanner_get_list_args_set_property (GObject *object,
                                          guint property_id,
                                          const GValue *value,
                                          GParamSpec *pspec)
{
  HbaseScannerGetListArgs *self = HBASE_SCANNER_GET_LIST_ARGS (object);

  switch (property_id)
  {
    case PROP_HBASE_SCANNER_GET_LIST_ARGS_ID:
      self->id = g_value_get_int (value);
      self->__isset_id = TRUE;
      break;

    case PROP_HBASE_SCANNER_GET_LIST_ARGS_NB_ROWS:
      self->nbRows = g_value_get_int (value);
      self->__isset_nbRows = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
hbase_scanner_get_list_args_get_property (GObject *object,
                                          guint property_id,
                                          GValue *value,
                                          GParamSpec *pspec)
{
  HbaseScannerGetListArgs *self = HBASE_SCANNER_GET_LIST_ARGS (object);

  switch (property_id)
  {
    case PROP_HBASE_SCANNER_GET_LIST_ARGS_ID:
      g_value_set_int (value, self->id);
      break;

    case PROP_HBASE_SCANNER_GET_LIST_ARGS_NB_ROWS:
      g_value_set_int (value, self->nbRows);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
hbase_scanner_get_list_args_instance_init (HbaseScannerGetListArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->id = 0;
  object->__isset_id = FALSE;
  object->nbRows = 0;
  object->__isset_nbRows = FALSE;
}

static void 
hbase_scanner_get_list_args_finalize (GObject *object)
{
  HbaseScannerGetListArgs *tobject = HBASE_SCANNER_GET_LIST_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
hbase_scanner_get_list_args_class_init (HbaseScannerGetListArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = hbase_scanner_get_list_args_read;
  struct_class->write = hbase_scanner_get_list_args_write;

  gobject_class->finalize = hbase_scanner_get_list_args_finalize;
  gobject_class->get_property = hbase_scanner_get_list_args_get_property;
  gobject_class->set_property = hbase_scanner_get_list_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_SCANNER_GET_LIST_ARGS_ID,
     g_param_spec_int ("id",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_SCANNER_GET_LIST_ARGS_NB_ROWS,
     g_param_spec_int ("nbRows",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
hbase_scanner_get_list_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (HbaseScannerGetListArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) hbase_scanner_get_list_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (HbaseScannerGetListArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) hbase_scanner_get_list_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "HbaseScannerGetListArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _HbaseScannerGetListResultProperties
{
  PROP_HBASE_SCANNER_GET_LIST_RESULT_0,
  PROP_HBASE_SCANNER_GET_LIST_RESULT_SUCCESS,
  PROP_HBASE_SCANNER_GET_LIST_RESULT_IO,
  PROP_HBASE_SCANNER_GET_LIST_RESULT_IA
};

/* reads a hbase_scanner_get_list_result object */
static gint32
hbase_scanner_get_list_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  HbaseScannerGetListResult * this_object = HBASE_SCANNER_GET_LIST_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              TRowResult * _elem184 = NULL;
              if ( _elem184 != NULL)
              {
                g_object_unref (_elem184);
              }
              _elem184 = g_object_new (TYPE_T_ROW_RESULT, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem184), protocol, error)) < 0)
              {
                g_object_unref (_elem184);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->success, _elem184);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->io != NULL)
          {
            g_object_unref (this_object->io);
          }
          this_object->io = g_object_new (TYPE_I_O_ERROR, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
          {
            g_object_unref (this_object->io);
            this_object->io = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_io = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ia != NULL)
          {
            g_object_unref (this_object->ia);
          }
          this_object->ia = g_object_new (TYPE_ILLEGAL_ARGUMENT, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ia), protocol, error)) < 0)
          {
            g_object_unref (this_object->ia);
            this_object->ia = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ia = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
hbase_scanner_get_list_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  HbaseScannerGetListResult * this_object = HBASE_SCANNER_GET_LIST_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "HbaseScannerGetListResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_LIST, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i185;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->success ? this_object->success->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i185 = 0; i185 < (this_object->success ? this_object->success->len : 0); i185++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->success, i185))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_io == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "io", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ia == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ia", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ia), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
hbase_scanner_get_list_result_set_property (GObject *object,
                                            guint property_id,
                                            const GValue *value,
                                            GParamSpec *pspec)
{
  HbaseScannerGetListResult *self = HBASE_SCANNER_GET_LIST_RESULT (object);

  switch (property_id)
  {
    case PROP_HBASE_SCANNER_GET_LIST_RESULT_SUCCESS:
      if (self->success != NULL)
        g_ptr_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    case PROP_HBASE_SCANNER_GET_LIST_RESULT_IO:
      if (self->io != NULL)
        g_object_unref (self->io);
      self->io = g_value_dup_object (value);
      self->__isset_io = TRUE;
      break;

    case PROP_HBASE_SCANNER_GET_LIST_RESULT_IA:
      if (self->ia != NULL)
        g_object_unref (self->ia);
      self->ia = g_value_dup_object (value);
      self->__isset_ia = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
hbase_scanner_get_list_result_get_property (GObject *object,
                                            guint property_id,
                                            GValue *value,
                                            GParamSpec *pspec)
{
  HbaseScannerGetListResult *self = HBASE_SCANNER_GET_LIST_RESULT (object);

  switch (property_id)
  {
    case PROP_HBASE_SCANNER_GET_LIST_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    case PROP_HBASE_SCANNER_GET_LIST_RESULT_IO:
      g_value_set_object (value, self->io);
      break;

    case PROP_HBASE_SCANNER_GET_LIST_RESULT_IA:
      g_value_set_object (value, self->ia);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
hbase_scanner_get_list_result_instance_init (HbaseScannerGetListResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_success = FALSE;
  object->io = NULL;
  object->__isset_io = FALSE;
  object->ia = NULL;
  object->__isset_ia = FALSE;
}

static void 
hbase_scanner_get_list_result_finalize (GObject *object)
{
  HbaseScannerGetListResult *tobject = HBASE_SCANNER_GET_LIST_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_ptr_array_unref (tobject->success);
    tobject->success = NULL;
  }
  if (tobject->io != NULL)
  {
    g_object_unref(tobject->io);
    tobject->io = NULL;
  }
  if (tobject->ia != NULL)
  {
    g_object_unref(tobject->ia);
    tobject->ia = NULL;
  }
}

static void
hbase_scanner_get_list_result_class_init (HbaseScannerGetListResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = hbase_scanner_get_list_result_read;
  struct_class->write = hbase_scanner_get_list_result_write;

  gobject_class->finalize = hbase_scanner_get_list_result_finalize;
  gobject_class->get_property = hbase_scanner_get_list_result_get_property;
  gobject_class->set_property = hbase_scanner_get_list_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_SCANNER_GET_LIST_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_SCANNER_GET_LIST_RESULT_IO,
     g_param_spec_object ("io",
                         NULL,
                         NULL,
                         TYPE_I_O_ERROR,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_SCANNER_GET_LIST_RESULT_IA,
     g_param_spec_object ("ia",
                         NULL,
                         NULL,
                         TYPE_ILLEGAL_ARGUMENT,
                         G_PARAM_READWRITE));
}

GType
hbase_scanner_get_list_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (HbaseScannerGetListResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) hbase_scanner_get_list_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (HbaseScannerGetListResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) hbase_scanner_get_list_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "HbaseScannerGetListResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _HbaseScannerCloseArgsProperties
{
  PROP_HBASE_SCANNER_CLOSE_ARGS_0,
  PROP_HBASE_SCANNER_CLOSE_ARGS_ID
};

/* reads a hbase_scanner_close_args object */
static gint32
hbase_scanner_close_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  HbaseScannerCloseArgs * this_object = HBASE_SCANNER_CLOSE_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->id, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_id = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
hbase_scanner_close_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  HbaseScannerCloseArgs * this_object = HBASE_SCANNER_CLOSE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "HbaseScannerCloseArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "id", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->id, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
hbase_scanner_close_args_set_property (GObject *object,
                                       guint property_id,
                                       const GValue *value,
                                       GParamSpec *pspec)
{
  HbaseScannerCloseArgs *self = HBASE_SCANNER_CLOSE_ARGS (object);

  switch (property_id)
  {
    case PROP_HBASE_SCANNER_CLOSE_ARGS_ID:
      self->id = g_value_get_int (value);
      self->__isset_id = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
hbase_scanner_close_args_get_property (GObject *object,
                                       guint property_id,
                                       GValue *value,
                                       GParamSpec *pspec)
{
  HbaseScannerCloseArgs *self = HBASE_SCANNER_CLOSE_ARGS (object);

  switch (property_id)
  {
    case PROP_HBASE_SCANNER_CLOSE_ARGS_ID:
      g_value_set_int (value, self->id);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
hbase_scanner_close_args_instance_init (HbaseScannerCloseArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->id = 0;
  object->__isset_id = FALSE;
}

static void 
hbase_scanner_close_args_finalize (GObject *object)
{
  HbaseScannerCloseArgs *tobject = HBASE_SCANNER_CLOSE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
hbase_scanner_close_args_class_init (HbaseScannerCloseArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = hbase_scanner_close_args_read;
  struct_class->write = hbase_scanner_close_args_write;

  gobject_class->finalize = hbase_scanner_close_args_finalize;
  gobject_class->get_property = hbase_scanner_close_args_get_property;
  gobject_class->set_property = hbase_scanner_close_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_SCANNER_CLOSE_ARGS_ID,
     g_param_spec_int ("id",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
hbase_scanner_close_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (HbaseScannerCloseArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) hbase_scanner_close_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (HbaseScannerCloseArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) hbase_scanner_close_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "HbaseScannerCloseArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _HbaseScannerCloseResultProperties
{
  PROP_HBASE_SCANNER_CLOSE_RESULT_0,
  PROP_HBASE_SCANNER_CLOSE_RESULT_IO,
  PROP_HBASE_SCANNER_CLOSE_RESULT_IA
};

/* reads a hbase_scanner_close_result object */
static gint32
hbase_scanner_close_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  HbaseScannerCloseResult * this_object = HBASE_SCANNER_CLOSE_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->io != NULL)
          {
            g_object_unref (this_object->io);
          }
          this_object->io = g_object_new (TYPE_I_O_ERROR, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
          {
            g_object_unref (this_object->io);
            this_object->io = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_io = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ia != NULL)
          {
            g_object_unref (this_object->ia);
          }
          this_object->ia = g_object_new (TYPE_ILLEGAL_ARGUMENT, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ia), protocol, error)) < 0)
          {
            g_object_unref (this_object->ia);
            this_object->ia = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ia = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
hbase_scanner_close_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  HbaseScannerCloseResult * this_object = HBASE_SCANNER_CLOSE_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "HbaseScannerCloseResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_io == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "io", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ia == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ia", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ia), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
hbase_scanner_close_result_set_property (GObject *object,
                                         guint property_id,
                                         const GValue *value,
                                         GParamSpec *pspec)
{
  HbaseScannerCloseResult *self = HBASE_SCANNER_CLOSE_RESULT (object);

  switch (property_id)
  {
    case PROP_HBASE_SCANNER_CLOSE_RESULT_IO:
      if (self->io != NULL)
        g_object_unref (self->io);
      self->io = g_value_dup_object (value);
      self->__isset_io = TRUE;
      break;

    case PROP_HBASE_SCANNER_CLOSE_RESULT_IA:
      if (self->ia != NULL)
        g_object_unref (self->ia);
      self->ia = g_value_dup_object (value);
      self->__isset_ia = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
hbase_scanner_close_result_get_property (GObject *object,
                                         guint property_id,
                                         GValue *value,
                                         GParamSpec *pspec)
{
  HbaseScannerCloseResult *self = HBASE_SCANNER_CLOSE_RESULT (object);

  switch (property_id)
  {
    case PROP_HBASE_SCANNER_CLOSE_RESULT_IO:
      g_value_set_object (value, self->io);
      break;

    case PROP_HBASE_SCANNER_CLOSE_RESULT_IA:
      g_value_set_object (value, self->ia);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
hbase_scanner_close_result_instance_init (HbaseScannerCloseResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->io = NULL;
  object->__isset_io = FALSE;
  object->ia = NULL;
  object->__isset_ia = FALSE;
}

static void 
hbase_scanner_close_result_finalize (GObject *object)
{
  HbaseScannerCloseResult *tobject = HBASE_SCANNER_CLOSE_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->io != NULL)
  {
    g_object_unref(tobject->io);
    tobject->io = NULL;
  }
  if (tobject->ia != NULL)
  {
    g_object_unref(tobject->ia);
    tobject->ia = NULL;
  }
}

static void
hbase_scanner_close_result_class_init (HbaseScannerCloseResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = hbase_scanner_close_result_read;
  struct_class->write = hbase_scanner_close_result_write;

  gobject_class->finalize = hbase_scanner_close_result_finalize;
  gobject_class->get_property = hbase_scanner_close_result_get_property;
  gobject_class->set_property = hbase_scanner_close_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_SCANNER_CLOSE_RESULT_IO,
     g_param_spec_object ("io",
                         NULL,
                         NULL,
                         TYPE_I_O_ERROR,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_SCANNER_CLOSE_RESULT_IA,
     g_param_spec_object ("ia",
                         NULL,
                         NULL,
                         TYPE_ILLEGAL_ARGUMENT,
                         G_PARAM_READWRITE));
}

GType
hbase_scanner_close_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (HbaseScannerCloseResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) hbase_scanner_close_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (HbaseScannerCloseResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) hbase_scanner_close_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "HbaseScannerCloseResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _HbaseGetRowOrBeforeArgsProperties
{
  PROP_HBASE_GET_ROW_OR_BEFORE_ARGS_0,
  PROP_HBASE_GET_ROW_OR_BEFORE_ARGS_TABLE_NAME,
  PROP_HBASE_GET_ROW_OR_BEFORE_ARGS_ROW,
  PROP_HBASE_GET_ROW_OR_BEFORE_ARGS_FAMILY
};

/* reads a hbase_get_row_or_before_args object */
static gint32
hbase_get_row_or_before_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  HbaseGetRowOrBeforeArgs * this_object = HBASE_GET_ROW_OR_BEFORE_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->tableName != NULL)
          {
            g_free(this_object->tableName);
            this_object->tableName = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->tableName = g_byte_array_new();
          g_byte_array_append (this_object->tableName, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_tableName = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->row != NULL)
          {
            g_free(this_object->row);
            this_object->row = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->row = g_byte_array_new();
          g_byte_array_append (this_object->row, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_row = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if (this_object->family != NULL)
          {
            g_free(this_object->family);
            this_object->family = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->family = g_byte_array_new();
          g_byte_array_append (this_object->family, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_family = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
hbase_get_row_or_before_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  HbaseGetRowOrBeforeArgs * this_object = HBASE_GET_ROW_OR_BEFORE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "HbaseGetRowOrBeforeArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "tableName", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->tableName ? ((GByteArray *) this_object->tableName)->data : NULL, this_object->tableName ? ((GByteArray *) this_object->tableName)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "row", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->row ? ((GByteArray *) this_object->row)->data : NULL, this_object->row ? ((GByteArray *) this_object->row)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "family", T_STRING, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->family ? ((GByteArray *) this_object->family)->data : NULL, this_object->family ? ((GByteArray *) this_object->family)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
hbase_get_row_or_before_args_set_property (GObject *object,
                                           guint property_id,
                                           const GValue *value,
                                           GParamSpec *pspec)
{
  HbaseGetRowOrBeforeArgs *self = HBASE_GET_ROW_OR_BEFORE_ARGS (object);

  switch (property_id)
  {
    case PROP_HBASE_GET_ROW_OR_BEFORE_ARGS_TABLE_NAME:
      if (self->tableName != NULL)
        g_byte_array_unref (self->tableName);
      self->tableName = g_value_dup_boxed (value);
      self->__isset_tableName = TRUE;
      break;

    case PROP_HBASE_GET_ROW_OR_BEFORE_ARGS_ROW:
      if (self->row != NULL)
        g_byte_array_unref (self->row);
      self->row = g_value_dup_boxed (value);
      self->__isset_row = TRUE;
      break;

    case PROP_HBASE_GET_ROW_OR_BEFORE_ARGS_FAMILY:
      if (self->family != NULL)
        g_byte_array_unref (self->family);
      self->family = g_value_dup_boxed (value);
      self->__isset_family = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
hbase_get_row_or_before_args_get_property (GObject *object,
                                           guint property_id,
                                           GValue *value,
                                           GParamSpec *pspec)
{
  HbaseGetRowOrBeforeArgs *self = HBASE_GET_ROW_OR_BEFORE_ARGS (object);

  switch (property_id)
  {
    case PROP_HBASE_GET_ROW_OR_BEFORE_ARGS_TABLE_NAME:
      g_value_set_boxed (value, self->tableName);
      break;

    case PROP_HBASE_GET_ROW_OR_BEFORE_ARGS_ROW:
      g_value_set_boxed (value, self->row);
      break;

    case PROP_HBASE_GET_ROW_OR_BEFORE_ARGS_FAMILY:
      g_value_set_boxed (value, self->family);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
hbase_get_row_or_before_args_instance_init (HbaseGetRowOrBeforeArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->tableName = NULL;
  object->__isset_tableName = FALSE;
  object->row = NULL;
  object->__isset_row = FALSE;
  object->family = NULL;
  object->__isset_family = FALSE;
}

static void 
hbase_get_row_or_before_args_finalize (GObject *object)
{
  HbaseGetRowOrBeforeArgs *tobject = HBASE_GET_ROW_OR_BEFORE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->tableName != NULL)
  {
    thrift_string_free(tobject->tableName);
    tobject->tableName = NULL;
  }
  if (tobject->row != NULL)
  {
    thrift_string_free(tobject->row);
    tobject->row = NULL;
  }
  if (tobject->family != NULL)
  {
    thrift_string_free(tobject->family);
    tobject->family = NULL;
  }
}

static void
hbase_get_row_or_before_args_class_init (HbaseGetRowOrBeforeArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = hbase_get_row_or_before_args_read;
  struct_class->write = hbase_get_row_or_before_args_write;

  gobject_class->finalize = hbase_get_row_or_before_args_finalize;
  gobject_class->get_property = hbase_get_row_or_before_args_get_property;
  gobject_class->set_property = hbase_get_row_or_before_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_GET_ROW_OR_BEFORE_ARGS_TABLE_NAME,
     g_param_spec_boxed ("tableName",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_GET_ROW_OR_BEFORE_ARGS_ROW,
     g_param_spec_boxed ("row",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_GET_ROW_OR_BEFORE_ARGS_FAMILY,
     g_param_spec_boxed ("family",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));
}

GType
hbase_get_row_or_before_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (HbaseGetRowOrBeforeArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) hbase_get_row_or_before_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (HbaseGetRowOrBeforeArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) hbase_get_row_or_before_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "HbaseGetRowOrBeforeArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _HbaseGetRowOrBeforeResultProperties
{
  PROP_HBASE_GET_ROW_OR_BEFORE_RESULT_0,
  PROP_HBASE_GET_ROW_OR_BEFORE_RESULT_SUCCESS,
  PROP_HBASE_GET_ROW_OR_BEFORE_RESULT_IO
};

/* reads a hbase_get_row_or_before_result object */
static gint32
hbase_get_row_or_before_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  HbaseGetRowOrBeforeResult * this_object = HBASE_GET_ROW_OR_BEFORE_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              TCell * _elem186 = NULL;
              if ( _elem186 != NULL)
              {
                g_object_unref (_elem186);
              }
              _elem186 = g_object_new (TYPE_T_CELL, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem186), protocol, error)) < 0)
              {
                g_object_unref (_elem186);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->success, _elem186);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->io != NULL)
          {
            g_object_unref (this_object->io);
          }
          this_object->io = g_object_new (TYPE_I_O_ERROR, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
          {
            g_object_unref (this_object->io);
            this_object->io = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_io = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
hbase_get_row_or_before_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  HbaseGetRowOrBeforeResult * this_object = HBASE_GET_ROW_OR_BEFORE_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "HbaseGetRowOrBeforeResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_LIST, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i187;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->success ? this_object->success->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i187 = 0; i187 < (this_object->success ? this_object->success->len : 0); i187++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->success, i187))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_io == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "io", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
hbase_get_row_or_before_result_set_property (GObject *object,
                                             guint property_id,
                                             const GValue *value,
                                             GParamSpec *pspec)
{
  HbaseGetRowOrBeforeResult *self = HBASE_GET_ROW_OR_BEFORE_RESULT (object);

  switch (property_id)
  {
    case PROP_HBASE_GET_ROW_OR_BEFORE_RESULT_SUCCESS:
      if (self->success != NULL)
        g_ptr_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    case PROP_HBASE_GET_ROW_OR_BEFORE_RESULT_IO:
      if (self->io != NULL)
        g_object_unref (self->io);
      self->io = g_value_dup_object (value);
      self->__isset_io = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
hbase_get_row_or_before_result_get_property (GObject *object,
                                             guint property_id,
                                             GValue *value,
                                             GParamSpec *pspec)
{
  HbaseGetRowOrBeforeResult *self = HBASE_GET_ROW_OR_BEFORE_RESULT (object);

  switch (property_id)
  {
    case PROP_HBASE_GET_ROW_OR_BEFORE_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    case PROP_HBASE_GET_ROW_OR_BEFORE_RESULT_IO:
      g_value_set_object (value, self->io);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
hbase_get_row_or_before_result_instance_init (HbaseGetRowOrBeforeResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_success = FALSE;
  object->io = NULL;
  object->__isset_io = FALSE;
}

static void 
hbase_get_row_or_before_result_finalize (GObject *object)
{
  HbaseGetRowOrBeforeResult *tobject = HBASE_GET_ROW_OR_BEFORE_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_ptr_array_unref (tobject->success);
    tobject->success = NULL;
  }
  if (tobject->io != NULL)
  {
    g_object_unref(tobject->io);
    tobject->io = NULL;
  }
}

static void
hbase_get_row_or_before_result_class_init (HbaseGetRowOrBeforeResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = hbase_get_row_or_before_result_read;
  struct_class->write = hbase_get_row_or_before_result_write;

  gobject_class->finalize = hbase_get_row_or_before_result_finalize;
  gobject_class->get_property = hbase_get_row_or_before_result_get_property;
  gobject_class->set_property = hbase_get_row_or_before_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_GET_ROW_OR_BEFORE_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_GET_ROW_OR_BEFORE_RESULT_IO,
     g_param_spec_object ("io",
                         NULL,
                         NULL,
                         TYPE_I_O_ERROR,
                         G_PARAM_READWRITE));
}

GType
hbase_get_row_or_before_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (HbaseGetRowOrBeforeResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) hbase_get_row_or_before_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (HbaseGetRowOrBeforeResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) hbase_get_row_or_before_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "HbaseGetRowOrBeforeResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _HbaseGetRegionInfoArgsProperties
{
  PROP_HBASE_GET_REGION_INFO_ARGS_0,
  PROP_HBASE_GET_REGION_INFO_ARGS_ROW
};

/* reads a hbase_get_region_info_args object */
static gint32
hbase_get_region_info_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  HbaseGetRegionInfoArgs * this_object = HBASE_GET_REGION_INFO_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->row != NULL)
          {
            g_free(this_object->row);
            this_object->row = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->row = g_byte_array_new();
          g_byte_array_append (this_object->row, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_row = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
hbase_get_region_info_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  HbaseGetRegionInfoArgs * this_object = HBASE_GET_REGION_INFO_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "HbaseGetRegionInfoArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "row", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->row ? ((GByteArray *) this_object->row)->data : NULL, this_object->row ? ((GByteArray *) this_object->row)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
hbase_get_region_info_args_set_property (GObject *object,
                                         guint property_id,
                                         const GValue *value,
                                         GParamSpec *pspec)
{
  HbaseGetRegionInfoArgs *self = HBASE_GET_REGION_INFO_ARGS (object);

  switch (property_id)
  {
    case PROP_HBASE_GET_REGION_INFO_ARGS_ROW:
      if (self->row != NULL)
        g_byte_array_unref (self->row);
      self->row = g_value_dup_boxed (value);
      self->__isset_row = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
hbase_get_region_info_args_get_property (GObject *object,
                                         guint property_id,
                                         GValue *value,
                                         GParamSpec *pspec)
{
  HbaseGetRegionInfoArgs *self = HBASE_GET_REGION_INFO_ARGS (object);

  switch (property_id)
  {
    case PROP_HBASE_GET_REGION_INFO_ARGS_ROW:
      g_value_set_boxed (value, self->row);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
hbase_get_region_info_args_instance_init (HbaseGetRegionInfoArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->row = NULL;
  object->__isset_row = FALSE;
}

static void 
hbase_get_region_info_args_finalize (GObject *object)
{
  HbaseGetRegionInfoArgs *tobject = HBASE_GET_REGION_INFO_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->row != NULL)
  {
    thrift_string_free(tobject->row);
    tobject->row = NULL;
  }
}

static void
hbase_get_region_info_args_class_init (HbaseGetRegionInfoArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = hbase_get_region_info_args_read;
  struct_class->write = hbase_get_region_info_args_write;

  gobject_class->finalize = hbase_get_region_info_args_finalize;
  gobject_class->get_property = hbase_get_region_info_args_get_property;
  gobject_class->set_property = hbase_get_region_info_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_GET_REGION_INFO_ARGS_ROW,
     g_param_spec_boxed ("row",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));
}

GType
hbase_get_region_info_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (HbaseGetRegionInfoArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) hbase_get_region_info_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (HbaseGetRegionInfoArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) hbase_get_region_info_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "HbaseGetRegionInfoArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _HbaseGetRegionInfoResultProperties
{
  PROP_HBASE_GET_REGION_INFO_RESULT_0,
  PROP_HBASE_GET_REGION_INFO_RESULT_SUCCESS,
  PROP_HBASE_GET_REGION_INFO_RESULT_IO
};

/* reads a hbase_get_region_info_result object */
static gint32
hbase_get_region_info_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  HbaseGetRegionInfoResult * this_object = HBASE_GET_REGION_INFO_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->io != NULL)
          {
            g_object_unref (this_object->io);
          }
          this_object->io = g_object_new (TYPE_I_O_ERROR, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
          {
            g_object_unref (this_object->io);
            this_object->io = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_io = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
hbase_get_region_info_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  HbaseGetRegionInfoResult * this_object = HBASE_GET_REGION_INFO_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "HbaseGetRegionInfoResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_io == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "io", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
hbase_get_region_info_result_set_property (GObject *object,
                                           guint property_id,
                                           const GValue *value,
                                           GParamSpec *pspec)
{
  HbaseGetRegionInfoResult *self = HBASE_GET_REGION_INFO_RESULT (object);

  switch (property_id)
  {
    case PROP_HBASE_GET_REGION_INFO_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    case PROP_HBASE_GET_REGION_INFO_RESULT_IO:
      if (self->io != NULL)
        g_object_unref (self->io);
      self->io = g_value_dup_object (value);
      self->__isset_io = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
hbase_get_region_info_result_get_property (GObject *object,
                                           guint property_id,
                                           GValue *value,
                                           GParamSpec *pspec)
{
  HbaseGetRegionInfoResult *self = HBASE_GET_REGION_INFO_RESULT (object);

  switch (property_id)
  {
    case PROP_HBASE_GET_REGION_INFO_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    case PROP_HBASE_GET_REGION_INFO_RESULT_IO:
      g_value_set_object (value, self->io);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
hbase_get_region_info_result_instance_init (HbaseGetRegionInfoResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_T_REGION_INFO, NULL);
  object->__isset_success = FALSE;
  object->io = NULL;
  object->__isset_io = FALSE;
}

static void 
hbase_get_region_info_result_finalize (GObject *object)
{
  HbaseGetRegionInfoResult *tobject = HBASE_GET_REGION_INFO_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->io != NULL)
  {
    g_object_unref(tobject->io);
    tobject->io = NULL;
  }
}

static void
hbase_get_region_info_result_class_init (HbaseGetRegionInfoResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = hbase_get_region_info_result_read;
  struct_class->write = hbase_get_region_info_result_write;

  gobject_class->finalize = hbase_get_region_info_result_finalize;
  gobject_class->get_property = hbase_get_region_info_result_get_property;
  gobject_class->set_property = hbase_get_region_info_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_GET_REGION_INFO_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_T_REGION_INFO,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_GET_REGION_INFO_RESULT_IO,
     g_param_spec_object ("io",
                         NULL,
                         NULL,
                         TYPE_I_O_ERROR,
                         G_PARAM_READWRITE));
}

GType
hbase_get_region_info_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (HbaseGetRegionInfoResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) hbase_get_region_info_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (HbaseGetRegionInfoResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) hbase_get_region_info_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "HbaseGetRegionInfoResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _HbaseAppendArgsProperties
{
  PROP_HBASE_APPEND_ARGS_0,
  PROP_HBASE_APPEND_ARGS_APPEND
};

/* reads a hbase_append_args object */
static gint32
hbase_append_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  HbaseAppendArgs * this_object = HBASE_APPEND_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->append), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_append = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
hbase_append_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  HbaseAppendArgs * this_object = HBASE_APPEND_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "HbaseAppendArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "append", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->append), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
hbase_append_args_set_property (GObject *object,
                                guint property_id,
                                const GValue *value,
                                GParamSpec *pspec)
{
  HbaseAppendArgs *self = HBASE_APPEND_ARGS (object);

  switch (property_id)
  {
    case PROP_HBASE_APPEND_ARGS_APPEND:
      if (self->append != NULL)
        g_object_unref (self->append);
      self->append = g_value_dup_object (value);
      self->__isset_append = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
hbase_append_args_get_property (GObject *object,
                                guint property_id,
                                GValue *value,
                                GParamSpec *pspec)
{
  HbaseAppendArgs *self = HBASE_APPEND_ARGS (object);

  switch (property_id)
  {
    case PROP_HBASE_APPEND_ARGS_APPEND:
      g_value_set_object (value, self->append);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
hbase_append_args_instance_init (HbaseAppendArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->append = g_object_new (TYPE_T_APPEND, NULL);
  object->__isset_append = FALSE;
}

static void 
hbase_append_args_finalize (GObject *object)
{
  HbaseAppendArgs *tobject = HBASE_APPEND_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->append != NULL)
  {
    g_object_unref(tobject->append);
    tobject->append = NULL;
  }
}

static void
hbase_append_args_class_init (HbaseAppendArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = hbase_append_args_read;
  struct_class->write = hbase_append_args_write;

  gobject_class->finalize = hbase_append_args_finalize;
  gobject_class->get_property = hbase_append_args_get_property;
  gobject_class->set_property = hbase_append_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_APPEND_ARGS_APPEND,
     g_param_spec_object ("append",
                         NULL,
                         NULL,
                         TYPE_T_APPEND,
                         G_PARAM_READWRITE));
}

GType
hbase_append_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (HbaseAppendArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) hbase_append_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (HbaseAppendArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) hbase_append_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "HbaseAppendArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _HbaseAppendResultProperties
{
  PROP_HBASE_APPEND_RESULT_0,
  PROP_HBASE_APPEND_RESULT_SUCCESS,
  PROP_HBASE_APPEND_RESULT_IO
};

/* reads a hbase_append_result object */
static gint32
hbase_append_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  HbaseAppendResult * this_object = HBASE_APPEND_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              TCell * _elem188 = NULL;
              if ( _elem188 != NULL)
              {
                g_object_unref (_elem188);
              }
              _elem188 = g_object_new (TYPE_T_CELL, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem188), protocol, error)) < 0)
              {
                g_object_unref (_elem188);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->success, _elem188);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->io != NULL)
          {
            g_object_unref (this_object->io);
          }
          this_object->io = g_object_new (TYPE_I_O_ERROR, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
          {
            g_object_unref (this_object->io);
            this_object->io = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_io = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
hbase_append_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  HbaseAppendResult * this_object = HBASE_APPEND_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "HbaseAppendResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_LIST, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i189;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->success ? this_object->success->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i189 = 0; i189 < (this_object->success ? this_object->success->len : 0); i189++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->success, i189))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_io == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "io", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
hbase_append_result_set_property (GObject *object,
                                  guint property_id,
                                  const GValue *value,
                                  GParamSpec *pspec)
{
  HbaseAppendResult *self = HBASE_APPEND_RESULT (object);

  switch (property_id)
  {
    case PROP_HBASE_APPEND_RESULT_SUCCESS:
      if (self->success != NULL)
        g_ptr_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    case PROP_HBASE_APPEND_RESULT_IO:
      if (self->io != NULL)
        g_object_unref (self->io);
      self->io = g_value_dup_object (value);
      self->__isset_io = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
hbase_append_result_get_property (GObject *object,
                                  guint property_id,
                                  GValue *value,
                                  GParamSpec *pspec)
{
  HbaseAppendResult *self = HBASE_APPEND_RESULT (object);

  switch (property_id)
  {
    case PROP_HBASE_APPEND_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    case PROP_HBASE_APPEND_RESULT_IO:
      g_value_set_object (value, self->io);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
hbase_append_result_instance_init (HbaseAppendResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_success = FALSE;
  object->io = NULL;
  object->__isset_io = FALSE;
}

static void 
hbase_append_result_finalize (GObject *object)
{
  HbaseAppendResult *tobject = HBASE_APPEND_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_ptr_array_unref (tobject->success);
    tobject->success = NULL;
  }
  if (tobject->io != NULL)
  {
    g_object_unref(tobject->io);
    tobject->io = NULL;
  }
}

static void
hbase_append_result_class_init (HbaseAppendResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = hbase_append_result_read;
  struct_class->write = hbase_append_result_write;

  gobject_class->finalize = hbase_append_result_finalize;
  gobject_class->get_property = hbase_append_result_get_property;
  gobject_class->set_property = hbase_append_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_APPEND_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_APPEND_RESULT_IO,
     g_param_spec_object ("io",
                         NULL,
                         NULL,
                         TYPE_I_O_ERROR,
                         G_PARAM_READWRITE));
}

GType
hbase_append_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (HbaseAppendResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) hbase_append_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (HbaseAppendResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) hbase_append_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "HbaseAppendResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _HbaseCheckAndPutArgsProperties
{
  PROP_HBASE_CHECK_AND_PUT_ARGS_0,
  PROP_HBASE_CHECK_AND_PUT_ARGS_TABLE_NAME,
  PROP_HBASE_CHECK_AND_PUT_ARGS_ROW,
  PROP_HBASE_CHECK_AND_PUT_ARGS_COLUMN,
  PROP_HBASE_CHECK_AND_PUT_ARGS_VALUE,
  PROP_HBASE_CHECK_AND_PUT_ARGS_MPUT,
  PROP_HBASE_CHECK_AND_PUT_ARGS_ATTRIBUTES
};

/* reads a hbase_check_and_put_args object */
static gint32
hbase_check_and_put_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  HbaseCheckAndPutArgs * this_object = HBASE_CHECK_AND_PUT_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->tableName != NULL)
          {
            g_free(this_object->tableName);
            this_object->tableName = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->tableName = g_byte_array_new();
          g_byte_array_append (this_object->tableName, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_tableName = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->row != NULL)
          {
            g_free(this_object->row);
            this_object->row = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->row = g_byte_array_new();
          g_byte_array_append (this_object->row, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_row = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if (this_object->column != NULL)
          {
            g_free(this_object->column);
            this_object->column = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->column = g_byte_array_new();
          g_byte_array_append (this_object->column, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_column = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_STRING)
        {
          if (this_object->value != NULL)
          {
            g_free(this_object->value);
            this_object->value = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->value = g_byte_array_new();
          g_byte_array_append (this_object->value, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_value = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->mput), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_mput = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 7:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              Text key190 = NULL;
              Text val191 = NULL;
              if (key190 != NULL)
              {
                g_free(key190);
                key190 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              key190 = g_byte_array_new();
              g_byte_array_append (key190, (guint8 *) data, (guint) len);
              g_free (data);
              if (val191 != NULL)
              {
                g_free(val191);
                val191 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              val191 = g_byte_array_new();
              g_byte_array_append (val191, (guint8 *) data, (guint) len);
              g_free (data);
              if (this_object->attributes && key190)
                g_hash_table_insert ((GHashTable *)this_object->attributes, (gpointer) key190, (gpointer) val191);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_attributes = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
hbase_check_and_put_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  HbaseCheckAndPutArgs * this_object = HBASE_CHECK_AND_PUT_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "HbaseCheckAndPutArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "tableName", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->tableName ? ((GByteArray *) this_object->tableName)->data : NULL, this_object->tableName ? ((GByteArray *) this_object->tableName)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "row", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->row ? ((GByteArray *) this_object->row)->data : NULL, this_object->row ? ((GByteArray *) this_object->row)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "column", T_STRING, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->column ? ((GByteArray *) this_object->column)->data : NULL, this_object->column ? ((GByteArray *) this_object->column)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "value", T_STRING, 5, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->value ? ((GByteArray *) this_object->value)->data : NULL, this_object->value ? ((GByteArray *) this_object->value)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "mput", T_STRUCT, 6, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->mput), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "attributes", T_MAP, 7, error)) < 0)
    return -1;
  xfer += ret;
  {
    Text key192 = NULL;
    Text val193 = NULL;
    GList *key_list = NULL, *iter = NULL;
    Text* keys;
    int i = 0, key_count;

    if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRING, this_object->attributes ? (gint32) g_hash_table_size ((GHashTable *) this_object->attributes) : 0, error)) < 0)
      return -1;
    xfer += ret;
    if (this_object->attributes)
      g_hash_table_foreach ((GHashTable *) this_object->attributes, thrift_hash_table_get_keys, &key_list);
    key_count = g_list_length (key_list);
    keys = g_newa (Text, key_count);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
      keys[i++] = (Text) iter->data;
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key192 = keys[i];
      val193 = (Text) g_hash_table_lookup (((GHashTable *) this_object->attributes), (gpointer) key192);

      if ((ret = thrift_protocol_write_binary (protocol,  key192 ? ((GByteArray *)  key192)->data : NULL,  key192 ? ((GByteArray *)  key192)->len : 0, error)) < 0)
        return -1;
      xfer += ret;

      if ((ret = thrift_protocol_write_binary (protocol,  val193 ? ((GByteArray *)  val193)->data : NULL,  val193 ? ((GByteArray *)  val193)->len : 0, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
hbase_check_and_put_args_set_property (GObject *object,
                                       guint property_id,
                                       const GValue *value,
                                       GParamSpec *pspec)
{
  HbaseCheckAndPutArgs *self = HBASE_CHECK_AND_PUT_ARGS (object);

  switch (property_id)
  {
    case PROP_HBASE_CHECK_AND_PUT_ARGS_TABLE_NAME:
      if (self->tableName != NULL)
        g_byte_array_unref (self->tableName);
      self->tableName = g_value_dup_boxed (value);
      self->__isset_tableName = TRUE;
      break;

    case PROP_HBASE_CHECK_AND_PUT_ARGS_ROW:
      if (self->row != NULL)
        g_byte_array_unref (self->row);
      self->row = g_value_dup_boxed (value);
      self->__isset_row = TRUE;
      break;

    case PROP_HBASE_CHECK_AND_PUT_ARGS_COLUMN:
      if (self->column != NULL)
        g_byte_array_unref (self->column);
      self->column = g_value_dup_boxed (value);
      self->__isset_column = TRUE;
      break;

    case PROP_HBASE_CHECK_AND_PUT_ARGS_VALUE:
      if (self->value != NULL)
        g_byte_array_unref (self->value);
      self->value = g_value_dup_boxed (value);
      self->__isset_value = TRUE;
      break;

    case PROP_HBASE_CHECK_AND_PUT_ARGS_MPUT:
      if (self->mput != NULL)
        g_object_unref (self->mput);
      self->mput = g_value_dup_object (value);
      self->__isset_mput = TRUE;
      break;

    case PROP_HBASE_CHECK_AND_PUT_ARGS_ATTRIBUTES:
      if (self->attributes != NULL)
        g_hash_table_unref (self->attributes);
      self->attributes = g_value_dup_boxed (value);
      self->__isset_attributes = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
hbase_check_and_put_args_get_property (GObject *object,
                                       guint property_id,
                                       GValue *value,
                                       GParamSpec *pspec)
{
  HbaseCheckAndPutArgs *self = HBASE_CHECK_AND_PUT_ARGS (object);

  switch (property_id)
  {
    case PROP_HBASE_CHECK_AND_PUT_ARGS_TABLE_NAME:
      g_value_set_boxed (value, self->tableName);
      break;

    case PROP_HBASE_CHECK_AND_PUT_ARGS_ROW:
      g_value_set_boxed (value, self->row);
      break;

    case PROP_HBASE_CHECK_AND_PUT_ARGS_COLUMN:
      g_value_set_boxed (value, self->column);
      break;

    case PROP_HBASE_CHECK_AND_PUT_ARGS_VALUE:
      g_value_set_boxed (value, self->value);
      break;

    case PROP_HBASE_CHECK_AND_PUT_ARGS_MPUT:
      g_value_set_object (value, self->mput);
      break;

    case PROP_HBASE_CHECK_AND_PUT_ARGS_ATTRIBUTES:
      g_value_set_boxed (value, self->attributes);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
hbase_check_and_put_args_instance_init (HbaseCheckAndPutArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->tableName = NULL;
  object->__isset_tableName = FALSE;
  object->row = NULL;
  object->__isset_row = FALSE;
  object->column = NULL;
  object->__isset_column = FALSE;
  object->value = NULL;
  object->__isset_value = FALSE;
  object->mput = g_object_new (TYPE_MUTATION, NULL);
  object->__isset_mput = FALSE;
  object->attributes = g_hash_table_new_full (g_str_hash, g_str_equal, thrift_string_free, thrift_string_free);
  object->__isset_attributes = FALSE;
}

static void 
hbase_check_and_put_args_finalize (GObject *object)
{
  HbaseCheckAndPutArgs *tobject = HBASE_CHECK_AND_PUT_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->tableName != NULL)
  {
    thrift_string_free(tobject->tableName);
    tobject->tableName = NULL;
  }
  if (tobject->row != NULL)
  {
    thrift_string_free(tobject->row);
    tobject->row = NULL;
  }
  if (tobject->column != NULL)
  {
    thrift_string_free(tobject->column);
    tobject->column = NULL;
  }
  if (tobject->value != NULL)
  {
    thrift_string_free(tobject->value);
    tobject->value = NULL;
  }
  if (tobject->mput != NULL)
  {
    g_object_unref(tobject->mput);
    tobject->mput = NULL;
  }
  if (tobject->attributes != NULL)
  {
    g_hash_table_destroy (tobject->attributes);
    tobject->attributes = NULL;
  }
}

static void
hbase_check_and_put_args_class_init (HbaseCheckAndPutArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = hbase_check_and_put_args_read;
  struct_class->write = hbase_check_and_put_args_write;

  gobject_class->finalize = hbase_check_and_put_args_finalize;
  gobject_class->get_property = hbase_check_and_put_args_get_property;
  gobject_class->set_property = hbase_check_and_put_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_CHECK_AND_PUT_ARGS_TABLE_NAME,
     g_param_spec_boxed ("tableName",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_CHECK_AND_PUT_ARGS_ROW,
     g_param_spec_boxed ("row",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_CHECK_AND_PUT_ARGS_COLUMN,
     g_param_spec_boxed ("column",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_CHECK_AND_PUT_ARGS_VALUE,
     g_param_spec_boxed ("value",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_CHECK_AND_PUT_ARGS_MPUT,
     g_param_spec_object ("mput",
                         NULL,
                         NULL,
                         TYPE_MUTATION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_CHECK_AND_PUT_ARGS_ATTRIBUTES,
     g_param_spec_boxed ("attributes",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));
}

GType
hbase_check_and_put_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (HbaseCheckAndPutArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) hbase_check_and_put_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (HbaseCheckAndPutArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) hbase_check_and_put_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "HbaseCheckAndPutArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _HbaseCheckAndPutResultProperties
{
  PROP_HBASE_CHECK_AND_PUT_RESULT_0,
  PROP_HBASE_CHECK_AND_PUT_RESULT_SUCCESS,
  PROP_HBASE_CHECK_AND_PUT_RESULT_IO,
  PROP_HBASE_CHECK_AND_PUT_RESULT_IA
};

/* reads a hbase_check_and_put_result object */
static gint32
hbase_check_and_put_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  HbaseCheckAndPutResult * this_object = HBASE_CHECK_AND_PUT_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->io != NULL)
          {
            g_object_unref (this_object->io);
          }
          this_object->io = g_object_new (TYPE_I_O_ERROR, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
          {
            g_object_unref (this_object->io);
            this_object->io = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_io = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ia != NULL)
          {
            g_object_unref (this_object->ia);
          }
          this_object->ia = g_object_new (TYPE_ILLEGAL_ARGUMENT, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ia), protocol, error)) < 0)
          {
            g_object_unref (this_object->ia);
            this_object->ia = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ia = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
hbase_check_and_put_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  HbaseCheckAndPutResult * this_object = HBASE_CHECK_AND_PUT_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "HbaseCheckAndPutResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_BOOL, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->success, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_io == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "io", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->io), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ia == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ia", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ia), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
hbase_check_and_put_result_set_property (GObject *object,
                                         guint property_id,
                                         const GValue *value,
                                         GParamSpec *pspec)
{
  HbaseCheckAndPutResult *self = HBASE_CHECK_AND_PUT_RESULT (object);

  switch (property_id)
  {
    case PROP_HBASE_CHECK_AND_PUT_RESULT_SUCCESS:
      self->success = g_value_get_boolean (value);
      self->__isset_success = TRUE;
      break;

    case PROP_HBASE_CHECK_AND_PUT_RESULT_IO:
      if (self->io != NULL)
        g_object_unref (self->io);
      self->io = g_value_dup_object (value);
      self->__isset_io = TRUE;
      break;

    case PROP_HBASE_CHECK_AND_PUT_RESULT_IA:
      if (self->ia != NULL)
        g_object_unref (self->ia);
      self->ia = g_value_dup_object (value);
      self->__isset_ia = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
hbase_check_and_put_result_get_property (GObject *object,
                                         guint property_id,
                                         GValue *value,
                                         GParamSpec *pspec)
{
  HbaseCheckAndPutResult *self = HBASE_CHECK_AND_PUT_RESULT (object);

  switch (property_id)
  {
    case PROP_HBASE_CHECK_AND_PUT_RESULT_SUCCESS:
      g_value_set_boolean (value, self->success);
      break;

    case PROP_HBASE_CHECK_AND_PUT_RESULT_IO:
      g_value_set_object (value, self->io);
      break;

    case PROP_HBASE_CHECK_AND_PUT_RESULT_IA:
      g_value_set_object (value, self->ia);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
hbase_check_and_put_result_instance_init (HbaseCheckAndPutResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
  object->io = NULL;
  object->__isset_io = FALSE;
  object->ia = NULL;
  object->__isset_ia = FALSE;
}

static void 
hbase_check_and_put_result_finalize (GObject *object)
{
  HbaseCheckAndPutResult *tobject = HBASE_CHECK_AND_PUT_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->io != NULL)
  {
    g_object_unref(tobject->io);
    tobject->io = NULL;
  }
  if (tobject->ia != NULL)
  {
    g_object_unref(tobject->ia);
    tobject->ia = NULL;
  }
}

static void
hbase_check_and_put_result_class_init (HbaseCheckAndPutResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = hbase_check_and_put_result_read;
  struct_class->write = hbase_check_and_put_result_write;

  gobject_class->finalize = hbase_check_and_put_result_finalize;
  gobject_class->get_property = hbase_check_and_put_result_get_property;
  gobject_class->set_property = hbase_check_and_put_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_CHECK_AND_PUT_RESULT_SUCCESS,
     g_param_spec_boolean ("success",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_CHECK_AND_PUT_RESULT_IO,
     g_param_spec_object ("io",
                         NULL,
                         NULL,
                         TYPE_I_O_ERROR,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HBASE_CHECK_AND_PUT_RESULT_IA,
     g_param_spec_object ("ia",
                         NULL,
                         NULL,
                         TYPE_ILLEGAL_ARGUMENT,
                         G_PARAM_READWRITE));
}

GType
hbase_check_and_put_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (HbaseCheckAndPutResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) hbase_check_and_put_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (HbaseCheckAndPutResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) hbase_check_and_put_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "HbaseCheckAndPutResultType",
                                   &type_info, 0);
  }

  return type;
}

